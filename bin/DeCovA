#!/usr/bin/perl


##depth analysis of bam files
##at regions defined by a bed file or a list of genes
##makes R graphs, with depth line and not covered domains, at different thresholds

##thomas Simonet, CHU de Lyon, 2014 (thomas.simonet@chu-lyon.fr)
##Pierre-Antoine Rollat-Farnier, CHU de Lyon, 2015
##Vincent Danjean, 2016

##This program is a free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>


our $VERSION="1.5.3";

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Find;
use Cwd 'abs_path';
use lib dirname(abs_path($0))."/../lib";
use Bio::NGS::HCL::DeCovA::CNV_tool;


############
#parameters:

Getopt::Long::Configure ("bundling");
my%opt = ();
GetOptions (\%opt, 
	"file|f=s@",
	"dir|d=s@",
	"suffix|s=s",
	"refseq|r=s",
	"bed|b=s",
	"mut|m=s",
	"outdir|O=s",
	"outfile|o=s",
	"id|i=s@",
	"nonCoding|N",
	"depthThreshold|t=s@",
	"printThreshold|T=i",
	"noGraphThreshold",
	"noUTR|U",
	"noUTRinTxt|u",
	"maxDepth=i",
	"expand2val|l=s",
	"UDstream=s",
	"splitBedFromId",
	"mergeBedFromId",
	"expand2bed|L",
	"Ltxt:s",
	"UDtxt:s",
	"Lbed=i",
	"noReverse|R",
	"graphSum|S",
	"allSample|A",
	"bySample|X",
	"noAllTranscripts",
	"noDepthMut|M",
	"covPlot|P",
	"covBed|B",
	"bedReport",
	"Reseq=f",
	"cov_fields|F=s@",
	"geneReport",
	"summary:s",
	"keepCov|k",
	"keepBed|K:s",
	"raw_cov=s@",
	"binPlot=i",
	"maxPlot=i",
	"genePlot",
	"interPlot",
	"gatk:s",
	"ram|x=i",
	"cpu=i",
	"bedtools=s",
	"samtools=s",
	"picard=s",
	"genome|g=s",
	"dedup:s",
	"mbq=i",
	"mmq=i",
	"CNV|C",
	"sex_file=s",
	"bed_cov=s",
	"split_bed",
	"no_overlap_bed",
	"cut_bed:s",
	"reAnnot_bed",
	"level2=s",
	"spread2=s",
	"level_del=f",
	"level_dup=f",
	"spread_del=f",
	"spread_dup=f",
	"range=f",
	"highQual=s",
	"ex_region=f",
	"ex_sample=f",
	"ex_cov=f",
	"ex_DP=i",
	"max_nonCNVcons=i",
	"max_nonCNVrate=f",
	"ratioByGender=s",
	"normAllChr",
	"normDepth=s",
	"graph_byGene:s",
	"graph_byChr:s",
	"graph_byCNV:s",
	"CNV_fields=s@",
	"compress|z",
	"nGraph:i",
	"version|v",
	"help|h") or die "Invalid parameters: $! \n";

unless(%opt) { usage(); }

if (exists $opt{help}) { usage(); }

if (exists $opt{version}) { die "$VERSION\n"; }

if(@ARGV) {
	print"Invalid parameters:\n";
	foreach(@ARGV) { print"\t$_\n"; }
	die "(forgotten \"-\"?)\n";
	}

sub usage
{
die "usage:
	as a script:		perl /path/to/DeCovA [option]
	or after installation:	DeCovA [option]

options:

inputs:
	-f / --file : list of bam files (comma separated, or set several times), or file with such a list (ended with \".list\"; one bam per line)
	-d / --dir : directory(ies) where to find bam files (comma separated, or set several times)
	-s / --suffix : suffix to add before opening bam files
	-r / --refseq : RefSeq file (required)
	-b / --bed : bed file, used to analyse depth coverage
	-m / --mut : mut file, used to plot known mutations ; format: \"chr	pos(1-based)	info\" (vcf files are ok)
	-i / --id : list of of refseq genes/transcripts id (comma separated, or set several times), or file with such a list (\".list\")
	-g / --genome : path to genome.fa file, if available (required if using GATK)
	--sex_file : format: patient\tsex
	--raw_cov : use this coverage tool output .cov file (to skip bam analysis) (gatk output only supported)
	--bed_cov : use this DeCovA's output .cov.txt file (to skip cov bed analysis in CNV detect)

outputs:
	-o / --outfile : text outfile name (default: cov_samplename.txt)
	-O / --outdir : out directory (default: folder named with date)
	-S / --graphSum : will perform graphSums (sum of covered samples by position)
	-A / --allSample : will perform graphAllSample (depthline by gene and by sample, all samples graph on same .png file)
	-X / --bySample : will perform graphBySample (depthline by gene and by sample, one sample by .png file)
	-M / --noDepthMut : does not print, foreach file, depth at known mutations provided by opt -m (default: yes if -opt m)
	-P / --covPlot : will perform covPlots
	-B / --covBed : will output cov of bed intervals
	-C / --CNV : will output CNV foreach bed intervals
	--Reseq : float [0-1] : print bed interval if cov < value (def: do not print)
	--geneReport : will print all uncovered genomic intervals (within gene region) in 1 txt file per sample (default: no)
	--bedReport : will print all uncovered intervals (within bed intervals) in 1 txt file per sample (default: no)
	--summary : (Y/N) : to print summary txt file (default: yes if -S -A -X)
	-k / --keepCov : do not erase coverage file at the end of the process
	-K / --keepBed : do not erase bed file inferred from gene list, at the end of the process (and eventually rename)

parameters:
  *refseq gene analysis:
	-N / --nonCoding : analyse also Non coding transcripts (default: no)
	-U / --noUTR : does not take into account UTR regions, for graphs (default: yes)
	-u / --noUTRinTxt : does not take into account UTR regions, for summary txt file and plots (default: yes)
	-t / --depthThreshold : depth thresholds, comma separated
	-T / --printThreshold : depth threshold used for txt outputs (must be one of those in opt -t; default : the smallest one)
	--noGraphThreshold : all graphs will be printed, whatever the coverage 
		(default: only the genes not fully covered at threshold in -opt -T will be drawn)
	--noAllTranscripts : does not print All transcripts on same file, in graphBySample (default: yes)
	--maxDepth : max depth value when printing graph (optional)
	-l / --expand2val : int: length to add at each ends of exons, on graphs (default: 0) ; or int1,int2 : lengths to add in 5' and 3'
	--UDstream : int: length to add at each ends of genes, on graphs ; or int1,int2 : lengths to add upstram and downstream
	--splitBedFromId : if padding creates overlapping exons, take the mid between them (for report)
	--mergeBedFromId : merge overlapping exons
	-L / --expand2bed : expand length of gene analysed regions to bed coord, if -l < bed , on graphs (default: no)
	--Ltxt : does take into account expanded length (from -l and -L) for txt outputs (default: no), or add a different length
	--UDtxt : does take into account up/downStream length for txt outputs (default: no), or add a different length
	-R / --noReverse : does not reverse regions if sens of transcript = (-) (default: yes)
	--nGraph : max nber of graphs per sheet (default : all samples or all transcripts)

  *plot param:
	--binPlot : bin width for covPlot (default=10)
	--maxPlot : max depth for covPlot (default=100)
	--genePlot : will perform plots for regions extracted from genes coord, not only for bed intervals (default: no)
	--interPlot : will produce intersection covPlot (default: no)

  *bam filters
 	--dedup : do not take in account dup reads (default keep all reads; enter \"do\" to perform Picard deduplication) 
	--mbq : minimum base quality (default 0; requires gatk)
	--mmq : minimum mapping quality (default 0)

  *cov_bed param:
	-F / --cov_fields : fields foreach intervals in covBed (comma separated), among: min, max, tot, mean, median, cov 
		(default: min,mean,cov)
	--Lbed : length added out of bed interval ends (default: 0)
	--split_bed : splits overlapping bed intervals for Cov and CNV analyses
	--no_overlap_bed : removes overlapping bed intervals for Cov and CNV analyses
	--cut_bed : cut bed intervals in shorter fragments: cutL:x,minL:y,maxL:z,keepLast:s
				cutL : length of segmentation (def: 150)
				minL : min length required to keep the last interval, after segmentation (def: --cutL/2)
				maxL : length above which bed intervals will be segmented, in N segments of \"cutL\" length (def: as --cutL)
				keepLast : if last interval shorter than minL :
						enter m (merge) if want that last two ones are simply merged
						enter h (half) if want that last two ones are output with length = half of their sum
						enter n if want to through it out
	--reAnnot_bed : removes and replaces 4th column of bed file with gene info

  *CNV_detect param:
	--level2 : \"avg\"/\"med\" : use average/median as center of depths of a region (def: med)(if spread2 is set, level2 is unset, unless explicitedly)
	--spread2 : \"std\"/\"qtile\" : use standard deviation/deviation from quartile as dispersion of depths of a region (def: none)(std forces avg, qtile forces med)
	--level_del : float , [0-1] (def: 0.8)
	--level_dup : float , >1 (def: 1.2)
	--spread_del : float , <0 (def: none)
	--spread_dup : float , >0  (def: none)
	--range : samples kept for avg-std calculation if within mediane+/-range*quartile (def: none, ie all samples used)
	--highQual : flag as high qual if one of following criteria : enter li/ls/si/ss/c for level inf-sup / spread inf/sup / consecutive :\n\t\t\tex : li:0.25,ls:1.75,si:-5,ss:-5,c:2
	--ex_region : float [0-1] : region excluded from analysis if CNVs/N_samples >value (def: 1)
	--ex_sample : float [0-1] : sample excluded from analysis if CNVs/N_regions >value (def: 1)
	--ex_cov : float [0-1] : region excluded from analysis if none of the samples have cov >=value (def: 0)
	--ex_DP : int : region excluded from analysis if avg depth <=value (def: 0)
	--max_nonCNVcons : max nber of non-CNV consecutive intervals tolerated within a CNV (def: 0)
	--max_nonCNVrate : max rate of non-CNV intervals tolerated within a CNV (def: 0)
	--ratioByGender :	enter \"a\" : foreach region from all chrom, depth ratio computed separately for F and M ; 
				enter \"g\" : foreach region from gonosomes only, depth ratio computed separately for F and M
				def: no (depth ratio for F and M together)
	--normAllChr : total depth used to norm sample depths = sum on all chr, whatever the sex (def: double the depth for chrX if male, and skip chrY in the sum)
	--normDepth : \"mean\"/\"tot\" : total depth used to norm sample depths = sum of total depths of each region or sum of mean depths of each region (def)
	--graph_byGene : to enable graph for gene affected by a CNV (def: no)
	--graph_byChr : to enable graph by chromosome (def: no)
	--graph_byCNV : to enable graph around each CNV (def: yes)
	--CNV_fields : fields foreach region (comma separated), among: min,max,med,avg,std,Q1,Q3 (default: none)

  *external tools path:
	--bedtools : enter path to executable, if not installed as root or not in path
	--samtools : enter  path to executable, if not installed as root
	--picard : enter path to executable .jar, if not installed as root
	--gatk : cov analysis will be performed by gatk (default:bedtools; enter path to executable, if not installed as root)

  *general:
	-x / --ram : memory for gatk (in Go)
	--cpu : multi-thread for gatk (def: 1)
	-z / --compress : archive output folder
	-v / --version : current version 
	-h / --help : help
	\n";
}

##inputs:

#-d: directory
my@dir = ();
if (exists $opt{dir}) {
	foreach (@{ $opt{dir} }) {
		if ($_ =~ /.list$/) {
			open(LIST, $_) || die "can't open file $_\n";
			while (my$line=<LIST>) {
				unless ($line =~ /^\s*$/) {
					$line =~ s/\s*$//;
					push (@dir, $line);
					}
				}
			close LIST;
			}
		else
			{ push(@dir, split(/,/, $_)); }
		}
	foreach (@dir) {
		unless( -d $_ ) 
			{ die "$_ directory not found\n"; }
		unless ($_ =~ /\/$/) { $_ .= "/"; } 
		}
	}
#-f: files
my$suff = "";
if (exists $opt{suffix}) { 
	$suff = $opt{suffix}; 
	$suff =~ s/.bam$//;
	}
my@Files = ();
if (exists $opt{file}) {
	foreach (@{ $opt{file} }) {
		if ($_ =~ /.list$/) {
			open(LIST, $_) || die "can't open file $_\n";
			while (my$line=<LIST>) {
				unless ($line =~ /^\s*$/) {
					$line =~ s/\s*$//;
					push (@Files, $line);
					}
				}
			close LIST;
			}
		else
			{ push(@Files, split(/,/, $_)); }
		}
	}
else { 
	foreach my$dir(@dir) {
		find(\&subDir, $dir);
		}
	}
sub subDir
{
if ($suff) {
	if (-f $_ && $_=~/$suff.bam$/) 
		{ push(@Files, $File::Find::name); }
	}
else {
	if (-f $_ && $_=~/.bam$/) 
		{ push(@Files, $File::Find::name); }
	}
}
my(%fName,%path);	#fName: name of file, without path and extension
my$extenS = "$suff.bam";
if (@Files) {
	print "file(s) to analysed:\n";
	foreach (@Files) {
		($fName{$_},$path{$_}) = fileparse($_,$extenS);
		if (exists $opt{dir} && exists $opt{file}) {
			if (scalar@dir>1) { die "not possible to affect path to files if several paths specified\n"; }
			else { $path{$_} = $dir[0]; }
			}
		if ( -f "$path{$_}$fName{$_}$extenS" ) 
			{ print "\t$path{$_}$fName{$_}$extenS\n"; }
		else { die "$path{$_}$fName{$_}$extenS file not found\n"; }
		}
	}

my$ref="";
if (exists $opt{refseq}) { $ref = $opt{refseq}; }

my$bedFile="";
if (exists $opt{bed}) { $bedFile = $opt{bed}; }
my$bedName="";
if($bedFile) 
	{ $bedName = fileparse($bedFile,".bed"); }

my$mutFile="";
if (exists $opt{mut}) { $mutFile = $opt{mut}; }

my$outfile="cov_";
if ($opt{outfile})
	{ $outfile=$opt{outfile}; }

my(@IDs,%IDs);
if (exists $opt{id}) {
	if ($opt{id}[0] =~ /.list$/) {
		open(LIST, "<", $opt{id}[0]) || die "can't open file ".$opt{id}[0]."\n";
		while (my$line=<LIST>) {
			unless($line =~ /^\s*$/ || $line =~ /^#/) {
				chomp $line;
				$line =~ s/\s//g;
				push(@IDs, $line);
				}
			}
		close LIST;
		}
	else { @IDs = split(/,/, join(',',@{$opt{id}})); }
	foreach my$id(@IDs) { 
		if ($id =~ /^N[MR]_/)
			{ $id =~ s/\.(\d+)$//; }
		$IDs{$id} = 1;
		}
	@IDs = sort(keys%IDs);
	print "Regions to analyse: \n";
	foreach my$id(@IDs)
		{ print "\t".$id."\n"; }
	}

my@raw_cov_file = ();
if (exists $opt{raw_cov}) {
	@raw_cov_file = split(/,/, join(',',@{$opt{raw_cov}}));
	foreach (@raw_cov_file) {
		unless ( -s "$_" ) { die "$_ cov file not found or empty\n"; }
		}
	}
if (@Files && @raw_cov_file) { die "must choose between providing bam files or cov files\n"; }

my$bed_cov_file = "";
if (exists $opt{bed_cov}) { 
	if (-e $opt{bed_cov}) { $bed_cov_file = $opt{bed_cov}; }
	else { die "$bed_cov_file file not found\n"; }
	}

my$genom = "";
if (exists $opt{genome}) { 
	$genom = $opt{genome}; 
	}

my$fichier_sexe = "";
if (exists $opt{sex_file}) { 
	if (-e $opt{sex_file}) { $fichier_sexe = $opt{sex_file}; }
	else { die "$fichier_sexe file not found\n"; }
	}

##jobs
my%jobs = ();
$jobs{"bedReport"} = 0;
if (exists $opt{bedReport})
	{ $jobs{"bedReport"} = 1; }
$jobs{"graphSum"} = "";
if (exists $opt{graphSum})
	{ $jobs{"graphSum"} = 1; }
$jobs{"graphAllSampls"} = "";
if (exists $opt{allSample})
	{ $jobs{"graphAllSampls"} = 1; }
$jobs{"graphBySample"} = "";
if (exists $opt{bySample})
	{ $jobs{"graphBySample"} = 1; }
$jobs{"covMut"} = "";
if ($mutFile) { $jobs{"covMut"} = 1; }
if (exists $opt{noDepthMut})
	{ $jobs{"covMut"} = ""; }
$jobs{"covPlot"} = "";
if (exists $opt{covPlot})
	{ $jobs{"covPlot"} = 1; }
$jobs{"interSplot"} = "";
if (exists $opt{interPlot})
	{ $jobs{"interSplot"} = 1; }
$jobs{"genePlot"} = "";
if (exists $opt{genePlot})
	{ $jobs{"genePlot"} = 1; }
$jobs{"covBed"} = "";
if (exists $opt{covBed})
	{ $jobs{"covBed"} = 1; }
$jobs{"2Reseq"} = "";
if (exists $opt{Reseq})
	{ $jobs{"2Reseq"}=$opt{Reseq}; }
$jobs{"CNV"} = "";
if (exists $opt{CNV}) {
	$jobs{"CNV"} = 1; 
	}
$jobs{"geneReport"} = "";
if (exists $opt{geneReport})
	{ $jobs{"geneReport"} = 1; }
$jobs{"geneSummary"} = "";
if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"})		# || @IDs)
	{ $jobs{"geneSummary"} = 1; }
if (exists $opt{summary}) {
	if ($opt{summary}) {
		if ($opt{summary} =~ /^y|^o/i) { $jobs{"geneSummary"} = 1; }
		elsif ($opt{summary} =~ /^n/i) { $jobs{"geneSummary"} = ""; }
		else { die "opt summary no recognized (y/n)"; }
		}
	else { $jobs{"geneSummary"} = 1; }
	}
$jobs{"keepCov"} = "";
if (exists $opt{keepCov}) { $jobs{"keepCov"} = 1; }
$jobs{"keepBed"} = "";
my$keepBedName = "";
if ($bedName) { $keepBedName = $bedName; }
else { $keepBedName = "allID"; }
my$keepBedDir = ".";
if (exists $opt{keepBed}) {
	$jobs{"keepBed"} = 1;
	if ($opt{keepBed}) { 
		#$keepBedName = $opt{keepBed};
		#$keepBedName =~ s/\.bed$//;
		if (-f $opt{keepBed}) { die "$opt{keepBed} already exists\n"; }
		my($name,$dir) = fileparse($opt{keepBed},".bed");
		if ($name) { $keepBedName = $name; }
		if ($dir) {
			if (-d $keepBedDir) { $keepBedDir = $dir; }
			else { die "$keepBedDir not found\n"; }
			}
		}
	}

##refseq gene analysis param
my(@Thresholds,$pThreshold);
if (exists $opt{printThreshold})
	{ $pThreshold = $opt{printThreshold}; }
if (exists $opt{depthThreshold}) {
	@Thresholds = split(/,/, join(',',@{$opt{depthThreshold}}));
	foreach (@Thresholds) {
		if ($_ =~ /^\d+$/) { print "depth threshold: $_\n"; }
		else { die "$_ depth threshold value need to be an integer\n"; }
		}
	@Thresholds = sort{$b<=>$a}@Thresholds;	#decroissant
	#check if $pThreshold one of those in @Thresholds
	if ($pThreshold) {
		my$ok=0;
		foreach (@Thresholds) {
			if ($pThreshold==$_) 
				{ $ok=1; last; }
			}
		unless ($ok) 
			{ die "opt -T threshold value need to be 1 of those in opt -t\n"; }
		}
	else { $pThreshold = $Thresholds[-1]; }
	print "threshold for summary: $pThreshold \n";
	}
else { 
	if ($pThreshold) { @Thresholds = ($pThreshold); }
	}
##regions extent
my$nonCod = "";
if (exists $opt{nonCoding})
	{ $nonCod = 1; }

my$wUTR = 1;
if (exists $opt{noUTR})
	{ $wUTR = 0; }
my$UTRinTxt = 1;
if (exists $opt{noUTRinTxt})
	{ $UTRinTxt = 0; }
if ($nonCod && (!$wUTR || !$UTRinTxt))
	{ die "nonCoding inclusion not compatible with UTR exclusion\n"; }

my$maxGr = ""; #max depth for graphs
if (exists $opt{maxDepth}) { 
	if ($opt{maxDepth} =~ /^\d+$/) { $maxGr = $opt{maxDepth}; }
	else { die "--maxCov opt value need to be an integer\n"; }
	}

my$len5 = 0; my$len3 = 0;
if (exists $opt{expand2val}) {
	if ($opt{expand2val} =~ /,/) {
		my@len = split(/,/,$opt{expand2val});
		$len5 = $len[0];
		$len3 = $len[1];
		}
	else {
		$len5 = $opt{expand2val};
		$len3 = $opt{expand2val};
		}
	}

my$splitBedFromId = 0;
if (exists $opt{splitBedFromId}) { $splitBedFromId = 1; }
my$mergeBedFromId = 0;
if (exists $opt{mergeBedFromId}) { $mergeBedFromId = 1; }

my$lenTxt5 = 0; my$lenTxt3 = 0;
if (exists $opt{Ltxt}) {
	if ($opt{Ltxt}) {
		if ($opt{Ltxt} =~ /,/) {
			my@len = split(/,/,$opt{Ltxt});
			$lenTxt5 = $len[0];
			$lenTxt3 = $len[1];
			}
		else {
			$lenTxt5 = $opt{Ltxt};
			$lenTxt3 = $opt{Ltxt};
			}
		}
	else { $lenTxt5 = $len5; $lenTxt3 = $len3; }
	}

my$upstream = 0; my$downstream = 0;
if (exists $opt{UDstream}) {
	if ($wUTR) {
		if ($opt{UDstream} =~ /,/) {
			my@len = split(/,/,$opt{UDstream});
			$upstream = $len[0];
			$downstream = $len[1];
			}
		else {
			$upstream = $opt{UDstream};
			$downstream = $opt{UDstream};
			}
		if ($upstream <= $len5) { $upstream = 0; }
		if ($downstream <= $len3) { $downstream = 0; }
		#if ($upstream < $len5 || $downstream < $len3)
		#	{ die "upstream/downstream expansion must be longer than padding $upstream <= $len5  $downstream <= $len3\n"; }
		}
	else { die "upstream/downstream expansion not compatible without UTR\n"; }
	}

my$UpInTxt = 0 ; my$DownInTxt = 0;
if (exists $opt{UDtxt}) {
	if ($opt{UDtxt}) {
		if ($wUTR) {
			if ($opt{UDtxt} =~ /,/) {
				my@len = split(/,/,$opt{UDtxt});
				$UpInTxt = $len[0];
				$DownInTxt = $len[1];
				}
			else {
				$UpInTxt = $opt{UDtxt};
				$DownInTxt = $opt{UDtxt};
				}
			if ($UpInTxt <= $lenTxt5) { $UpInTxt = 0; }
			if ($DownInTxt <= $lenTxt3) { $DownInTxt = 0; }
			#if ($UpInTxt < $lenTxt5 || $DownInTxt < $lenTxt3)
			#	{ die "upstream/downstream expansion must be longer than padding $UpInTxt <= $lenTxt5 || $DownInTxt <= $lenTxt3\n"; }
			}
		else { die "upstream/downstream expansion not compatible without UTR\n"; }
		}
	else { $UpInTxt = $upstream; $DownInTxt = $downstream; }
	}

my$Expand = "";
if (exists $opt{expand2bed})
	{ $Expand = 1; }

my$spacer = 0;

my$Rev = 1;
if (exists $opt{noReverse})
	{ $Rev = 0; }

my$AllTranscripts = 1;		##all transcripts on same graph; no longer disable possibility
if (exists $opt{noEachTranscript}) 
	{ $AllTranscripts = 0; }

my$gThreshold = 1;
if (exists $opt{noGraphThreshold})
	{  $gThreshold=""; }

my$nGraf = "max";
if (exists $opt{nGraph} && $opt{nGraph}!=0)
	{ $nGraf = $opt{nGraph}; }

## plots param
my$bin = 10; #nber of bin for bar plots
if (exists $opt{binPlot})
	{ $bin = $opt{binPlot}; }
my$maxPl = 100; #max depth for bar plots
if (exists $opt{maxPlot})
	{ $maxPl = $opt{maxPlot}; }
if (($maxPl % $bin) != 0) { die "binPlot needs to be a multiple of maxPlot\n"; }

##external tools paths and param
my$bedT = "";
if (exists $opt{bedtools})
	{ $bedT = $opt{bedtools}; }
my$samT = "";
if (exists $opt{samtools})
	{ $samT = $opt{samtools}; }
my$picard = "";
if (exists $opt{picard})
	{ $picard = $opt{picard}; }
my$gatk = "";
if (exists $opt{gatk}) { 
	$gatk = $opt{gatk}; 
	if (!$gatk) { $gatk = 1; }	#if exists, but no value: means, just use it, but will test the default command
	}
my$ram = "";
if (exists $opt{ram}) { 
	$ram = $opt{ram};
	}
my$threads = "";
if (exists $opt{cpu}) { 
	$threads = $opt{cpu};
	}
my$dedup = "";
if (exists $opt{dedup}) { 
	if ($opt{dedup} eq "do") { $dedup = "do"; }
	elsif ($opt{dedup} eq "") { $dedup = 1; }
	else { die "not recognized value for --dedup arg.\n"; }
	}
my$mbq = "";
if (exists $opt{mbq}) {
	if ($opt{mbq} =~ /^\d+$/) { $mbq = $opt{mbq}; }
	else { die "mbq value need to be an integer\n"; }
	}
my$mmq = "";
if (exists $opt{mmq}) {
	if ($opt{mmq} =~ /^\d+$/) { $mmq = $opt{mmq}; }
	else { die "mmq value need to be an integer\n"; }
	}
my$gz = "";
if (exists $opt{compress})
	{ $gz = 1; }

##bed param
my$lenForBed = 0;
if (exists $opt{Lbed}) {
	if ($opt{Lbed} =~ /^\d+$/) { $lenForBed = $opt{Lbed}; }
	else { die "--Lbed value need to be an integer\n"; }
	}

my$splitBed = "";
if (exists $opt{split_bed}) { $splitBed = 1; }

my$rmOverlapBed = "";
if (exists $opt{no_overlap_bed}) { $rmOverlapBed = 1; }

my$cutBed = "";
my%cutB_opt = ();
if (exists $opt{cut_bed}) { 
	$cutBed = 1;
	$cutB_opt{"cutL"}=150; $cutB_opt{"maxL"}=150; $cutB_opt{"minL"}=75; $cutB_opt{"keepLast"}="merge";
	if ($opt{cut_bed}) {	## cutL:x,minL:y,maxL:z,keepLast:s
		my@cutB_arg = split(/,/,$opt{cut_bed});
		my$minL=""; my$maxL="";
		foreach my$a (@cutB_arg) {
			my$ok=0;
			foreach my$o (keys%cutB_opt) {
				if ($a =~ /$o:(.+)/) {
					if ($o eq "minL") { $minL=1; }
					if ($o eq "maxL") { $maxL=1; }
					if ($o eq "keepLast") {
						if ($1 =~ /^m/i) { $cutB_opt{"$o"} = "merge"; }
						elsif  ($1 =~ /^h/i) { $cutB_opt{"$o"} = "half"; }
						elsif  ($1 =~ /^n/i) { $cutB_opt{"$o"} = ""; }
						else { die "cut_bed opt \"keepLast\" not recognized ($1?) (\"h\" , \"m\" or \"n\")\n"; }
						}
					else { $cutB_opt{"$o"} = $1; }
					$ok=1;
					}

				

				}
			unless ($ok) { die "cut_bed opt not recognized ($a?)\n"; }
			}
		unless ($minL) { $cutB_opt{"minL"} = int($cutB_opt{"cutL"}/2); }
		unless ($maxL) { $cutB_opt{"maxL"} = $cutB_opt{"cutL"}; }
		}
	}
#if ($splitBed && $cutBed) { die "not able to split overlapping and cut long intervals, sorry...\n";}

my$reAnnotBed = "";
if (exists $opt{reAnnot_bed}) { $reAnnotBed = 1; }

my@covFields =(); 
if ($pThreshold) { @covFields = ("min","mean","cov"); }
else { @covFields = ("min","mean","tot"); }
my%covFieldList = ("min"=>1,"max"=>1,"tot"=>1,"mean"=>1,"median"=>1,"cov"=>1);
if (exists $opt{cov_fields}) {
	@covFields = split(/,/, join(',',@{$opt{cov_fields}}));
	foreach (@covFields) {
		unless (exists $covFieldList{$_}) { die "cov field not recognized (min,max,tot,mean,median,cov)\n"; }
		}
	}

## CNV param
my%CNV_opt;
$CNV_opt{"center"} = "med";
if (exists $opt{spread2}) { $CNV_opt{"center_test"} = 0; }
else { $CNV_opt{"center_test"} = 1; }
if (exists $opt{level2}) {
	if ($opt{level2} =~ /^avg/i) { $CNV_opt{"center"} = "avg"; }
	elsif ($opt{level2} =~ /^med/i) { $CNV_opt{"center"} = "med"; }
	else { die "opt --level2 not recognized (avg/med)\n"; }
	$CNV_opt{"center_test"} = 1;
	}
if (exists $opt{spread2}) {
	if ($opt{spread2} =~ /^std/i) { $CNV_opt{"spread"} = "std"; $CNV_opt{"center"} = "avg"; }
	elsif ($opt{spread2} =~ /^q/i) { $CNV_opt{"spread"} = "Qtile"; $CNV_opt{"center"} = "med"; }
	else { die "opt --spread2 not recognized (std/qtile)\n"; }
	$CNV_opt{"spread_test"} = 1;
	}
$CNV_opt{"seuil_del"} = 0.8;
if (exists $opt{level_del}) { $CNV_opt{"seuil_del"} = $opt{level_del}; }
$CNV_opt{"seuil_dup"} = 1.2;
if (exists $opt{level_dup}) { $CNV_opt{"seuil_dup"} = $opt{level_dup}; }
if (exists $opt{spread_del}) { $CNV_opt{"spread_del"} = $opt{spread_del}; }
if (exists $opt{spread_dup}) { $CNV_opt{"spread_dup"} = $opt{spread_dup}; }
if (exists $opt{range}) { $CNV_opt{"range"} = $opt{range}; }
if (exists $opt{highQual}) {
	my@tab1 = split(/,/,$opt{highQual});
	foreach my$string (@tab1) {
		my@tab2 = split(/:/,$string);
		if ($tab2[0] =~ /^li/i) { $CNV_opt{"trueCNV"}{"level"}{"del"} = $tab2[1]; }
		elsif ($tab2[0] =~ /^ls/i) { $CNV_opt{"trueCNV"}{"level"}{"dup"} = $tab2[1]; }
		elsif ($tab2[0] =~ /^si/i) { $CNV_opt{"trueCNV"}{"spread"}{"del"} = $tab2[1]; }
		elsif ($tab2[0] =~ /^ss/i) { $CNV_opt{"trueCNV"}{"spread"}{"dup"} = $tab2[1]; }
		elsif ($tab2[0] =~ /^c/i) { $CNV_opt{"trueCNV"}{"conseC"} = $tab2[1]; }
		else  { die "opt --highQual not recognized (li/ls/si/ss/c)\n"; }
		}
	}
$CNV_opt{"seuil_region"} = 1;
if (exists $opt{ex_region}) { $CNV_opt{"seuil_region"} = $opt{ex_region}; }
$CNV_opt{"seuil_patient"} = 1;
if (exists $opt{ex_sample}) { $CNV_opt{"seuil_patient"} = $opt{ex_sample}; }
if (exists $opt{ex_cov}) { $CNV_opt{"seuil_cov"} = $opt{ex_cov}; }
$CNV_opt{"min_DP"} = 0;
if (exists $opt{ex_DP}) { $CNV_opt{"min_DP"} = $opt{ex_DP}; }
$CNV_opt{"min_following_CNV"} = "";
#if (exists $opt{min_CNV}) { $CNV_opt{"min_following_CNV"} = $opt{min_CNV}; }
$CNV_opt{"max_Non_CNV"} = "";
if (exists $opt{max_nonCNVcons}) { $CNV_opt{"max_Non_CNV"} = $opt{max_nonCNVcons}; }
$CNV_opt{"max_Non_CNV_rate"} = "";
if (exists $opt{max_nonCNVrate}) { $CNV_opt{"max_Non_CNV_rate"} = $opt{max_nonCNVrate}; }
$CNV_opt{"ratioByGender"} = "";
if (exists $opt{ratioByGender}) {
	if ($opt{ratioByGender}=~/^a/i) { $CNV_opt{"ratioByGender"} = "all"; }
	elsif ($opt{ratioByGender}=~/^g/i) { $CNV_opt{"ratioByGender"} = "gono"; }
	elsif ($opt{ratioByGender}=~/^n/i) { $CNV_opt{"ratioByGender"} = ""; }
	else { die "opt --ratioByGender not recognized (a/g/n)\n"; }
	}
$CNV_opt{"RefDepth"} = "mean";
if (exists $opt{normDepth}) {
	if ($opt{normDepth}=~/^m/i) { $CNV_opt{"RefDepth"} = "mean"; }
	elsif ($opt{normDepth}=~/^t/i) { $CNV_opt{"RefDepth"} = "tot"; }
	else { die "opt --normDepth not recognized (mean/tot)\n"; }
	}
$CNV_opt{"RefNoChrY"} = 1;
if (exists $opt{normAllChr}) { $CNV_opt{"RefNoChrY"} = ""; }
$CNV_opt{"geneGraph"} = "";
if (exists $opt{graph_byGene} && ($opt{graph_byGene} eq "" || $opt{graph_byGene}=~/^y|o/i)) { $CNV_opt{"geneGraph"} = 1; }
if ($bed_cov_file && !@raw_cov_file) { $CNV_opt{"geneGraph"} = ""; }
$CNV_opt{"chromGraph"} = "";
if (exists $opt{graph_byChr} && ($opt{graph_byChr} eq "" || $opt{graph_byChr}=~/^y|o/i)) { $CNV_opt{"chromGraph"} = 1; }
$CNV_opt{"CNVgraph"} = 1;
if (exists $opt{graph_byCNV}) {
	if ($opt{graph_byCNV} eq "" || $opt{graph_byCNV}=~/^y|o/i) { $CNV_opt{"CNVgraph"} = 1; }
	elsif ($opt{graph_byCNV}=~/^n/i) { $CNV_opt{"CNVgraph"} = ""; }
	}
@{ $CNV_opt{"fields"} } = ();
if (exists $opt{CNV_fields}) {
	@{ $CNV_opt{"fields"} } = split(/,/, join(',',@{$opt{CNV_fields}}));
	my%CNVfieldList = ("min"=>1,"max"=>1,"med"=>1,"avg"=>1,"std"=>1,"Q1"=>1,"Q3"=>1);
	foreach (@{ $CNV_opt{"fields"} }) {
		unless (exists $CNVfieldList{$_}) { die "$_ CNV field not recognized (min,max,norm)\n"; }
		}
	}
$CNV_opt{"switch2graphByCNV"} = 250;
$CNV_opt{"maxGeneLab"} = 200;
$CNV_opt{"maxGeneSep"} = 500;
$CNV_opt{"maxLabelLgth"} = 25;
$CNV_opt{"graphCNVpadding"} = 4;
$CNV_opt{"maxDepthGraph"} = 10;
$CNV_opt{"ploidy"} = 2;




##opt warnings according to actions 

#unless (exists $opt{file} || exists $opt{dir}) { die "requires a list of bam files to analysed (opt -f), or a directory where to find such files (opt -d)\n"; }
if ($jobs{"covMut"} && @raw_cov_file) { die "cannot compute depth on mutation file from cov files\n"; }
if ($bed_cov_file) {
	$jobs{"CNV"} = 1;
	if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"covMut"})
		{ die "actions other than CNV_detect not allowed if .cov.txt file provided\n"; }
	}
if ($jobs{"CNV"} && !$bed_cov_file) {
	$jobs{"covBed"} = 1;
	}

if ($jobs{"bedReport"} || $jobs{"2Reseq"}) {
	$jobs{"covBed"} = 1;
	}

if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"covMut"}) {
	if (!@Files && !@raw_cov_file) { die "no .bam files (or coverage file) provided\n"; }
	}

#unless ($mutFile || ($jobs{"CNV"} && $bed_cov_file)) {
if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"}) {
	unless ($bedFile || exists $opt{id} ) 
		{ die ".bed file (opt -b) or list of genes or transcripts id required (opt -i)\n"; }
	}

unless (@Thresholds) {
	if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || ($jobs{"CNV"} && $CNV_opt{"seuil_cov"}))
		 { die "at least 1 threshold value required (opt -t)\n"; }
	if ($jobs{"covBed"}) {
		foreach(@covFields) {
			if ($_ eq "cov") { die "at least 1 threshold value required (opt -t)\n"; }
			}
		if ($jobs{"bedReport"})  { die "at least 1 threshold value required (opt -t)\n"; }
		}
	}

if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"genePlot"} || ($jobs{"CNV"} && $CNV_opt{"geneGraph"}) || ($bedFile && $reAnnotBed) || @IDs) { 
	unless ($ref) { die "RefSeq file required (opt -r)\n"; } 
	}

unless ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"CNV"} || $jobs{"covMut"} || $jobs{"keepCov"} || $jobs{"keepBed"})
	{ die "no job selected!\n"; }


###################
#check progr installation and db existence
my(%pathCmd);

#check R
$pathCmd{"R"} = `which "R"`;
if ($? eq "0") { print "R tools OK\n"; }
else { die "R tools not installed or not found\n"; }

my(%sName,%sName2,%gatkIdx); 
my(@ChromOrder,%chromLength,%withChr);		#%faIdx
my$bedTversion = "";

#genome index
if ($genom) {
	if (-e $genom) { print "$genom OK\n"; }
	else { die "$genom not found\n"; }
	if (-e "$genom.fai") {
		#@chromLength = `cut -f1-2 $genom.fai`;
		#chomp @chromLength;
		open(my$fh, '<', "$genom.fai") or die "cannot open $genom.fai\n";
		while (my$line = <$fh>) {
			my@tab = split(/\t/,$line);
			push(@ChromOrder,$tab[0]);
			$chromLength{$tab[0]} = $tab[1];
			}
		close $fh;
		}
	} 

if ( $jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"covMut"} ) {

	if ($raw_cov_file[0]) {
		## get @ChromOrder
		open(COV, "$raw_cov_file[0]") or die "cannot read $raw_cov_file[0]\n";
		my$firstLine = <COV>;
		unless (@ChromOrder) {
			my%allChr = ();
			while (my$line = <COV>) {
				my@tab = split(/\t/,$line);
				my@tab2 = split(/:/,$tab[0]);
				unless (exists $allChr{$tab2[0]}) {
					push(@ChromOrder,$tab2[0]);
					$allChr{$tab2[0]} = 1;
					}
				}
			}
		close COV;
		## get sample names
		chomp $firstLine;
		my@tab = split(/\t/,$firstLine);
		for my$i (0..$#tab) {
			if ($tab[$i] =~ /^Depth_for_(.+)/) {
				push(@Files,$1);
				$fName{$1} = $1;
				$sName2{$1} = $1;
				$gatkIdx{$1} = $i;
				$gatk = 1;
				}
			}
		unless (@Files) { die "not able to find sample names in $raw_cov_file[0]\nmissing header line?\n"; }
		$jobs{"keepCov"} = "";
		}

	else {
		##check external softwares:
		##samtools
		if ($samT) {
			#system "$samT"; #write the name of calling script of picard #> /dev/null 2>&1
			$pathCmd{$samT} = `which "$samT"`;
			if ($? eq "0") { print "samtools OK\n"; }
			else {
				$samT =~ s/samtools$//;
				$samT =~ s/\/$//;
				if ($samT eq "") { $samT = "."; }
				$samT .= "/samtools";
				$pathCmd{$samT} = `which "$samT"`;
				if ($? eq "0") { print "samtools OK\n"; }
				else { $samT = ""; }
				}
			}
		else {
			$pathCmd{$samT} = `which "samtools"`;
			if ($? eq "0") { $samT = "samtools"; print "samtools OK\n"; }
			else { $samT = ""; }
			}	
		##picard tools
		if ($picard) {
			my$picardName = $picard;
			$picardName =~ s/\.jar$//;
			$picardName =~ s/picard$//;
			$picardName =~ s/\/$//;
			$picardName .= "/picard\.jar";
			if (-e $picardName) { 
				$picard = "java -jar $picardName";
				print "picard-tools OK\n"; 
				}
			else {
				print "$picardName .jar file not found; test for command\n";
				$pathCmd{$picard} = `which "$picard"`; 
				if ($? eq "0") { print "picard-tools OK\n"; }
				else { $picard = ""; }
				}
			}
		else {
			$pathCmd{"picard-tools"} = `which "picard-tools"`; 
			if ($? eq "0") { $picard = "picard-tools"; print "picard-tools OK\n"; }
			else { $picard = ""; }
			}
		##gatk
		## gatk == 1 if want to use gatk; so that it won't test for existing command if don't want to use it
		if ($mbq && !$gatk) { $gatk = 1; }
		if ($gatk) {
			if ($gatk ne "1") {
				my$gatkName = $gatk;
				$gatkName =~ s/\.jar$//;
				$gatkName =~ s/GenomeAnalysisTK$//;
				$gatkName =~ s/\/$//;
				$gatkName .= "/GenomeAnalysisTK\.jar";
				if (-e $gatkName) {
					if ($ram) { $gatk = "java -jar -Xmx$ram"."g $gatkName"; }
					else { $gatk = "java -jar $gatkName"; }
					print "GATK OK\n"; 
					}
				else {
					print "$gatkName .jar file not found; test for command\n";
					$pathCmd{$gatk} = `which "$gatk"`; 
					if ($? eq "0") {
						if ($ram) { $gatk .= " -Xmx$ram"."g"; }
						print "GATK OK\n"; 
						}
					else { die "GATK .jar file not found\n"; } #$gatk = ""; }
					}
				}
			else {
				$pathCmd{"GenomeAnalysisTK"} = `which "GenomeAnalysisTK"`; 
				if ($? eq "0") {
					if ($ram) { $gatk = "GenomeAnalysisTK -Xmx$ram"."g"; }
					else { $gatk = "GenomeAnalysisTK"; }
					print "GATK OK\n"; 
					}
				else { die "GATK cmd not found\n"; } #$gatk = ""; }
				}
			foreach (@Files) { $gatkIdx{$_} = ""; }	#to initialize
			}
		if ($mbq && !$gatk) { die "need GATK in order to filter for mbq\n"; }
		##bedtools
		if ($bedT) {
			#system "$bedT";
			$pathCmd{$bedT} = `which "$bedT"`; 
			if ($? eq "0") { print "bedtools OK\n"; }
			else {
				$bedT =~ s/bedtools$//;
				$bedT =~ s/\/$//;
				if ($bedT eq "") { $bedT = "."; }
				$bedT.="/bedtools";
				$pathCmd{$bedT} = `which "$bedT"`; 
				if ($? eq "0")  { print "bedtools OK\n"; }
				else { $bedT = ""; }
				}
			}
		else {
			$pathCmd{"bedtools"} = `which "bedtools"`; 
			if ($? eq "0") { $bedT="bedtools"; print "bedtools OK\n"; }
			else { $bedT = ""; }
			}
		if ($bedT) {
			my@bedTversion = split(/\./, `$bedT --version`);
			$bedTversion[0] =~ s/bedtools v//;
			if ( ($bedTversion[0]<2) || ($bedTversion[0]==2 && $bedTversion[1]<24) ) { $bedTversion = 1; }
			else	{ $bedTversion = 2; }
			}

		if ($mmq && !$gatk) {
			unless ($samT) { die "samtools not installed or not found\n"; }
			}
		#if ($jobs{"CNV"} && ($CNV_opt{"RefDepth"} eq "tot") && !$samT) { die "samtools not installed or not found\n"; }
		if ($dedup eq "do" && !$picard) { die "picard tools not installed or not found\n"; }
		if (!$bedT && !$gatk) { die "bedtools or GATK required\n"; }

		##find sample names in bam
		##sName: name of sample in bam file ; sName2: not redundant name of sample (cat with ID if several exists)
		if ($samT) {
			my%allID;
			foreach my$f (@Files) {
				#my$sample = `$samT view -H $path{$f}$fName{$f}$extenS | awk '(\$0 ~ /^\@RG/) {print \$0}'| awk 'BEGIN{FS=OFS=\"\t\"} { for(i=1;i<=NF;i++) {if(\$i ~ /^SM/) {print \$i} } }' | awk 'BEGIN{FS=OFS=\":\"} {print \$2}'`;
				my$sample = `$samT view -H $path{$f}$fName{$f}$extenS | awk '(\$0 ~ /^\@RG/) {print \$0}'`;
				chomp $sample;
				my@info = split(/\t/,$sample);
				my($ID,$SM);
				foreach my$i (@info) {
					if($i =~ /^ID/) {
						my@tab = split(/:/,$i);
						$ID = $tab[1]; 
						}
					elsif($i =~ /^SM/) {
						my@tab = split(/:/,$i);
						$SM = $tab[1]; 
						}
					}
				if (exists $allID{$SM}) {
					$sName{$f} = $SM;
					$sName2{$f} = $SM."_".$ID;
					foreach (@{ $allID{$SM} })
						{ $sName2{$_} = $SM."_".$ID; }
					}
				else {
					$sName{$f} = $SM;
					$sName2{$f} = $SM;
					}
				push(@{ $allID{$SM} },$f);
				}
			}
		else {
			foreach (@Files) {
				$sName{$_} = $fName{$_};
				$sName2{$_} = $fName{$_};
				}
			}
		#sort @Files according to %sName2 lexical order
		@Files = (sort {$sName2{$a} cmp $sName2{$b}} (keys %sName2));

		#bam index
		if (@Files) {
			if ($samT) {
				foreach my$file (@Files) {
					unless (-e "$path{$file}$fName{$file}$extenS.bai") {
						my$cmd = "$samT index $path{$file}$fName{$file}$extenS";
						print "$cmd\n";
						system "$cmd";
						}
#					my@tmp = `$samT idxstats $path{$file}$fName{$file}$extenS | cut -f1`;
#					chomp @tmp;
#					foreach (@tmp) {
#						if ($_ =~ /^\w/) { push(@{ $faIdx{$file} }, $_); }
#						}
#					}
#				}
#			else {
#				if (@ChromOrder) {
#					foreach my$file (@Files) {
#						foreach (@ChromOrder)
#							{ push(@{ $faIdx{$file} }, $_); }
#						}
#					}
#				else {
#					if ($jobs{"CNV"} && $CNV_opt{"RefDepth"} eq "tot")
#						{ die "cannot determine chr idx of bam files\n"; }
					}
				}
			unless (@ChromOrder) {
				if ($samT && -e "$path{$Files[0]}$fName{$Files[0]}$extenS.bai") {
					my@tmp = `$samT idxstats $path{$Files[0]}$fName{$Files[0]}$extenS`;
					foreach my$line (@tmp) {
						if ($line =~ /^\w/) {
							my@tab = split(/\t/,$line);
							push(@ChromOrder,$tab[0]);
							$chromLength{$tab[0]} = $tab[1];
							}
						}
					}
				}
			}
		## check requiring genome.fa and genome.fa.fai
		if ($gatk) {
			unless ($genom) { die "reference genome.fa required\n"; }
			unless (-e "$genom.fai") { die "index genome.fa.fai required (\"samtools faidx genome.fa\")\n"; }
			}
		else  {
			if ($bedTversion == 2) {
				unless (scalar(keys%chromLength)) { die "index of genome.fa.fai required\n"; }
				}
			}
		}
	## check for "chr" in chrom names
	if (@ChromOrder) {
		if ($ChromOrder[0] =~ /^chr/) {
			$withChr{"all"}="_wChr.bed";
			foreach (@Files) { $withChr{$_}="_wChr.bed"; } 
			}
		else {
			$withChr{"all"}="_0Chr.bed";
			foreach (@Files) { $withChr{$_}="_0Chr.bed"; } 
			}
		}
	#read gender file, just to check existing sample names
	if ($fichier_sexe) {
		open(PATIENTS, "$fichier_sexe") or die "cannot read $fichier_sexe\n";
		foreach my $ligne (<PATIENTS>) {
			$ligne =~ m/(\S+)\s+(\S+)/;
			my$ok="";
			foreach my$file (@Files) {
				if ($1 eq $sName2{$file}) {
					$ok=1; last;
					}
				}
			unless ($ok) { die "sample $1 not found in bam files\n"; }
			}
		close PATIENTS;
		}
	}


#create output dirs
use POSIX qw/strftime/;
my$outdir = "";
my$chromLength = "";
if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"CNV"} || $jobs{"covMut"}) {
	if (exists $opt{outdir}) { 
		$outdir = $opt{outdir}; 
		$outdir =~ s/\/$//;
		if (-d $outdir) {
			if ($jobs{"CNV"} && $bed_cov_file) { $outdir .= "/CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
			else { $outdir .= "/covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
			}
		}
	else {
		if ($jobs{"CNV"} && $bed_cov_file) { $outdir = "CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
		else { $outdir = "covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
		}
	mkdir($outdir);
	}
else {
	if (exists $opt{outdir}) { 
		$outdir = $opt{outdir}; 
		$outdir =~ s/\/$//;
		unless (-d $outdir) { mkdir($outdir); }
		}
	else { $outdir = "."; }
	}
if ($jobs{"graphBySample"} || $jobs{"geneReport"} || $jobs{"bedReport"}) { 
	foreach (@Files)
		{ mkdir("$outdir/cov\_$sName2{$_}"); }
	}
if ($jobs{"graphAllSampls"} || $jobs{"graphSum"})
	{ mkdir("$outdir/cov_All"); }
if ($raw_cov_file[0]) {
	my$cmd = "tail -n +2 $raw_cov_file[0] > $outdir/all.cov";
	print "$cmd\n";
	system "$cmd";
	}
else {
	if ( ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"covMut"}) && !$gatk && $bedTversion == 2) {
		if (scalar(keys%chromLength)) {
			$chromLength = "$outdir/chromLength.txt";		#used by bedtools
			open (my$fhOut, ">", "$chromLength");
			foreach(@ChromOrder) { print $fhOut "$_\t$chromLength{$_}\n"; }
			close $fhOut;
			}
		}
	}
if ($jobs{"keepBed"} && !$jobs{"graphSum"} && !$jobs{"graphAllSampls"} && !$jobs{"graphBySample"} && !$jobs{"geneSummary"} && !$jobs{"geneReport"} && !$jobs{"covPlot"} && !$jobs{"genePlot"} && !$jobs{"interSplot"} && !$jobs{"covBed"} && !$jobs{"CNV"} && !$jobs{"covMut"}) {
	unless (exists $opt{outdir}) { $outdir = $keepBedDir; }
	$bedName = $keepBedName;
	}


###################
##Job 1:find coordinates (genes, transcripts, bed, mut)

## if ID list provided : print in $idFile lines of RefSeq matching each $id of @ID
my$idFile = "";
if (@IDs) {
	$idFile = "$outdir/id_List.txt";
	gene2Ref2($idFile,$ref,\@IDs);
	}

##if bedFile provided:
my($Bed_r);	#$Bed{$chr}{$start} = $end , in 1-based
if ($bedFile) {
	print "processing $bedFile\n";
	if ($lenForBed) {
		print "adding $lenForBed bp to $bedFile intervals ends\n";
		my$expandedBed = "$outdir/$bedName";
		$expandedBed =~ s/.bed$//;
		$expandedBed .= "_w$lenForBed.bed";
		addLength2Bed($bedFile,$expandedBed,$lenForBed);
		$bedFile = $expandedBed;
		}
	if ($reAnnotBed) {
		print "re-annotating intervals of $bedFile with $ref\n";
		$reAnnotBed = "$outdir/$bedName";
		$reAnnotBed =~ s/.bed$//;
		$reAnnotBed .= "_ann.bed";
		if ($idFile) { reAnnotBed3($bedFile,$reAnnotBed,$idFile,\@ChromOrder,$nonCod); }
		else { reAnnotBed3($bedFile,$reAnnotBed,$ref,\@ChromOrder,$nonCod); }
		$bedFile = $reAnnotBed;
		}
	#transform in 1-based coord; keep longest intervals
	$Bed_r = readBed($bedFile);
	#merge overlapping intervals
	foreach my$chr (keys%{$Bed_r}) {
		%{ ${$Bed_r}{$chr} } = mergeIntervals(\%{ ${$Bed_r}{$chr} });
		}
	#print merged bed
	printBed("original",$Bed_r,\@ChromOrder);
	#eventually slice bed intervals
	$bedFile = sliceBedIntervals($bedFile,"$outdir/$bedName",$splitBed,$rmOverlapBed,$cutBed,\%cutB_opt,\@ChromOrder);
	}

my$keepTmp = "";
my%tmpFile;
foreach (@Files) { $tmpFile{$_} = ""; }

##if file of known mutations provided (in 1-based coordinates)
my(%Mut);
if ($mutFile) { 
	print "read $mutFile\n"; 
	%Mut = readMut($mutFile);		#$Mut{$chr}{$startMut} = $infoMut (1-based coord)
	if($jobs{"covMut"}) { 
		if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"} || $jobs{"CNV"}) 
			{ $keepTmp = 1; }
		%tmpFile = depthMut($mutFile,\%path,$extenS,\@Files,\%fName,\%sName,\%sName2,\%Mut,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$mbq,$dedup,$threads,$chromLength,$bedT,$bedTversion,$samT,$picard,$gatk,$genom);
		}
	}

##find and design transcripts:
my(@hashSub,$geneNM_r,$NMgene_r,$NMchr_r,$NMsens_r,%NMstartCod,%NMendCod,%Regions,$txtRegions_r,%NM_Ex,$txt_NM_Ex_r,$Genes_r,%RegBed,%NMlength,%intron,%UTR,%Cod,%RegMut,$coordBed_r,$id2Bed);	#	$NMstartCod{"raw"}->{} %{ ${$NMstartCod_r}{"raw"} } 

if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || (@IDs && !$bedFile) || $jobs{"genePlot"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || ($jobs{"CNV"} && $CNV_opt{"geneGraph"})) {

##if no list of genes/transcripts provided, finds transcripts overlapping at least partially with bed intervals
unless ($idFile) {
	$idFile = "$outdir/id_List.txt";
	@IDs = geneFromBed2($idFile,$ref,$Bed_r);
	}

##for list of genes/transcripts, extract foreach NM_id starts and ends of each coding exons
##and transform in 1-based coordinates
@hashSub = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$splitBedFromId,$mergeBedFromId,$nonCod,$wUTR,$id2Bed,\@ChromOrder);
#($geneNM_r, $NMgene_r, $NMchr_r, $NMsens_r, $NMstartCod{"raw"}, $NMendCod{"raw"}, $Regions{"raw"}, $NM_Ex{"raw"}, $Genes_r) = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$splitBedFromId,$mergeBedFromId,$nonCod,$wUTR,$id2Bed,\@ChromOrder);
#return (\%geneNM,\%NMgene,\%NMchr,\%NMsens,\%NMstartCod,\%NMendCod,\%Regions,\%NM_Ex,\%Genes,\%Bed);
$geneNM_r = $hashSub[0];		# @{ $geneNM{$gene} } = [$NM1,...]
$NMgene_r = $hashSub[1];		# $NMgene{$NM} = $gene;
$NMchr_r = $hashSub[2];		# %NMchr : key = NM, value = chr
$NMsens_r = $hashSub[3];		# %NMsens : key = NM, value = "+" or "-"
$NMstartCod{"raw"} = $hashSub[4];		#${$NMstartCod_r}{"raw"} = $hashSub[4];		# %NMstartCod : key = NM, value = start of coding sequence
$NMendCod{"raw"} = $hashSub[5];		#${$NMendCod_r}{"raw"} = %{$hashSub[5]};		# %NMendCod : key = NM, value = end of coding sequence
$Regions{"raw"} = $hashSub[6];		# $Regions{chr}{NM}{start of region} = end of region
$NM_Ex{"raw"} = $hashSub[7];		# %NM_Ex{NM}{start of region}{start of exon} = end of exon
$Genes_r = $hashSub[8]; 
unless ($bedFile) { 
	$Bed_r = $hashSub[9];		#$Bed{$chr}{$start} = $end; 
	foreach my$chr (keys%{$Bed_r}) {
		%{ ${$Bed_r}{$chr} } = mergeIntervals(\%{ ${$Bed_r}{$chr} });
		}
	}
#if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"graphSum"}) {
#	my$nG=scalar(keys%geneNM);
#	if ($nG>200) {
#		print "$nG genes to analyse ; continue?(Y/n)\n";
#		my$doIt = <STDIN>; chomp $doIt;
#		if ($doIt =~ /^n$/i)
#			{ die "stop analysis\n"; }
#		}
#	}

##for summary txt file:
if (($jobs{"keepBed"} || $jobs{"covBed"} || $jobs{"CNV"}) && (!$bedFile)) {
	$bedName = $keepBedName;
	$id2Bed = "$outdir/$bedName.bed";
	}
@hashSub = Id2Coord($idFile,$lenTxt5,$lenTxt3,$UpInTxt,$DownInTxt,$splitBedFromId,$mergeBedFromId,$nonCod,$UTRinTxt,$id2Bed,\@ChromOrder);
$txtRegions_r = $hashSub[6];		# as %Regions, but for summary txt file
$txt_NM_Ex_r = $hashSub[7];		# as %NM_Ex, but for summary txt file
$coordBed_r = $hashSub[9];		# as %Bed, but for coordPlot and cov_Bed if no bedfile
foreach my$chr (keys%{$coordBed_r}) {
	%{ ${$coordBed_r}{$chr} } = mergeIntervals(\%{ ${$coordBed_r}{$chr} });
	}
if ($id2Bed) {
	$id2Bed = sliceBedIntervals($id2Bed,"$outdir/$bedName",$splitBed,$rmOverlapBed,$cutBed,\%cutB_opt,\@ChromOrder);
	}
unlink "$idFile" or warn "Could not unlink: $!";

#changes Regions{gene} according to each NM (without -A N)
if ($AllTranscripts) {

	NM2GeneRegion($Genes_r,$geneNM_r,$NMchr_r,$Regions{"raw"},$NM_Ex{"raw"});

	NM2GeneRegion($Genes_r,$geneNM_r,$NMchr_r,$txtRegions_r,$txt_NM_Ex_r);

	}

#links bed intervals to Regions, eventually changes Regions according to bed (with -L Y)
if ($Expand) {
	print "change regions intervals according to bed\n";
	if($AllTranscripts) {
		foreach my$gene(keys%{$Genes_r})
			{
			my@NMs =  @{ ${$geneNM_r}{$gene} };
			my$chr = ${$NMchr_r}{$NMs[0]};
			$RegBed{"raw"}->{$gene} = changeRegion2G(\@NMs,\%{ $Regions{"raw"}->{$chr}{$gene} },$NM_Ex{"raw"},\%{ ${$Bed_r}{$chr} });
			#$RegBed{$gene}{$startReg}{$startBed} = $endBed;
			}
		}
	else {
		foreach my$NM (keys%NM_Ex) {
			$RegBed{"raw"}->{$NM} = changeRegion2N(\%{ $Regions{"raw"}->{${$NMchr_r}{$NM}}{$NM} },\%{ $NM_Ex{"raw"}->{$NM} },\%{ ${$Bed_r}{${$NMchr_r}{$NM}} });
			#$RegBed{$NM}{$startReg}{$startBed} = $endBed;
			}
		}
	}
else {
	print "change bed intervals according to genes\n";
	$RegBed{"raw"} = linkBed($Regions{"raw"},$Bed_r);
	}

#eliminates $NM with no corresponding cov bed
print "eliminates transcripts with no corresponding bed intervals\n";
if ($AllTranscripts) { notAnalysedG($geneNM_r,$Genes_r,$Regions{"raw"},$NM_Ex{"raw"},$RegBed{"raw"}); }
else  { notAnalysedN($Genes_r,$NMgene_r,$Regions{"raw"},$NM_Ex{"raw"},$RegBed{"raw"}); }


#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#for end of exon = x, start of next exon = x
@hashSub = transposeReg($spacer,$Regions{"raw"});
$spacer = $hashSub[0];
%NMlength = %{$hashSub[1]};			#$NMlength{$NM} = $end of region (for start of region = 0)
$Regions{"coord0"} = $hashSub[2];	#$Regions{"coord0"}{$NM}{start of region} = $end of region (for start of region = 0)
	
#$NM_Ex{"coord0"}{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
#$NMstartCod{"coord0"}{$NM} = $start of coding sequence (for start of region = 0)
#$NMendCod{"coord0"}{$NM} = $end of coding sequence (for start of region = 0)
if ($AllTranscripts) {
	foreach my$gene(keys%{ $Regions{"coord0"} }) {
		foreach my$NM (@{ ${$geneNM_r}{$gene} }) {
			@hashSub = transposeNM($wUTR,$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $Regions{"raw"}->{${$NMchr_r}{$NM}}{$gene} },\%{ $Regions{"coord0"}->{$gene} },\%{ $NM_Ex{"raw"}->{$NM} }); 
			$NMstartCod{"coord0"}->{$NM} = $hashSub[0];		#${$NMstartCod_r}{"coord0"}{$NM} = $hashSub[0];
			$NMendCod{"coord0"}->{$NM} = $hashSub[1];			#${$NMendCod_r}{"coord0"}->{$NM} = $hashSub[1];
			$NM_Ex{"coord0"}->{$NM} = $hashSub[2];
			}
		}
	}
else {
	foreach my$NM (keys%{ $Regions{"coord0"} }) { 
		@hashSub = transposeNM($wUTR,$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $Regions{"raw"}->{${$NMchr_r}{$NM}}{$NM} },\%{ $Regions{"coord0"}->{$NM} },\%{ $NM_Ex{"raw"}{$NM} });
		$NMstartCod{"coord0"}->{$NM} = $hashSub[0];
		$NMendCod{"coord0"}->{$NM} = $hashSub[1]; 
		$NM_Ex{"coord0"}->{$NM} = $hashSub[2];
		}
	}

#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons
if ($AllTranscripts) {
	@hashSub = designExons1($wUTR,$Genes_r,$geneNM_r,$Regions{"coord0"},$NM_Ex{"coord0"},$NMstartCod{"coord0"},$NMendCod{"coord0"});
	}
else {
	@hashSub = designExons2($wUTR,$Regions{"coord0"},$NM_Ex{"coord0"},$NMstartCod{"coord0"},$NMendCod{"coord0"});
	}
#return(\%introns,\%UTR,\%Cod);
$intron{"coord0"} = $hashSub[0];	# $intron{"coord0"}{$NM}{$startIntron} = $endIntron (for start of region = 0)
$UTR{"coord0"} = $hashSub[1];		# $UTR{"coord0"}{$NM}{$startUTR} = $endUTR (for start of region = 0)
$Cod{"coord0"} = $hashSub[2];		# $Cod{"coord0"}{$NM}{$startCod} = $endCod (for start of region = 0)

if ($mutFile)
	{ $RegMut{"raw"} = linkMut($Regions{"raw"},\%Mut); }	#$RegMut{$NM}{$startReg}{$startMut} = $infoMut

#$RegBed{"coord0"}{$NM}{$startBed00} = $endBed00 (start of Region=0 )
#$RegMut{"coord0"}{$NM}{$mut00} = $infoMut (start of Region=0 )
@hashSub = transposeBed($Regions{"raw"},$Regions{"coord0"},$RegBed{"raw"},$RegMut{"raw"});
$RegBed{"coord0"} = $hashSub[0];
$RegMut{"coord0"} = $hashSub[1];

foreach my$gene (keys%{$Genes_r}) {
	my@NMs =  @{ ${$geneNM_r}{$gene} };
	my$chr = ${$NMchr_r}{$NMs[0]};
	my$sens = ${$NMsens_r}{$NMs[0]};
	if ($Rev && $sens eq "-") {
		if ($AllTranscripts) {
			@hashSub = ReverseGene1($gene,$NMlength{$gene},\%{ $Regions{"coord0"}->{$gene} },\%{ $RegBed{"coord0"}->{$gene} },\%{ $RegMut{"coord0"}->{$gene} });
			$Regions{"rev"}->{$gene} = $hashSub[0];
			$RegBed{"rev"}->{$gene} = $hashSub[1];
			$RegMut{"rev"}->{$gene} = $hashSub[2];
			foreach my$NM (@NMs) {
				@hashSub = ReverseGene2($NM,$NMlength{$gene},\%{ $Regions{"coord0"}->{$gene} },\%{ $NM_Ex{"coord0"}->{$NM} },\%{ $intron{"coord0"}->{$NM} },\%{ $UTR{"coord0"}->{$NM} },\%{ $Cod{"coord0"}->{$NM} });
				$NM_Ex{"rev"}->{$NM} = $hashSub[0];
				$intron{"rev"}->{$NM} = $hashSub[1];
				$UTR{"rev"}->{$NM} = $hashSub[2];
				$Cod{"rev"}->{$NM} = $hashSub[3];
				}
			}
		else {
			foreach my$NM (@NMs) {
				@hashSub = ReverseNMs($NM,$NMlength{$NM},\%{ $Regions{"coord0"}->{$NM} },\%{ $NM_Ex{"coord0"}->{$NM} },\%{ $intron{"coord0"}->{$NM} },\%{ $UTR{"coord0"}->{$NM} },\%{ $Cod{"coord0"}->{$NM} },\%{ $RegBed{"coord0"}->{$NM} },\%{ $RegMut{"coord0"}{$NM} });
				$Regions{"rev"}->{$NM} = $hashSub[0];
				$NM_Ex{"rev"}->{$NM} = $hashSub[1];
				$intron{"rev"}->{$NM} = $hashSub[2];
				$UTR{"rev"}->{$NM} = $hashSub[3];
				$Cod{"rev"}->{$NM} = $hashSub[4];
				$RegBed{"rev"}->{$NM} = $hashSub[5];
				$RegMut{"rev"}->{$NM} = $hashSub[6];
				}
			}
		}
	else {
		if ($AllTranscripts) {
			$Regions{"rev"}->{$gene} = $Regions{"coord0"}->{$gene};
			if (exists $RegBed{"coord0"}->{$gene}) { $RegBed{"rev"}->{$gene} = $RegBed{"coord0"}->{$gene}; }
			if (exists $RegMut{"coord0"}->{$gene}) { $RegMut{"rev"}->{$gene} = $RegMut{"coord0"}->{$gene}; }
			}
		else {
			foreach my$NM (@NMs) {
				$Regions{"rev"}->{$NM} = $Regions{"coord0"}->{$NM};
				if (exists $RegBed{"coord0"}->{$NM}) { $RegBed{"rev"}->{$NM} = $RegBed{"coord0"}->{$NM}; }
				if (exists $RegMut{"coord0"}->{$NM}) { $RegMut{"rev"}->{$NM} = $RegMut{"coord0"}->{$NM}; }
				}
			}
		foreach my$NM (@NMs) {
			if (exists $NM_Ex{"coord0"}->{$NM}) { $NM_Ex{"rev"}->{$NM} = $NM_Ex{"coord0"}->{$NM}; }
			if (exists $intron{"coord0"}->{$NM}) { $intron{"rev"}->{$NM} = $intron{"coord0"}->{$NM}; }
			if (exists $UTR{"coord0"}->{$NM}) { $UTR{"rev"}->{$NM} = $UTR{"coord0"}->{$NM}; }
			if (exists $Cod{"coord0"}->{$NM}) { $Cod{"rev"}->{$NM} = $Cod{"coord0"}->{$NM}; }
			}
		}
	}

}


###################
#Job 2: bams analysis:
my(%headers);

if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || $jobs{"covPlot"} || $jobs{"genePlot"} || $jobs{"interSplot"} || $jobs{"covBed"}) {

	my$intervalName;

	if (scalar(keys%{ $Regions{"raw"} }) > 0) {
		#merge intervals from %Regions (for example, if several transcripts for the same gene)
		#% $Regions{"raw"}{chr}{NM}{exonstart} = exonend
		#% $allInterval{chr}{start of region} = end of region
		#print bed corresponding to regions
		my$allIntervals_r = mergeRegions($Regions{"raw"});
		$intervalName = "regions";
		printBed($intervalName,$allIntervals_r,\@ChromOrder);
		if ($bedFile || ($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
			$intervalName = "merge";
			open (MERGE, ">$outdir/$intervalName.bed") || die "can't create file $outdir/$intervalName.bed\n";
			open (BED, "$outdir/regions_0Chr.bed") || die "can't open file $outdir/regions_0Chr.bed\n";
			while (my$line=<BED>) { print MERGE $line; }
			close BED;
			if ($bedFile) {
				open (BED, "$outdir/original_0Chr.bed") || die "can't open file $outdir/original_0Chr.bed\n";
				while (my$line=<BED>) { print MERGE $line; }
				close BED;
				}
			if (($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
				printBed("txtRegions",$coordBed_r,\@ChromOrder);
				open (BED, "$outdir/txtRegions_0Chr.bed") || die "can't open file $outdir/txtRegions_0Chr.bed\n";
				while (my$line=<BED>) { print MERGE $line; }
				close BED;
				}
			close MERGE; 
			my$merge_r = readBed("$outdir/$intervalName.bed");
			foreach my$chr (keys%{$merge_r})
				{ %{ ${$merge_r}{$chr} } = mergeIntervals(\%{ ${$merge_r}{$chr} }); }
			printBed($intervalName,$merge_r,\@ChromOrder);
			unlink "$outdir/$intervalName.bed";
			}
		}
	else {
		$intervalName = "original";
		}

	if ($raw_cov_file[0]) {	
		print "check that all intervals to be analysed are present in cov.file\n";
		my$intervals_r = readBed("$outdir/$intervalName\_0Chr.bed");	#$covbed{$chr}{$start} = $end;	transform in 1-based coord
		foreach my$chr (keys%{$intervals_r}) {
			print "\t$chr\n";
			my$withinChr = 0;
			my@Starts = sort{$a<=>$b}(keys%{ ${$intervals_r}{$chr} });
			my$s = 0;					#idx of @Starts
			my$pos = $Starts[$s];			#current position
			open(COV, "$raw_cov_file[0]") || die "can't open file $raw_cov_file[0]\n";
			while (my$line=<COV>) {
				chomp $line;
				my@tab = split(/\t/,$line);
				$tab[0] =~ s/chr//;
				my@tab2 = split(/:/,$tab[0]);
				if ($tab2[0] eq $chr) {
					$withinChr = 1;
					my$ok=1;
					while ($ok) {
						if ( $tab2[1] < $Starts[$s] ) { $ok=0; }
						else {
							if ( $tab2[1] <= ${$intervals_r}{$chr}{$Starts[$s]} ) {
								if ($tab2[1] == $pos) { $pos++; $ok=0; }
								else { die "some intervals to be analysed not found in cov file ( $chr:$pos )\n"; }
								}
							else {
								if ($s<$#Starts) {
									$s++;
									$pos = $Starts[$s];
									}
								else { $ok=0; }
								}
							}
						}
					}
				else {
					if ($withinChr) { last; }
					}
				}
			unless ($withinChr) { die "some intervals to be analysed not found in cov file ( $chr )\n"; }
			}
		}

	 else {
		##perform depth analysis
		if ($gatk) {
			my($r1,$r2) = gatkCov($intervalName,\%path,$extenS,\@Files,\%fName,\%sName,$outdir,"all.cov",$withChr{"all"},$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom);
			%gatkIdx = %$r1;
			#@{ $headers{"$outdir/all.cov"} } = @$r2;
			}
		else {
			$keepTmp = 0;
			bedToolsCov($intervalName,\%path,$extenS,\@Files,\%fName,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
			}
		}
	}


###################
#Job 3: Graphs:

if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"graphSum"} || ( ($jobs{"geneReport"} || $jobs{"geneSummary"}) && (($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream)) ) ) {

	my%NMnotCov;	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my%NM_UC;	##NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	if($jobs{"geneReport"}) {
		foreach (@Files) {
			open(OUT, ">", "$outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt\n";
			print OUT "## SAMPLE : $sName2{$_}\n\n";
			if ($pThreshold) {
				print OUT "## depth threshold : $pThreshold x\n\n";
				}
			close OUT;
			}
		}


	##foreach gene:
	foreach my$gene (sort(keys%{$Genes_r})) {

		print "analysing cov in $gene\n";
		my@NMs =  @{ ${$geneNM_r}{$gene} };
		my$chr = ${$NMchr_r}{$NMs[0]};
		my$sens = ${$NMsens_r}{$NMs[0]};

		unless ($AllTranscripts) {
			my%NMinterval;
			foreach my$NM (@NMs) {
				%{ $NMinterval{$chr}{$NM} } = %{ $Regions{"raw"}->{$chr}{$NM} };
				}
			my$tmpRef = mergeRegions(\%NMinterval);
			%{ $Regions{"raw"}->{$chr}{$gene} } = %{ ${$tmpRef}{$chr} };
			}

		##initialyzes %NMCov: @{ $NMCov{$threshold}{$NM}{$nReg} } = [0 foreach pos of Regions{$NM}{$startReg}]
		my%NMCov;
		if ($jobs{"graphSum"}) {
			foreach my$threshold (@Thresholds) {
				if ($AllTranscripts) {
					my$r=0; ##idx of reg of $NM
					foreach my$startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}->{$chr}{$gene} }) {
						my$pos=$startReg;
						while ($pos <= $Regions{"raw"}->{$chr}{$gene}{$startReg} ) { 
							push (@{ $NMCov{$gene}{$threshold}{$r} }, 0);
							$pos++;
							}
						$r++;
						}
					}
				else {
					foreach my$NM (@NMs) {
						my$r=0; ##idx of reg of $NM
						foreach my$startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}->{$chr}{$NM} }) {
							my$pos=$startReg;
							while ($pos <= $Regions{"raw"}->{$chr}{$NM}{$startReg} ) { 
								push (@{ $NMCov{$NM}{$threshold}{$r} }, 0);
								$pos++;
								}
							$r++;
							}
						}
					}
				}
			}
		##foreach depth files from bedtools coveragedepth -d:
		##intersection hash-intervals and gene-coordinates
		##scan bedtools files : create a hash : cov foreach position in intervals from %allInterval: #$allCov{$chr}{$loc} = $cov
		##create a hash : foreach NM, foreach file, foreach exon, array of values for ordered positions
		my%NMdepth;
		my%covStart01;
		my%covEnd01;
		foreach my$file (@Files) {
			print "\tfor bam $fName{$file}\n";
			##scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
			##create 2 hash : 
			## %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = depth
			## %notCov: start and end of each not covered domain within %allInterval : $notCov{$start} = $end
			if ($gatk)
				{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },$gatk,1); }
			else 
				{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },$gatk,1); }
			my$allDepth_r = $hashSub[0];
			my$notCov_r = $hashSub[1];
			my$notCovStarts_r = $hashSub[2];

			if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"}) {
				##for depth-line :
				##create a hash : foreach file, foreach NM, foreach exon, return an array of values for ordered positions
				## @{ $NMdepth{$NM}{$file}{$startReg} } = [ depth foreach ordered bp of exon ]
				if ($AllTranscripts)
					{ $NMdepth{$gene}->{$file} = depthLine(\%{ $Regions{"raw"}->{$chr}{$gene} },$allDepth_r); }
				else {
					foreach my$NM (@NMs)
						{ $NMdepth{$NM}->{$file} = depthLine(\%{ $Regions{"raw"}->{$chr}{$NM} },$allDepth_r); }
					}

				##for cov-domains:
				##intersections not covered regions and exons
				## printReports  , if $wUTR = $UTRinTxt and if $lenForTxt = $len
				##starts and ends of not covered regions within exons
				## $NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
				## @{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]
				my(%NMcovStart,%NMcovEnd);
				my$printR = "";
				if ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) ) { $printR = $jobs{"geneReport"}; }
				if ($AllTranscripts) {
					@hashSub = notCovDomains2(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },$notCov_r,$notCovStarts_r);
					$NMcovStart{$gene} = $hashSub[0];
					$NMcovEnd{$gene} = $hashSub[1];
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $NM_Ex{"raw"}->{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},$notCov_r,$notCovStarts_r,\%NMnotCov,$printR);
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				else {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}->{$chr}{$NM} },\%{ $NM_Ex{"raw"}->{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},$notCov_r,$notCovStarts_r,\%NMnotCov,$printR);
						$NMcovStart{$NM} = $hashSub[0];
						$NMcovEnd{$NM} = $hashSub[1];
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}

				##transposition and splicing: 1st position of 1st exon = 1, 
				##and	if end of exon = x, start of next exon = x+1
				## $covEnd01{$NM}{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
				## @{ $covStart01{$NM}{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
				if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"}) {
					if ($AllTranscripts) {
						@hashSub = transposeCov(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $Regions{"coord0"}->{$gene} },$NMcovStart{$gene},$NMcovEnd{$gene});
						$covStart01{$gene}->{$file} = $hashSub[0];
						$covEnd01{$gene}->{$file} = $hashSub[1];
						}
					else {
						foreach my$NM (@NMs) {
							@hashSub = transposeCov(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$NM} },\%{ $Regions{"coord0"}->{$NM} },$NMcovStart{$NM},$NMcovEnd{$NM});
							$covStart01{$NM}->{$file} = $hashSub[0];
							$covEnd01{$NM}->{$file} = $hashSub[1];
							}
						}
					}
				}

			## @{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
			if ($jobs{"graphSum"}) {
				if ($AllTranscripts) {
					foreach my$threshold (@Thresholds)
						{ covByThreshold($threshold,\%{ $Regions{"raw"}->{$chr}{$gene} },$allDepth_r,\%{ $NMCov{$gene}{$threshold} }); }
					}
				else {
					foreach my$NM (@NMs) {
						foreach my$threshold (@Thresholds)
							{ covByThreshold($threshold,\%{ $Regions{"raw"}->{$chr}{$NM} },$allDepth_r,\%{ $NMCov{$NM}{$threshold} }); }
						}
					}
				}
			}

		##foreach NM, find max cov, among all samples (A) or foreach sample (S)
		my(%maxCovA,%maxCovS);	##$maxCov{$NM} = $maxDepth;
		if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"}) {
			if ($maxGr) {
				if ($AllTranscripts) {
					$maxCovA{$gene} = $maxGr;
					foreach (@Files) { $maxCovS{$gene}{$_} = $maxGr; }
					}
				else {
					foreach my$NM (@NMs) {
						$maxCovA{$NM} = $maxGr;
						foreach (@Files) { $maxCovS{$NM}->{$_} = $maxGr; }
						}
					}
				}
			else {
				if ($AllTranscripts) { 
					@hashSub = maxCov(\@Files,$NMdepth{$gene},\%{ $Regions{"coord0"}->{$gene} }); 
					$maxCovA{$gene} = $hashSub[0];
					$maxCovS{$gene} = $hashSub[1];
					}
				else {
					foreach my$NM (@NMs) { 
						@hashSub = maxCov(\@Files,$NMdepth{$NM},\%{ $Regions{"coord0"}->{$NM} });
						$maxCovA{$NM} = $hashSub[0];
						$maxCovS{$NM} = $hashSub[1];
						}
					}
				}
			}

		##reverse if sens "-"
		if ($Rev) {
			if ($sens eq "-") {
				if ($AllTranscripts) {
					ReverseCov_Gene($jobs{"graphSum"},$jobs{"graphAllSampls"},$jobs{"graphBySample"},$gene,$NMlength{$gene},\@Thresholds,$NMdepth{$gene},\%{ $covEnd01{$gene} },$covStart01{$gene},$NMCov{$gene});
					}
				else {
					foreach my$NM (@NMs) {
						ReverseCov_NMs($jobs{"graphSum"},$jobs{"graphAllSampls"},$jobs{"graphBySample"},$NM,$NMlength{$NM},\@Thresholds,$NMdepth{$NM},\%{ $covEnd01{$NM} },$covStart01{$NM},$NMCov{$NM});
						}
					}
				}
			}

		##@{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
		##$NMCovEnd{$NM}{$threshold}{$ex}{$start}=$end
		##$NMCovVal{$NM}{$threshold}{$ex}{$start}=$value
		my(%NMCovEnd,%NMCovVal);
		if ($jobs{"graphSum"}) {
			if ($AllTranscripts) {
				@hashSub= covDomains(\@Thresholds,\%{ $Regions{"rev"}->{$gene} },\%{ $NMCov{$gene} });
				$NMCovEnd{$gene} = $hashSub[0];		
				$NMCovVal{$gene} = $hashSub[1];
				}
			else {
				foreach my$NM (@NMs) {
					@hashSub= covDomains(\@Thresholds,\%{ $Regions{"rev"}->{$NM} },\%{ $NMCov{$NM} });
					$NMCovEnd{$NM} = $hashSub[0];		
					$NMCovVal{$NM} = $hashSub[1];
					}
				}
			}

		##graphiques R
		my@colors=("gold","orange","orangered","red1","magenta4");

		##graph covByGene
		if ($jobs{"graphSum"}) { 
			if ($AllTranscripts)
				{ graphSumG($nGraf,$gene,$suff,$outdir,$sens,$chr,$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},$NMCovEnd{$gene},$NMCovVal{$gene}); }
			else
				{ graphSumN($nGraf,$gene,$suff,$outdir,$sens,$chr,\%NMlength,\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},\%NMCovEnd,\%NMCovVal); }
			}

		##graph covBySample
		if ($jobs{"graphAllSampls"}) {
			if ($AllTranscripts) {
				my$ok=0;
				if ($gThreshold) {
					foreach my$NM (@NMs) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok)
					{ graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2); }
				}
			else {
				foreach my$NM (@NMs) {
					my$ok=0;
					if ($gThreshold) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok)
						{ graphAllSampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$NM},$NMlength{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2); }
					}
				}
			}

		if ($jobs{"graphBySample"}) {
			if ($AllTranscripts) { 
				my$ok=0;
				if ($gThreshold) {
					foreach my$NM (@NMs) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok)
					{ graphBySampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$gene},$maxCovS{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2); }
				}
			else {
				foreach my$NM (@NMs) {
					my$ok=0;
					if ($gThreshold) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok)
						{ graphBySampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$NM},$maxCovS{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2); }
					}
				}
			}
		}
	##summary , if $wUTR = $UTRinTxt and if $lenForTxt = $len
	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($jobs{"geneSummary"} && ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) )) {
		open (OUT, ">$outdir/notCovSummary.txt"); 
		print OUT "depth threshold: $pThreshold\n";
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my$gene (sort(keys%{$Genes_r})) {
			print OUT "\n$gene\n"; 
			foreach my$NM (@{ ${$geneNM_r}{$gene} }) {
				my$txt="";
				foreach my$file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}->{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}
	}

##re-analyse for $printReports || $printSummary, if $wUTR != $UTRinTxt, or if $lenForTxt != $len
if ( ($jobs{"geneReport"} || $jobs{"geneSummary"}) && (($UTRinTxt != $wUTR) || ($lenTxt5 != $len5) || ($lenTxt3 != $len3) || ($UpInTxt != $upstream) || ($DownInTxt != $downstream)) ) {

	my%NMnotCov;	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my%NM_UC;	## NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	foreach my$gene (sort(keys%{$Genes_r})) {
		print "analysing cov in $gene\n";
		my@NMs =  @{ ${$geneNM_r}{$gene} };
		my$chr = ${$NMchr_r}{$NMs[0]};
		my$sens = ${$NMsens_r}{$NMs[0]};
		unless ($AllTranscripts) {
			my%NMinterval;
			foreach my$NM (@NMs)
				{ %{ $NMinterval{$chr}{$NM} } = %{ ${$txtRegions_r}{$chr}{$NM} }; }
			my$tmpRef = mergeRegions(\%NMinterval);
			%{ ${$txtRegions_r}{$chr}{$gene} } = %{ ${$tmpRef}{$chr} };
			}

		foreach my$file (@Files) {
			print "\tfor bam $fName{$file}\n";
			## %notCov: start and end of each not covered domain within %allInterval : $notCov{$start} = $end
			if ($gatk)
				{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxGr,$chr,\@Thresholds,\%{ ${$txtRegions_r}{$chr}{$gene} },$gatk,1); }
			else 
				{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.cov",$maxGr,$chr,\@Thresholds,\%{ ${$txtRegions_r}{$chr}{$gene} },$gatk,1); }
			my$notCov_r = $hashSub[1];
			my$notCovStarts_r = $hashSub[2];

			if ($jobs{"geneSummary"} || $jobs{"geneReport"}) {
				if ($AllTranscripts) {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ ${$txtRegions_r}{$chr}{$gene} },\%{ ${$txt_NM_Ex_r}{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},$notCov_r,$notCovStarts_r,\%NMnotCov,$jobs{"geneReport"});
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				else {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ ${$txtRegions_r}{$chr}{$NM} },\%{ ${$txt_NM_Ex_r}{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},$notCov_r,$notCovStarts_r,\%NMnotCov,$jobs{"geneReport"});
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				}
			}
		}
	##summary
	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($jobs{"geneSummary"}) {
		open (OUT, ">$outdir/notCovSummary.txt");
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my$gene (sort(keys%{$Genes_r})) {
			print OUT "\n$gene\n"; 
			foreach my$NM (@{ ${$geneNM_r}{$gene} }) {
				my$txt="";
				foreach my$file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}->{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}							
	}


###################
#Job 4: Plots:

#classiq
if ($jobs{"covPlot"}) { 
	mkdir ("$outdir/covPlot");
	if (!$bedFile || $jobs{"genePlot"}) 
		{ %withChr = covPlot($bin,$maxPl,"all_Genes_Regions",\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,$coordBed_r); }
	if ($bedFile) 
		{ %withChr = covPlot($bin,$maxPl,$bedName,\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,$Bed_r); }
	}

#plots for samples intersection
if ($jobs{"interSplot"}) {
	unless (-e "$outdir/covPlot")
		{ mkdir ("$outdir/covPlot"); }
	if (!$bedFile || $jobs{"genePlot"}) { 
		InterS($bin,$maxPl,$maxGr,$coordBed_r,"all_Genes_Regions",\@Files,\%fName,$outdir,$gatk,\%gatkIdx); 
		}
	if ($bedFile) {		
		InterS($bin,$maxPl,$maxGr,$Bed_r,$bedName,\@Files,\%fName,$outdir,$gatk,\%gatkIdx);
		}
	}

###################
#Job 5: cov of each bed interval

my($bedLines_r);
if ($jobs{"covBed"}) {
	if ($bedFile) {
		$bedLines_r = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$bedFile,$bedName,$Bed_r,$pThreshold,$jobs{"2Reseq"},$jobs{"bedReport"},\@covFields,$gatk,\%gatkIdx,\%CNV_opt);		
		}
	else {
		$bedLines_r = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$id2Bed,$bedName,$coordBed_r,$pThreshold,$jobs{"2Reseq"},$jobs{"bedReport"},\@covFields,$gatk,\%gatkIdx,\%CNV_opt);
		}
	}

my($cnv_Patients_r,$cnv_Results_r);
if ($jobs{"CNV"}) {


	if ($bed_cov_file) {
		Bio::NGS::HCL::DeCovA::CNV_tool::CNV_reAnalyse($bed_cov_file,$outdir,$fichier_sexe,\%CNV_opt);
		}
	
	else {
	
		mkdir "$outdir/CNV_analysis";

		($cnv_Patients_r,$cnv_Results_r) = Bio::NGS::HCL::DeCovA::CNV_tool::CNV_detect(\@Files,\%sName2,"$outdir/CNV_analysis",$fichier_sexe,\%CNV_opt,$bedLines_r,\@ChromOrder);

		if ($CNV_opt{"geneGraph"} && keys%{$cnv_Results_r}) {
			print "cnv geneGraph \n";
			#get transcripts and genes overlapping bed CNV results
			my(%IDs,%CNVbed,%CNV_Genes);
			open (MERGE, ">$outdir/allCNVs.bed") || die "can't create file $outdir/allCNVs.bed\n";
			##cnv_Results{$Chrom}{Start}{End} = "DEL/DUP	foldRatio"
			foreach my$file (keys%{$cnv_Results_r}) {
				print "\tfor $file\t";
				#open (BED, "$outdir/CNV_analysis/$sName2{$file}/CNV_$sName2{$file}.txt") || die "can't open $outdir/CNV_analysis/CNV_$sName2{$file}.txt\n";
				#while (my$line=<BED>) { print MERGE $line; }
				#close BED;
				#%{ $CNVbed{$file} } = readBed("$outdir/CNV_analysis/$sName2{$file}/CNV_$sName2{$file}.txt");
				foreach my$chrom (keys%{ ${$cnv_Results_r}{$file} }) {
					foreach my$start (keys%{ ${$cnv_Results_r}{$file}{$chrom} }) {
						foreach my$end (keys%{ ${$cnv_Results_r}{$file}{$chrom}{$start} }) {
							my$chr = $chrom; $chr =~ s/^chr//i;
							print MERGE "$chr\t$start\t$end\n";
							if (exists $CNVbed{$file}{$chr}{($start+1)}) {
								if ($end > $CNVbed{$file}{$chr}{($start+1)}) 
									{ $CNVbed{$file}{$chr}{($start+1)} = $end; }	
								}
							else
								{ $CNVbed{$file}{$chr}{($start+1)} = $end; }
							}
						}
					}
				foreach my$chr (keys%{ $CNVbed{$file} }) {
					%{ $CNVbed{$file}{$chr} } = mergeIntervals(\%{ $CNVbed{$file}{$chr} });	
					}
				@{ $IDs{$file} } = geneFromBed2("$outdir/id.tmp",$ref,\%{ $CNVbed{$file} });
				unlink "$outdir/id.tmp";
				foreach (@{ $IDs{$file} }) {
					if (exists ${$NMgene_r}{$_} && exists ${$Genes_r}{${$NMgene_r}{$_}})
						{ $CNV_Genes{$file}{${$NMgene_r}{$_}} = 1; }
					}
				}
			close MERGE;
			$CNVbed{"allFiles"} = readBed("$outdir/allCNVs.bed");
			foreach my$chr (keys%{ $CNVbed{"allFiles"} }) {
				%{ $CNVbed{"allFiles"}->{$chr} } = mergeIntervals(\%{ $CNVbed{"allFiles"}->{$chr} }); 
				}
			@{ $IDs{"allFiles"} } = geneFromBed2("$outdir/id.tmp",$ref,$CNVbed{"allFiles"});
			unlink "$outdir/id.tmp";
			unlink "$outdir/allCNVs.bed";
			foreach (@{ $IDs{"allFiles"} }) {
				if (exists ${$NMgene_r}{$_} && exists ${$Genes_r}{${$NMgene_r}{$_}})
					{ $CNV_Genes{"allFiles"}{${$NMgene_r}{$_}} = 1; }
				}
			#change cov file with $Patients{$file}{"Ref_Profondeur_Patient"}
			if ($gatk) {
				my%gatkIdx2File;	#$gatkIdx{$file} = $i;
				foreach (keys%gatkIdx) { $gatkIdx2File{$gatkIdx{$_}} = $_; }	#$gatkIdx2File{$i} = $file;
				open(COV, "$outdir/all.cov") || die "can't open file $outdir/all.cov\n";
				open(NORM, ">$outdir/all.norm.cov") || die "can't create file $outdir/all.norm.cov\n";
				my$l=0; #line iteration
				while (my$line=<COV>) {
					chomp $line;
					my@tab = split(/\t/,$line);
					my$line2="";
					for my$i (0..2) { $line2 .= $tab[$i]."\t"; }
					for my$i (3..$#tab) { $line2 .= ($tab[$i] / ${$cnv_Patients_r}{$gatkIdx2File{$i}}{"Ref_depth"})."\t"; }
					chop $line2;
					print NORM $line2."\n";
					$l++;
					}
				close COV; close NORM;
				}
			else {
				foreach my$file (@Files) {
					open(COV, "$outdir/$fName{$file}.cov") || die "can't open file $outdir/$fName{$file}.cov\n";
					open(NORM, ">$outdir/$fName{$file}.norm.cov") || die "can't create file $outdir/$fName{$file}.norm.cov\n";
					while (my$line=<COV>){
						chomp $line;
						my@tab = split(/\t/,$line);
						$tab[-1] /= ${$cnv_Patients_r}{$file}{"Ref_depth"};
						my$line2="";
						foreach (@tab) { $line2 .= $_."\t"; }
						chop $line2;
						print NORM $line2."\n";
						}
					close COV; close NORM;
					}
				}
			#compute as in graphs by genes
			my(%CNV_NMdepth,%CNV_maxCov);
			foreach my$gene (keys%{ $CNV_Genes{"allFiles"} }) {

				print "analysing cov in $gene\n";
				my@NMs =  @{ ${$geneNM_r}{$gene} };
				my$chr = ${$NMchr_r}{$NMs[0]};
				my$sens = ${$NMsens_r}{$NMs[0]};
				## %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = depth
	
				foreach my$file (@Files) {
					print "\tfor $file\n";
					my$allDepth_r;
					if ($gatk)
						{ $allDepth_r = intersect($gatkIdx{$file},"$outdir/all.norm.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },$gatk,""); }
					else 
						{ $allDepth_r = intersect($fName{$file},"$outdir/$fName{$file}.norm.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },$gatk,""); }

					## %NMdepth: key = $file, value = %(key = $NM, value = %( key = $ex, value = @(cov foreach ordered bp of exon) ) )
					## @{ $CNV_NMdepth{$gene}->{$file}{$eachReg} } = [ depth foreach ordered bp of Reg ]
					$CNV_NMdepth{$gene}->{$file} = depthLine(\%{ $Regions{"raw"}->{$chr}{$gene} },$allDepth_r);
					}

				if ($maxGr) { $CNV_maxCov{$gene} = $maxGr; }
				else {
					@hashSub = maxCov(\@Files,$CNV_NMdepth{$gene},\%{ $Regions{"rev"}->{$gene} }); 
					$CNV_maxCov{$gene} = $hashSub[0];
					}

				##reverse depth coord if sens "-"
				if ($Rev && ($sens eq "-")) {
					my$nEx = scalar(keys%{ $CNV_NMdepth{$gene}->{$Files[0]} }) -1;
					foreach my$file (@Files) {
						#$nEx = scalar(keys%{ $CNV_NMdepth{$gene}->{$file} }) -1;
						my%tmp;
						foreach my$ex (sort{$a<=>$b}(keys%{ $CNV_NMdepth{$gene}->{$file} })) {
							@{ $tmp{($nEx-$ex)} } = reverse@{ $CNV_NMdepth{$gene}->{$file}{$ex} };
							}
						%{ $CNV_NMdepth{$gene}->{$file} } = %tmp;
						}
					}

				}
			#print graphs
			foreach my$file (@Files) {
				foreach my$gene (sort(keys%{ $CNV_Genes{$file} })) {
					#print "printing CNV graph for $sName2{$file}, in $gene\n";
					my@NMs =  @{ ${$geneNM_r}{$gene} };
					my$chr = ${$NMchr_r}{$NMs[0]};
					my$sens = ${$NMsens_r}{$NMs[0]};
					CNVgraphByGene($file,$suff,"$outdir/CNV_analysis/$sName2{$file}",$gene,$sens,$maxGr,$Rev,$chr,$CNV_maxCov{$gene},$pThreshold,$NMlength{$gene},\@Files,\%sName2,$Regions{"raw"},$Regions{"rev"},\@NMs,$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$CNV_NMdepth{$gene});
					}
				}
			}

		}
	
	}


###################
#rm tmp files
foreach my$f ("regions","original","merge")
	{ unlink "$outdir/$f\_0Chr.bed","$outdir/$f\_wChr.bed"; }
if (($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream))
	{ unlink "$outdir/txtRegions_0Chr.bed","$outdir/txtRegions_wChr.bed"; }

if (!$jobs{"keepBed"}) {
	if ($jobs{"covBed"} && !$bedFile)
		{ unlink "$outdir/$bedName.bed"; }
	if ($splitBed)
		{ unlink "$splitBed"; }
	if ($rmOverlapBed)
		{ unlink "$rmOverlapBed"; }
	if ($cutBed)
		{ unlink "$cutBed"; }
	}

if ($jobs{"keepCov"}) {
	if ($gatk) {
		#open(my$fhOut, ">", "$outdir/gatk.all.cov.txt") or die "cannot create $outdir/gatk.all.cov.txt file\n";
		#foreach (@{ $headers{"$outdir/all.cov"} }) { print $fhOut "$_"; }
		#open(my$fhIn, "<", "$outdir/all.cov") or die "cannot read $outdir/all.cov\n";
		#while (<$fhIn>) { print $fhOut "$_"; }
		#close $fhIn; close $fhOut;
		my$cmd = "cat $outdir/all.cov.headers.txt $outdir/all.cov > $outdir/gatk.all.cov.txt";
		print "$cmd\n";
		system "$cmd";
		}	
	}

if (-e "$outdir/chromLength.txt") { unlink "$outdir/chromLength.txt"; }

if ($gatk) {
	unlink glob "$outdir/all.cov*";
	if ($jobs{"CNV"}) { unlink glob "$outdir/all.norm.cov*"; }
	}
else {
	foreach (@Files) {
		unlink glob "$outdir/$fName{$_}.cov*";
		if ($jobs{"CNV"}) { unlink glob "$outdir/$fName{$_}.norm.cov*"; }
		}
	}

if ($dedup eq "do") {
	foreach (@Files) 
		{ unlink "$outdir/$fName{$_}-dedup.bam","$outdir/$fName{$_}-dedup.bam.bai","$outdir/$fName{$_}.dedup-metrics"; }
	}
foreach (@Files) {
	if (-e $tmpFile{$_}) 
		{ unlink "$tmpFile{$_}"; }
	}

if ($gz) {
	system "tar -zcvf $outdir.tar.gz $outdir";
	system "rm -rf $outdir";
	}

exit;


######################
sub readBed {

my($bed) = @_;
my%covBed;			#$covbed{$chr}{$start} = $end;	transform in hash with 1-based coord
open(BED, $bed) || die "can't open file $bed\n";
print "reading $bed\n";
my$ok=0;
while (my$line=<BED>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/^chr//i;
		#keep longest interval
		if ( exists $covBed{$tab[0]}{($tab[1]+1)} ) {
			if ( $tab[2] > $covBed{$tab[0]}{($tab[1]+1)})
				{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }
			else { next; }
			}
		else
			{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }
		}
	}
unless ($ok) { die "no bed formatted line in $bed file";}
close BED;
return(\%covBed);

}


######################
#only genes and transcipts

sub reAnnotBed1 {

print"look for transcripts overlapping bed file\n";
my($bedFile,$outFile,$refFile) = @_;	#refseq is in 0-based

#$RefCoord{$chr}{$start} = $end, in 1-based
#@{ $RefCoord{$chr}{$start}{$end} } = [$NM1,$NM2,...]
#bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#830	NM_004557	chr6	-	32162619	32191844	32163213	32191705	30	32162619,32164100,32164701,32165075,32166197,32166425,32166702,32168607,32168893,32169852,32171546,32171913,32178528,32180250,32180600,32180911,32181464,32181886,32183002,32184721,32184929,32185771,32187368,32187905,32188181,32188532,32188754,32190287,32190781,32191632,  32163927,32164198,32164849,32165371,32166336,32166507,32166922,32168783,32169277,32170376,32171659,32172166,32178713,32180404,32180688,32181029,32181617,32182032,32183162,32184844,32185043,32185885,32187563,32188061,32188418,32188655,32189102,32190583,32190863,32191844,  0	NOTCH4	cmpl	cmpl	0,1,0,1,0,2,1,2,2,0,1,0,1,0,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,0,
my(%RefCoord,%RefID);
open(my$fh, "<", $refFile) || die "can't open file $refFile\n";
while (my$line=<$fh>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;			
		push(@{ $RefCoord{$tab[2]}{$tab[4]}{$tab[5]} }, $tab[1]);
		$RefID{$tab[1]}{"cdsStart"} = $tab[6];
		$RefID{$tab[1]}{"cdsEnd"} = $tab[7];
		@{ $RefID{$tab[1]}{"exonStarts"} } = split(/,/,$tab[9]);
		@{ $RefID{$tab[1]}{"exonEnds"} } = split(/,/,$tab[10]);
		$RefID{$tab[1]}{"geneID"} = $tab[12];

		}
	}
close($fh);

my(%intervals,@chromOrder,%allChrom);
# $intervals{$chr}{$start}{$end} = $line;	
open($fh, "<", $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<$fh>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		unless (exists $allChrom{$tab[0]}) { push(@chromOrder,$tab[0]); $allChrom{$tab[0]} = 1; }
		$intervals{$tab[0]}{$tab[1]}{$tab[2]}{"info"} = "";
		if ($tab[4]) {
			for my$i (4..$#tab) { $intervals{$tab[0]}{$tab[1]}{$tab[2]}{"info"} .= "\t".$tab[$i]; }
			}
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close ($fh);

foreach my$chr (keys%intervals) {
	my@bedStarts = sort{$a<=>$b}keys%{ $intervals{$chr} };
	my@refStarts = sort{$a<=>$b}keys%{ $RefCoord{$chr} };
	my$c=0;	#idx of @refStarts
	my@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
	foreach my$bedstart(@bedStarts) {
		while ( ($c<(scalar@refStarts-1)) && ($bedstart > $RefEndC[0]) ) {
			$c++;
			@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
			}
		foreach my$bedEnd (sort{$a<=>$b}keys%{ $intervals{$chr}{$bedstart} }) {
			my$c2=$c;
			my@RefEndC2 = @RefEndC;
			while (($c2<(scalar@refStarts-1)) && ($bedEnd>=$refStarts[$c2])) {
				foreach my$refEnd (@RefEndC2) {
					if ($bedstart<=$refEnd) {
						foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) 
							{ $intervals{$chr}{$bedstart}{$bedEnd}{"NM"}{$_} = 1; }
						}
					else { last; }
					}
				$c2++;
				@RefEndC2 = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c2]} };
				}
			if ($bedEnd>=$refStarts[$c2]) {
				foreach my$refEnd (@RefEndC2) {
					if ($bedstart<=$refEnd) { 
						foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) 
							{ $intervals{$chr}{$bedstart}{$bedEnd}{"NM"}{$_} = 1; }
						}
					else { last; }
					}
				}
			}
		}
	}

#print annotated bed
open($fh, ">", "$outFile") || die "can't create file $outFile\n";
foreach my$chr (@chromOrder) {
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my$line = $chr."\t".$start;
		foreach my$end ( sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} }) ) {
				$line .= "\t".$end."\t";
			my%genes;
			foreach my$nm (keys%{ $intervals{$chr}{$start}{$end}{"NM"} }) {
				push(@{ $genes{$RefID{$nm}{"geneID"}} }, $nm);
				}
			foreach my$gene (sort(keys%genes)) {
				$line .= "$gene:";
				foreach my$nm (@{ $genes{$gene} }) { $line .= "$nm,"; }
				chop $line;
				$line .= ";";
				}
			chop $line;
			if ($intervals{$chr}{$start}{$end}{"info"}) {
				$line .= "\t".$intervals{$chr}{$start}{$end}{"info"};
				}
			print $fh "$line"."\n";
			}
		}
	}
close ($fh);

}


######################
#genes and transcipts and exon nbr

sub reAnnotBed2 {

print"look for transcripts overlapping bed file\n";
my($bedFile,$outFile,$refFile) = @_;	#refseq is in 0-based

#$RefCoord{$chr}{$start} = $end, in 1-based
#@{ $RefCoord{$chr}{$start}{$end} } = [$NM1,$NM2,...]
#bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#830	NM_004557	chr6	-	32162619	32191844	32163213	32191705	30	32162619,32164100,32164701,32165075,32166197,32166425,32166702,32168607,32168893,32169852,32171546,32171913,32178528,32180250,32180600,32180911,32181464,32181886,32183002,32184721,32184929,32185771,32187368,32187905,32188181,32188532,32188754,32190287,32190781,32191632,  32163927,32164198,32164849,32165371,32166336,32166507,32166922,32168783,32169277,32170376,32171659,32172166,32178713,32180404,32180688,32181029,32181617,32182032,32183162,32184844,32185043,32185885,32187563,32188061,32188418,32188655,32189102,32190583,32190863,32191844,  0	NOTCH4	cmpl	cmpl	0,1,0,1,0,2,1,2,2,0,1,0,1,0,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,0,
my(%RefCoord,%RefID);
open(my$fh, "<", $refFile) || die "can't open file $refFile\n";
while (my$line=<$fh>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;			
		my@exStarts = split(/,/,$tab[9]);
		my$i=0;
		foreach (split(/,/,$tab[10])) {
			$RefCoord{$tab[2]}{$exStarts[$i]}{$_}{$tab[1]} = ($i+1);
			$i++;
			}
		$RefID{$tab[1]}{"txStart"} = $tab[4];
		$RefID{$tab[1]}{"txEnd"} = $tab[5];
		$RefID{$tab[1]}{"cdsStart"} = $tab[6];
		$RefID{$tab[1]}{"cdsEnd"} = $tab[7];
		$RefID{$tab[1]}{"geneID"} = $tab[12];

		}
	}
close($fh);

my(%intervals,@chromOrder,%allChrom);
# $intervals{$chr}{$start}{$end} = $line;	
open($fh, "<", $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<$fh>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		unless (exists $allChrom{$tab[0]}) { push(@chromOrder,$tab[0]); $allChrom{$tab[0]} = 1; }
		$intervals{$tab[0]}{$tab[1]}{$tab[2]}{"info"} = "";
		if ($tab[4]) {
			for my$i (4..$#tab) { $intervals{$tab[0]}{$tab[1]}{$tab[2]}{"info"} .= "\t".$tab[$i]; }
			}
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close ($fh);

foreach my$chr (keys%intervals) {
	my@bedStarts = sort{$a<=>$b}keys%{ $intervals{$chr} };
	my@refStarts = sort{$a<=>$b}keys%{ $RefCoord{$chr} };
	my$c=0;	#idx of @refStarts
	my@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
	foreach my$bedstart(@bedStarts) {
		while ( ($c<(scalar@refStarts-1)) && ($bedstart > $RefEndC[0]) ) {
			$c++;
			@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
			}
		foreach my$bedEnd (sort{$a<=>$b}keys%{ $intervals{$chr}{$bedstart} }) {
			my$c2=$c;
			my@RefEndC2 = @RefEndC;
			while (($c2<(scalar@refStarts-1)) && ($bedEnd>=$refStarts[$c2])) {
				foreach my$refEnd (@RefEndC2) {
					if ($bedstart<=$refEnd) {
						foreach my$nm (keys%{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) {
							push(@{ $intervals{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm} }, $RefCoord{$chr}{$refStarts[$c2]}{$refEnd}{$nm});
							}
						}
					else { last; }
					}
				$c2++;
				@RefEndC2 = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c2]} };
				}
			if ($bedEnd>=$refStarts[$c2]) {
				foreach my$refEnd (@RefEndC2) {
					if ($bedstart<=$refEnd) { 
						foreach my$nm (keys%{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) { 
							push(@{ $intervals{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm} }, $RefCoord{$chr}{$refStarts[$c2]}{$refEnd}{$nm})
							}
						}
					else { last; }
					}
				}
			}
		}
	}

#print annotated bed
open($fh, ">", "$outFile") || die "can't create file $outFile\n";
foreach my$chr (@chromOrder) {
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my$line = $chr."\t".$start;
		foreach my$end ( sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} }) ) {
				$line .= "\t".$end."\t";
			my%genes;
			foreach my$nm (keys%{ $intervals{$chr}{$start}{$end}{"NM"} }) {
				push(@{ $genes{$RefID{$nm}{"geneID"}} }, $nm);
				}
			foreach my$gene (sort(keys%genes)) {
				$line .= "$gene:";
				foreach my$nm (sort@{ $genes{$gene} }) {
					$line .= "$nm:";
					foreach (@{ $intervals{$chr}{$start}{$end}{"NM"}{$nm} }) {
						$line .= "$_-";
						}
					chop $line;
					$line .= ",";
					}
				chop $line;
				$line .= ";";
				}
			chop $line;
			if ($intervals{$chr}{$start}{$end}{"info"}) {
				$line .= $intervals{$chr}{$start}{$end}{"info"};
				}
			print $fh "$line"."\n";
			}
		}
	}
close ($fh);

}


######################
#genes and transcipts and exon nbr, and if none, introns or intergenic (closer gene and distance to it)
sub reAnnotBed3 {

print"re_annotating with transcripts overlapping bed file\n";
my($bedFile,$outFile,$refFile,$chromOrderRf,$nonCod) = @_;	#refseq is in 0-based		if (exists ${$IDrf}{$nm})

my@chromOrder = @{$chromOrderRf};
#refFile in %RefCoord,%RefID
#bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#830	NM_004557	chr6	-	32162619	32191844	32163213	32191705	30	32162619,32164100,32164701,32165075,32166197,32166425,32166702,32168607,32168893,32169852,32171546,32171913,32178528,32180250,32180600,32180911,32181464,32181886,32183002,32184721,32184929,32185771,32187368,32187905,32188181,32188532,32188754,32190287,32190781,32191632,  32163927,32164198,32164849,32165371,32166336,32166507,32166922,32168783,32169277,32170376,32171659,32172166,32178713,32180404,32180688,32181029,32181617,32182032,32183162,32184844,32185043,32185885,32187563,32188061,32188418,32188655,32189102,32190583,32190863,32191844,  0	NOTCH4	cmpl	cmpl	0,1,0,1,0,2,1,2,2,0,1,0,1,0,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,0,
my(%RefCoord,%RefID);
open(my$fh, "<", $refFile) || die "can't open file $refFile\n";
while (my$line=<$fh>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		if(($nonCod) || ($tab[6] != $tab[7])) {
			$tab[2] =~ s/^chr//i;
			push(@{ $RefCoord{$tab[2]}{$tab[4]}{$tab[5]} }, $tab[1]);
			$RefID{$tab[1]}{"cdsStart"} = $tab[6];
			$RefID{$tab[1]}{"cdsEnd"} = $tab[7];
			@{ $RefID{$tab[1]}{"exonStarts"} } = split(/,/,$tab[9]);
			@{ $RefID{$tab[1]}{"exonEnds"} } = split(/,/,$tab[10]);
			$RefID{$tab[1]}{"geneID"} = $tab[12];
			}
		}
	}
close($fh);
##bedFile in %intervals
my(%intervals,@tmpOrder,%allChrom,%trueChr);		
open($fh, "<", $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<$fh>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		my$chr = $tab[0];
		$chr =~ s/^chr//i;
		unless (exists $allChrom{$chr}) {
			push(@tmpOrder,$chr);
			$allChrom{$chr} = 1;
			$trueChr{$chr} = $tab[0];
			}
		$intervals{$chr}{$tab[1]}{$tab[2]}{"info"} = "";
		if ($tab[4]) {
			for my$i (4..$#tab) { $intervals{$chr}{$tab[1]}{$tab[2]}{"info"} .= "\t".$tab[$i]; }
			}
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close ($fh);
unless (@{$chromOrderRf}) { @chromOrder = @tmpOrder; }


foreach my$chr (keys%intervals) {
	if (exists $RefCoord{$chr}) {
		my@bedStarts = sort{$a<=>$b}keys%{ $intervals{$chr} };
		my@refStarts = sort{$a<=>$b}keys%{ $RefCoord{$chr} };
		my$c=0;	#idx of @refStarts
		my@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
		foreach my$bedstart (@bedStarts) {
			while ( ($c < $#refStarts) && ($bedstart > $RefEndC[0]) ) {
				$c++;
				@RefEndC = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
				}
			foreach my$bedEnd (sort{$a<=>$b}keys%{ $intervals{$chr}{$bedstart} }) {
				if ($bedEnd < $refStarts[$c]) {					##out of genes
					if ($c==0) {							##before 1st gene
						foreach my$refEnd (@RefEndC) {
							foreach my$nm (@{ $RefCoord{$chr}{$refStarts[$c]}{$refEnd} }) {
								$intervals{$chr}{$bedstart}{$bedEnd}{"interG"}{$nm} = "--".($refStarts[$c] - $bedEnd);
								}
							}
						}
					else {								##between 2 genes
						my@RefEnd0 = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[($c-1)]} };
						if (($refStarts[$c] - $bedEnd) < ($bedstart - $RefEnd0[0])) {
							foreach my$nm (@{ $RefCoord{$chr}{$refStarts[$c]}{$RefEndC[0]} }) {
								$intervals{$chr}{$bedstart}{$bedEnd}{"interG"}{$nm} = "--".($refStarts[$c] - $bedEnd);
								}
							}
						else {
							foreach my$nm (@{ $RefCoord{$chr}{$refStarts[($c-1)]}{$RefEnd0[0]} }) {
								$intervals{$chr}{$bedstart}{$bedEnd}{"interG"}{$nm} = "+".($bedstart - $RefEnd0[0]);
								}
							}
						}
					}

				elsif (($c==$#refStarts) && ($bedstart>$RefEndC[0])) {	##beyond last gene
					foreach my$nm (@{ $RefCoord{$chr}{$refStarts[$c]}{$RefEndC[0]} }) {
						$intervals{$chr}{$bedstart}{$bedEnd}{"interG"}{$nm} = "+".($bedstart - $RefEndC[0]);
						}
					}

				else {
					my$c2=$c;
					my@RefEndC2 = @RefEndC;
					while (($c2 < $#refStarts) && ($bedEnd >= $refStarts[$c2])) {
						foreach my$refEnd (@RefEndC2) {
							if ($bedstart<=$refEnd) {
								foreach my$nm (@{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) {
									complete_intervalBed($chr,$bedstart,$bedEnd,$nm,\%intervals,\%RefID);
									}
								}
							else { last; }
							}
						$c2++;
						@RefEndC2 = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c2]} };
						}
					if ($bedEnd >= $refStarts[$c2]) {	##for $c2==$#refStarts
						foreach my$refEnd (@RefEndC2) {
							if ($bedstart<=$refEnd) { 
								foreach my$nm (@{ $RefCoord{$chr}{$refStarts[$c2]}{$refEnd} }) {
									complete_intervalBed($chr,$bedstart,$bedEnd,$nm,\%intervals,\%RefID);
									}
								}
							else { last; }
							}
						}
					}
				}
			}
		}
	}

#print annotated bed
open($fh, ">", "$outFile") || die "can't create file $outFile\n";
foreach my$chr (@chromOrder) {
	$chr =~ s/^chr//i;
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		foreach my$end ( sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} }) ) {
			my$line = $trueChr{$chr}."\t".$start."\t".$end."\t";
			if (exists $intervals{$chr}{$start}{$end}{"interG"}) {
				$line .= "interG:";
				my%genes;
				foreach my$nm (keys%{ $intervals{$chr}{$start}{$end}{"interG"} }) {
					push(@{ $genes{$RefID{$nm}{"geneID"}} }, $nm);
					}
				foreach my$gene (sort(keys%genes)) {
					$line .= "$gene:";
					foreach my$nm (sort@{ $genes{$gene} }) {
						$line .= $nm.$intervals{$chr}{$start}{$end}{"interG"}{$nm}.",";
						}
					chop $line;
					$line .= ";";
					}
				chop $line;
				}
			elsif (exists $intervals{$chr}{$start}{$end}{"NM"}) {
				my(%genes,%someExon);
				foreach my$nm (keys%{ $intervals{$chr}{$start}{$end}{"NM"} }) {
					push(@{ $genes{$RefID{$nm}{"geneID"}} }, $nm);
					if (exists $intervals{$chr}{$start}{$end}{"NM"}{$nm}{"exon"}) { $someExon{$RefID{$nm}{"geneID"}} = 1; }
					}
				foreach my$gene (sort(keys%genes)) {
					$line .= "$gene:";
					foreach my$nm (sort@{ $genes{$gene} }) {
						if (exists $intervals{$chr}{$start}{$end}{"NM"}{$nm}{"intron"}) {
							unless (exists $someExon{$gene}) {
								$line .= "$nm:ivs-".$intervals{$chr}{$start}{$end}{"NM"}{$nm}{"intron"}.",";
								}
							}
						else {
							$line .= "$nm:exon-";
							foreach (@{ $intervals{$chr}{$start}{$end}{"NM"}{$nm}{"exon"} }) {
								$line .= "$_";
								if ($intervals{$chr}{$start}{$end}{"NM"}{$nm}{"NC"}) { $line .= ".NC"; }
								$line .= "-";
								}
							chop $line;
							$line .= ",";
							}
						}
					chop $line;
					$line .= ";";
					}
				chop $line;
				}
			else { $line .= "."; }
			if ($intervals{$chr}{$start}{$end}{"info"}) {
				$line .= $intervals{$chr}{$start}{$end}{"info"};
				}
			print $fh "$line"."\n";
			}
		}
	}
close ($fh);

}
####
sub complete_intervalBed {

my($chr,$bedstart,$bedEnd,$nm,$interval_rf,$RefID_rf) = @_;
my$i = 0;
while ( ($i<(scalar@{ ${$RefID_rf}{$nm}{"exonStarts"} }-1)) && ($bedstart > ${$RefID_rf}{$nm}{"exonEnds"}[$i]) ) {
	$i++;
	}
if ($bedEnd < ${$RefID_rf}{$nm}{"exonStarts"}[$i]) {
	${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"intron"} = $i;
	}
else {
	while (($i<(scalar@{ ${$RefID_rf}{$nm}{"exonStarts"} }-1)) && ($bedEnd >= ${$RefID_rf}{$nm}{"exonStarts"}[$i])) {
		push(@{ ${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"exon"} }, ($i+1));
		if ($bedstart >= ${$RefID_rf}{$nm}{"cdsEnd"}) {
			${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"NC"} = 1;
			}
		if ($bedEnd <= ${$RefID_rf}{$nm}{"cdsStart"}) {
			${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"NC"} = 1;
			}
		$i++
		}
	if ($bedEnd >= ${$RefID_rf}{$nm}{"exonStarts"}[$i]) {
		push(@{ ${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"exon"} }, ($i+1));
		if ($bedstart >= ${$RefID_rf}{$nm}{"cdsEnd"}) {
			${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"NC"} = 1;
			}
		if ($bedEnd <= ${$RefID_rf}{$nm}{"cdsStart"}) {
			${$interval_rf}{$chr}{$bedstart}{$bedEnd}{"NM"}{$nm}{"NC"} = 1;
			}
		}
	}
}


######################
sub addLength2Bed {

my($bedFile,$newBed,$len) = @_;
open(BED, $bedFile) || die "can't open file $bedFile\n";
open(OUT, ">$newBed") || die "can't create file $newBed\n";
while (my$line=<BED>) {
	if ( ($line !~ /^\w+\t\d+\t\d+/) || ($line =~ /^#/) )
		{ print OUT "$line"; }
	else {
		chomp $line;
		my@tab = split(/\t/,$line);
		print OUT $tab[0]."\t".($tab[1]-$len)."\t".($tab[2]+$len);
		for my$i (3..$#tab) { print OUT "\t".$tab[$i]; }
		print OUT "\n";
		}
	}
close BED; close OUT;
}


######################
sub sliceBedIntervals {

my($bedFile,$outFile,$splitBed,$rmOverlapBed,$cutBed,$cutB_optRf,$chromOrder_r) = @_;
if ($splitBed) {
	print "splitting overlapping intervals from $bedFile\n";
	$splitBed = "$outFile";
	$splitBed =~ s/.bed$//;
	$splitBed .= "_split.bed";
	split_Bed($bedFile,$splitBed,$chromOrder_r);
	$bedFile = $splitBed;
	}
elsif ($rmOverlapBed) {
	print "removing overlapping intervals from $bedFile\n";
	$rmOverlapBed = "$outFile";
	$rmOverlapBed =~ s/.bed$//;
	$rmOverlapBed .= "_flat.bed";
	rm_overlap_Bed($bedFile,$rmOverlapBed,$chromOrder_r);
	$bedFile = $rmOverlapBed;
	}
if ($cutBed) {
	print "cutting intervals from $bedFile 
(above $cutB_opt{maxL} bp ; in $cutB_opt{cutL} bp pieces , if longer than $cutB_opt{minL} bp , else ";
	if ($cutB_opt{"keepLast"} eq "merge") { print "merge 2 last)\n"; }
	elsif ($cutB_opt{"keepLast"} eq "half") { print "keep 2 last with half of their sum)\n"; }
	else { print "through it)\n"; }
	$cutBed = "$outFile";
	$cutBed =~ s/.bed$//;
	$cutBed .= "_cut".$cutB_opt{"cutL"}.".bed";
	cut_Bed($bedFile,$cutBed,$cutB_optRf);
	if ($splitBed || $rmOverlapBed) { unlink $bedFile; }
	$bedFile = $cutBed;
	}
return($bedFile);
}


######################
sub split_Bed_inefficient {

#split_Bed($bedFile,$splitBed);
my($bedFile,$newBed) = @_;

my(%intervals,@chromOrder,%allChrom);
# $intervals{$chr}{$start}{$end} = $line;	
open(BED, $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<BED>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		unless (exists $allChrom{$tab[0]}) 
			{ push(@chromOrder,$tab[0]); $allChrom{$tab[0]} = 1; }
		my$info = "";
		if ($tab[3]) {
			for my$i (3..$#tab)
				{ $info .= "\t".$tab[$i]; }
			}
		#else { $info = "\t."; }
		$intervals{$tab[0]}{$tab[1]}{$tab[2]} = $info;
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close BED;

#intervals with same start : start = end of second to last; end = end of last
# $interval2{$chr}[idx]{"start"/"end"/"info"} = ;
my%interval2;
foreach my$chr (keys%intervals) {
	my$i=0;
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my@Ends = sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} });
		if (scalar@Ends > 1) {
			$interval2{$chr}[$i]{"start"} = $Ends[-2];
			$interval2{$chr}[$i]{"end"} = $Ends[-1];
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$Ends[-1]};
			$i++;
			}
		else {
			$interval2{$chr}[$i]{"start"} = $start;
			$interval2{$chr}[$i]{"end"} = $Ends[0];
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$Ends[0]};
			$i++;
			}
		}
	}
%intervals=();
#overlapping intervals : 
# $interval3{$chr}{$start}{"end"/"info"} = ;
my%interval3;
foreach my$chr (keys%interval2) { 
	my$i=0;
	while (($i+1) < scalar@{ $interval2{$chr} } ) {
		if ($interval2{$chr}[$i+1]{"start"} < $interval2{$chr}[$i]{"end"}) {
			my$End = $interval2{$chr}[$i]{"end"};
			my$Info = $interval2{$chr}[$i]{"info"};
			my%tmp1 = ($interval2{$chr}[$i]{"start"} => $End);
			my$j=$i;
			while (($j+1) < scalar@{ $interval2{$chr} } && $interval2{$chr}[$j+1]{"start"} < $End) {
				my%tmp2;
				my@tmpStarts = sort{$a<=>$b}(keys%tmp1);
				for (my$k=0;$k<scalar@tmpStarts;$k++) {
					if ($interval2{$chr}[$j+1]{"start"} < $tmp1{$tmpStarts[$k]}) {
						if ($interval2{$chr}[$j+1]{"start"} > $tmpStarts[$k]) {
							$interval3{$chr}{$tmpStarts[$k]}{"end"} = $interval2{$chr}[$j+1]{"start"};
							$interval3{$chr}{$tmpStarts[$k]}{"info"} = $Info;
							}
						if ($interval2{$chr}[$j+1]{"end"} < $tmp1{$tmpStarts[$k]}) {
							$tmp2{$interval2{$chr}[$j+1]{"start"}} = $interval2{$chr}[$j+1]{"end"};
							$tmp2{$interval2{$chr}[$j+1]{"end"}} = $tmp1{$tmpStarts[$k]};
							for (my$l=($k+1);$l<scalar@tmpStarts;$l++)
								{ $tmp2{$tmpStarts[$l]} = $tmp1{$tmpStarts[$l]}; }
							last;
							}
						else {
							$tmp2{$interval2{$chr}[$j+1]{"start"}} = $tmp1{$tmpStarts[$k]};
							if ($interval2{$chr}[$j+1]{"end"} > $tmp1{$tmpStarts[$k]})
								{ $interval2{$chr}[$j+1]{"start"} = $tmp1{$tmpStarts[$k]}; }
							}
						}
					else {
						if ($interval2{$chr}[$j+1]{"start"} > $tmpStarts[$k]) {				
							$interval3{$chr}{$tmpStarts[$k]}{"end"} = $tmp1{$tmpStarts[$k]};
							$interval3{$chr}{$tmpStarts[$k]}{"info"} = $Info;
							}
						}
					}
				%tmp1 = %tmp2;
				$j++;
				}
			foreach (sort{$a<=>$b}(keys%tmp1)) {
				$interval3{$chr}{$_}{"end"} = $tmp1{$_};
				$interval3{$chr}{$_}{"info"} = $Info;
				}
			}
		else {
			unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
				}
			}
		$i++;
		}
	unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
		}
	}
%interval2=();
#print splitted bed
open(BED, ">$newBed") || die "can't create file $newBed\n";
foreach my$chr (@chromOrder) {
	if (exists $interval3{$chr}) {
		foreach my$start ( sort{$a<=>$b}(keys%{ $interval3{$chr} }) ) { 
			print BED $chr."\t".$start."\t".$interval3{$chr}{$start}{"end"}.$interval3{$chr}{$start}{"info"}."\n";
			}
		}
	}
close BED;

}


######################
sub split_Bed {

#split_Bed($bedFile,$splitBed);
my($bedFile,$newBed,$chromOrderRf) = @_;
my@chromOrder = @{$chromOrderRf};

##bedFile in %intervals
my(%intervals,@tmpOrder,%allChrom,%trueChr);		
open(my$fh, "<", $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<$fh>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		my$chr = $tab[0];
		$chr =~ s/^chr//i;
		unless (exists $allChrom{$chr}) {
			push(@tmpOrder,$chr);
			$allChrom{$chr} = 1;
			$trueChr{$chr} = $tab[0];
			}
		$intervals{$chr}{$tab[1]}{$tab[2]} = "";
		if ($tab[3]) {
			for my$i (3..$#tab)
				{ $intervals{$chr}{$tab[1]}{$tab[2]} .= "\t".$tab[$i]; }
			}
		#else { $intervals{$chr}{$tab[1]}{$tab[2]} = "\t."; }
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close ($fh);
unless (@{$chromOrderRf}) { @chromOrder = @tmpOrder; }

#split intervals with same start
# $interval2{$chr}[idx]{"start"/"end"/"info"} = ;
my%interval2;
foreach my$chr (keys%intervals) {
	my$i=0;
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my$currentStart=$start;
		foreach my$end ( sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} }) ) {
			$interval2{$chr}[$i]{"start"} = $currentStart;
			$interval2{$chr}[$i]{"end"} = $end;
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$end};
			$currentStart=$end;
			$i++;
			}
		}
	}
%intervals=();
#split overlapping intervals
# $interval3{$chr}{$start}{"end"/"info"} = ;
my%interval3;
foreach my$chr (keys%interval2) { 
	my$i=0;
	while (($i+1) < scalar@{ $interval2{$chr} } ) {
		if ($interval2{$chr}[$i+1]{"start"} < $interval2{$chr}[$i]{"end"}) {
			my$End = $interval2{$chr}[$i]{"end"};
			my$Info = $interval2{$chr}[$i]{"info"};
			my@allPos = ($interval2{$chr}[$i]{"start"},$interval2{$chr}[$i]{"end"}); 
			my$j=$i;
			while (($j+1) < scalar@{ $interval2{$chr} } && $interval2{$chr}[$j+1]{"start"} < $End) {
				push(@allPos,$interval2{$chr}[$j+1]{"start"});
				if ($interval2{$chr}[$j+1]{"end"} < $End) { push(@allPos,$interval2{$chr}[$j+1]{"end"}); }
				else {
					if ($interval2{$chr}[$j+1]{"end"} > $End)
						{ $interval2{$chr}[$j+1]{"start"} = $End; }
					}
				$j++;
				}
			my@allPos2 = sort{$a<=>$b}@allPos;
			for my$k (0..($#allPos2-1)) {
				$interval3{$chr}{$allPos2[$k]}{"end"} = $allPos2[$k+1];
				$interval3{$chr}{$allPos2[$k]}{"info"} = $Info;
				}
			}
		else {
			unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
				}
			}
		$i++;
		}
	unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
		}
	}
%interval2=();
#print splitted bed
open($fh, ">", "$newBed") || die "can't create file $newBed\n";
foreach my$chr (@chromOrder) {
	$chr =~ s/^chr//i;
	if (exists $interval3{$chr}) {
		foreach my$start ( sort{$a<=>$b}(keys%{ $interval3{$chr} }) ) { 
			print $fh $trueChr{$chr} ."\t".$start."\t".$interval3{$chr}{$start}{"end"}.$interval3{$chr}{$start}{"info"}."\n";
			}
		}
	}
close $fh;

}


######################
sub rm_overlap_Bed {

#no_overlap_Bed($bedFile,$splitBed);
my($bedFile,$newBed,$chromOrder_r) = @_;
my@chromOrder = @{$chromOrder_r};

##bedFile in %intervals
my(%intervals,@tmpOrder,%allChrom,%trueChr);		
open(my$fh, "<", $bedFile) || die "can't open file $bedFile\n";
my$ok=0;
while (my$line=<$fh>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		my$chr = $tab[0];
		$chr =~ s/^chr//i;
		unless (exists $allChrom{$chr}) {
			push(@tmpOrder,$chr);
			$allChrom{$chr} = 1;
			$trueChr{$chr} = $tab[0];
			}
		$intervals{$chr}{$tab[1]}{$tab[2]} = "";
		if ($tab[3]) {
			for my$i (3..$#tab)
				{ $intervals{$chr}{$tab[1]}{$tab[2]} .= "\t".$tab[$i]; }
			}
		#else { $intervals{$chr}{$tab[1]}{$tab[2]} = "\t."; }
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close ($fh);
unless (@{$chromOrder_r}) { @chromOrder = @tmpOrder; }

#intervals with same start : start = end of second to last; end = end of last
# $interval2{$chr}[idx]{"start"/"end"/"info"} = ;
my%interval2;
foreach my$chr (keys%intervals) {
	my$i=0;
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my@Ends = sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} });
		if (scalar@Ends > 1) {
			$interval2{$chr}[$i]{"start"} = $Ends[-2];
			$interval2{$chr}[$i]{"end"} = $Ends[-1];
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$Ends[-1]};
			$i++;
			}
		else {
			$interval2{$chr}[$i]{"start"} = $start;
			$interval2{$chr}[$i]{"end"} = $Ends[0];
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$Ends[0]};
			$i++;
			}
		}
	}
%intervals=();
#overlapping intervals : 
# $interval3{$chr}{$start}{"end"/"info"} = ;
my%interval3;
foreach my$chr (keys%interval2) { 
	my$i=0;
	while (($i+1) < scalar@{ $interval2{$chr} } ) {
		if ($interval2{$chr}[$i+1]{"start"} < $interval2{$chr}[$i]{"end"}) {
			if ($interval2{$chr}[$i+1]{"end"} > $interval2{$chr}[$i]{"start"}) {
				if ($interval2{$chr}[$i+1]{"start"} > $interval2{$chr}[$i]{"start"}) {
					$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i+1]{"start"};
					$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
					}
				if ($interval2{$chr}[$i+1]{"end"} < $interval2{$chr}[$i]{"end"}) {
					$interval2{$chr}[$i+1]{"start"} = $interval2{$chr}[$i+1]{"end"};
					$interval2{$chr}[$i+1]{"end"} = $interval2{$chr}[$i]{"end"};
					}
				else {
					$interval2{$chr}[$i+1]{"start"} = $interval2{$chr}[$i]{"end"};
					}
				}
			else {
				$interval2{$chr}[$i+1]{"start"} = $interval2{$chr}[$i]{"start"};
				$interval2{$chr}[$i+1]{"end"} = $interval2{$chr}[$i]{"end"};
				}
			}
		else {
			if (!exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} && $interval2{$chr}[$i]{"start"} != $interval2{$chr}[$i]{"end"}) {
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
				}
			}
		$i++;
		}
	if (!exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} && $interval2{$chr}[$i]{"start"} != $interval2{$chr}[$i]{"end"}) {
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
		}
	}
%interval2=();
#print no_overlap bed
open(BED, ">$newBed") || die "can't create file $newBed\n";
foreach my$chr (@chromOrder) {
	$chr =~ s/^chr//i;
	if (exists $interval3{$chr}) {
		foreach my$start ( sort{$a<=>$b}(keys%{ $interval3{$chr} }) ) { 
			print BED $trueChr{$chr}."\t".$start."\t".$interval3{$chr}{$start}{"end"}.$interval3{$chr}{$start}{"info"}."\n";
			}
		}
	}
close BED;

}



######################
sub cut_Bed {

my($bedFile,$newBed,$h1) = @_;
my%c_opt = %$h1;
my$cutL = $c_opt{"cutL"};

open(my$fhOut, ">", "$newBed") || die "can't create file $newBed\n";
open(my$fhBed, "<", "$bedFile") || die "can't open file $bedFile\n";
while (my$line=<$fhBed>) {
	chomp $line;
	my@tab = split(/\t/,$line);
	my$line2;
	if ( ($tab[2]-$tab[1]) >= $c_opt{"maxL"} ) {
		my$start = $tab[1];
		my$end = $tab[2];
		my$div=int(($end-$start) / $cutL);
		my$mod=($end-$start) % $cutL;
		my$info="";
		for (my$i=3;$i<scalar@tab;$i++)
			{ $info.=$tab[$i]."\t"; }
		chop $info;
		my$i=0;
		if ($c_opt{"keepLast"} && ($mod<$c_opt{"minL"})) {
			while ($i<($div-1)) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+(($i+1)*$cutL))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print $fhOut $line2."\n";
				$i++;
				}
			if ($c_opt{"keepLast"} eq "merge") {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				}
			else {
				my$lastI = $end-($start+($i*$cutL));
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+($i*$cutL)+int($lastI/2))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print $fhOut $line2."\n";
				$line2 = $tab[0]."\t".($start+($i*$cutL)+int($lastI/2))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				}
			print $fhOut $line2."\n";
			}
		else {
			while ($i<$div) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+(($i+1)*$cutL))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print $fhOut $line2."\n";
				$i++;
				}
			if ($mod>=$c_opt{"minL"}) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print $fhOut $line2."\n";
				}
			}
		}
	else {
		foreach my$i (@tab)
			{ $line2 .= $i."\t"; }
		chop $line2;
		print $fhOut $line2."\n";
		}
	}
close($fhBed);
close($fhOut);

}


#################### 
#extractBed from bedtools output
#not used anymore

sub extractBed {

my($dir,$file) = @_;
my%covBed;		#$covbed{$chr}{$start} = $end;

if ($dir) { 
	$dir =~ s/\/$//;
	open(COV, $dir."/".$file) || die "can't open file $file\n"; 
	}
else
	{ open(COV, $file) || die "can't open file $file\n"; }
while (my$line=<COV>) {
	chomp $line;
	my@tab = split(/\t/,$line);
	$tab[0] =~ s/chr//;
	if ( exists $covBed{$tab[0]}{($tab[1]+1)} ) {
		if ( $tab[2] > $covBed{$tab[0]}{($tab[1]+1)}) 
			{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }	
		else { next; }
		}
	else
		{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }
	}
close COV;
return(%covBed);
}


##############################
#print lines of RefSeq matching each $id of @IDs

sub gene2Ref {

my($idFile,$ref,$h1)=@_;
my@IDs=@$h1;
my@Ref;
if ($ref) {
	open(REF, $ref) || die "can't open file $ref\n";
	while (my$line=<REF>) {
		unless($line =~ /^#/) {
			chomp $line;
			my@tab = split(/\t/,$line);
			push(@Ref, $line);
			}
		}
	close(REF);
	}
else { die "RefSeq file required\n"; }
my@Ref2;
foreach my$id (@IDs) { 
	my@tmp = grep(/\t$id\t/i, @Ref); 
	if (@tmp) { push(@Ref2, @tmp); }
	else { die "can't find $id in $ref file\n"; }
	}
open(IDS, ">$idFile") || die "can't create file $idFile\n";
foreach(@Ref2) { print IDS "$_\n"; }
close(IDS);
}

##############################
#print lines of RefSeq matching each $id of @IDs

sub gene2Ref2 {

my($idFile,$refFile,$IDrf)=@_;
my(%allRefs);
#bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#830	NM_004557	chr6	-	32162619	32191844	32163213	32191705	30	32162619,32164100,32164701,32165075,32166197,32166425,32166702,32168607,32168893,32169852,32171546,32171913,32178528,32180250,32180600,32180911,32181464,32181886,32183002,32184721,32184929,32185771,32187368,32187905,32188181,32188532,32188754,32190287,32190781,32191632,  32163927,32164198,32164849,32165371,32166336,32166507,32166922,32168783,32169277,32170376,32171659,32172166,32178713,32180404,32180688,32181029,32181617,32182032,32183162,32184844,32185043,32185885,32187563,32188061,32188418,32188655,32189102,32190583,32190863,32191844,  0	NOTCH4	cmpl	cmpl	0,1,0,1,0,2,1,2,2,0,1,0,1,0,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,0,
if ($refFile) {
	open(my$fh, "<", "$refFile") || die "can't open file $refFile\n";
	while (my$line=<$fh>) {
		unless($line =~ /^#/) {
			chomp $line;
			my@tab=split(/\t/,$line);
			push(@{ $allRefs{"NM"}{uc($tab[1])} }, $line);
			push(@{ $allRefs{"gene"}{uc($tab[12])} }, uc($tab[1]));
			}
		}
	close($fh);
	}
else { die "RefSeq file required (opt -r)"; }

my%targets;
foreach my$id (@{$IDrf}) {
	$id = uc($id);
	if (exists $allRefs{"NM"}{$id}) { $targets{$id} = 1; }
	elsif (exists $allRefs{"gene"}{$id}) { 
		foreach my$nm (@{ $allRefs{"gene"}{$id} }) { $targets{$nm} = 1; }
		}
	else { die "can't find $id in $refFile file\n"; }
	}

open(my$fh, ">", "$idFile") || die "can't create file $idFile\n";
foreach my$nm (keys%targets) {
	foreach (@{ $allRefs{"NM"}{$nm} }) {
		print $fh "$_\n";
		}
	}
close($fh);
}


##############################
#old one

sub geneFromBed {
print"look for transcripts overlapping bed file\n";
my($ref,$h1) = @_;	#refseq in 0-based
my%interval = %$h1;	#$Bed{$chr}{$start} = $end , in 1-based
my@Chrom=(0);
my$ok1=0;		#next line if no NM in this chromosome
my$chr;
my@bedStarts=();
my(%allNM);
open(REF, $ref) || die "can't open file $ref\n";
while (my$line=<REF>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;
		unless ($tab[2] eq $Chrom[-1]) { 
			push (@Chrom, $tab[2]); print $tab[2]."\n";
			$ok1=0;
			foreach my$i (sort(keys%interval)) {
				if ($i eq $tab[2]) {
					$chr = $tab[2]; 
					@bedStarts = sort{$a<=>$b}keys%{ $interval{$chr} };
					$ok1=1;
					last; 
					}
				}
			}
		if ($ok1) {
			for (my$c=0;$c<scalar(@bedStarts);$c++) {
				if ( (($tab[4]+1) <= $interval{$chr}{$bedStarts[$c]}) && ($tab[5] >= $bedStarts[$c]) )
					{ $allNM{$tab[1]} = $tab[12]; }
				}
			}

		}
	}
close(REF);
my@Transcripts = sort{ $allNM{$a} cmp $allNM{$b} }keys%allNM ;
return(sort@Transcripts);
}


######################
#new one, refseq in ram

sub geneFromBed2 {

print"looking for transcripts overlapping bed file\n";
my($idFile,$refFile,$interval_rf) = @_;	#refseq in 0-based
#my%interval = %$h1;	#$Bed{$chr}{$start} = $end , in 1-based
my(%NM,@Transcripts,%RefCoord,%newLines);
#$RefCoord{$chr}{$start} = $end, in 1-based
#@{ $RefCoord{$chr}{$start}{$end} } = [$NM1,$NM2,...]		
open(REF, $refFile) || die "can't open file $refFile\n";
while (my$line=<REF>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;			
		push(@{ $RefCoord{$tab[2]}{($tab[4]+1)}{$tab[5]}{"NM"} }, $tab[1]);
		push(@{ $RefCoord{$tab[2]}{($tab[4]+1)}{$tab[5]}{"line"} }, $line);
		}
	}
close(REF);

foreach my$chr (sort(keys%{$interval_rf})) {
	my@bedStarts = sort{$a<=>$b}keys%{ ${$interval_rf}{$chr} };
	my@refStarts = sort{$a<=>$b}keys%{ $RefCoord{$chr} };
	my$c=0;	#idx of @refStarts
	my@RefEnds = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
	foreach my$bedstart(@bedStarts) {
		while ( ($c<(scalar@refStarts-1)) && ($bedstart > $RefEnds[0]) ) { 
			$c++; 
			@RefEnds = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c]} };
			}
		my$c2=$c;
		while (($c2<(scalar@refStarts-1)) && (${$interval_rf}{$chr}{$bedstart}>=$refStarts[$c2])) {
			foreach my$end (@RefEnds) {
				if ($bedstart<=$end) { 
					foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$end}{"NM"} }) 
						{ $NM{$_}=1; }
					foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$end}{"line"} }) 
						{ $newLines{$_}=1;}
					}
				else { last; }
				}
			$c2++;
			@RefEnds = sort{$b<=>$a}keys%{ $RefCoord{$chr}{$refStarts[$c2]} };
			}
		if (${$interval_rf}{$chr}{$bedstart}>=$refStarts[$c2]) {
			foreach my$end (@RefEnds) {
				if ($bedstart<=$end) { 
					foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$end}{"NM"} }) 
						{ $NM{$_}=1; }
					foreach(@{ $RefCoord{$chr}{$refStarts[$c2]}{$end}{"line"} }) 
						{ $newLines{$_}=1;}
					}
				else { last; }
				}
			}
		}
	}
open(IDS, ">$idFile") || die "can't create file $idFile\n";
foreach(keys%newLines)
	{ print IDS "$_\n";}
close(IDS);
@Transcripts = sort(keys(%NM));
return(@Transcripts);
}


##########################
#RefSeq:
##bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#0	NM_032291	chr1	+	66999824	67210768	67000041	67208778	25	66999824,67091529,67098752,67101626,67105459,67108492,67109226,67126195,67133212,67136677,67137626,67138963,67142686,67145360,67147551,67154830,67155872,67161116,67184976,67194946,67199430,67205017,67206340,67206954,67208755,	67000051,67091593,67098777,67101698,67105516,67108547,67109402,67126207,67133224,67136702,67137678,67139049,67142779,67145435,67148052,67154958,67155999,67161176,67185088,67195102,67199563,67205220,67206405,67207119,67210768,	0	SGIP1	cmpl	cmpl	0,1,2,0,0,0,1,0,0,0,1,2,1,1,1,1,0,1,1,2,2,0,2,1,1,
## @hashSub = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$splitBedFromId,$mergeBedFromId,$nonCod,$wUTR,$id2Bed,\@ChromOrder);

sub Id2Coord {

my($idFile,$len5,$len3,$upstream,$downstream,$noOverlap,$mergeBedFromId,$nonCod,$wUTR,$id2Bed,$h1) = @_;
my@ChromOrder = @$h1;
my(%NMgene,%geneNM,%NMchr,%NMsens,%NMstartCod,%NMendCod,%NM_Ex,%Regions,%gOK,%hashBed,%printBed);

open(IDS, "$idFile") || die "can't open file $idFile\n";
while (my$line=<IDS>) {
	chomp $line;
	my@tab=split(/\t/,$line);
	$tab[2] =~ s/^chr//i;
	if ( (exists $geneNM{$tab[12]}) && ($tab[2] ne $NMchr{$geneNM{$tab[12]}[0]}) )
		{ $tab[12] .= "-$tab[2]"; }
	my$ok=1;
	if (exists $NMchr{$tab[1]}) {
		if ($tab[2] =~ /^$NMchr{$tab[1]}.+/)
			{ $ok=0; }
		unless ($NMchr{$tab[1]} =~ /$tab[2].+/)
			{ $ok=0; }
			#{ $tab[1].= "-$tab[2]"; }
		}
	unless ($nonCod) {
		#only coding transcipt: cdsStar != cdsEnd
		if ($tab[6] == $tab[7]) 
			{ $ok=0; }
		}
	if ($ok) {
		my$NM = $tab[1];
		my$gene = $tab[12];
		$NMgene{$NM} = $gene;
		push(@{ $geneNM{$gene} }, $NM);
		my$chr = $tab[2];
		$NMchr{$NM} = $chr;	
		$NMsens{$NM} = $tab[3];
		print $gene."\tchr: ".$NMchr{$NM}."\t".$NM."\tsens:".$NMsens{$NM}."\n";
		$NMstartCod{$NM} = ($tab[6]+1);	#for 1-based coord
		$NMendCod{$NM} = $tab[7];
		my@Starts = split(/,/,$tab[9]);
		my@Ends = split(/,/,$tab[10]);
		my(%interval,$firstCodingEx,$lastCodingEx,$minLen,$plusLen,$exonNb); # %interval in 1-based coord
		if ($tab[3] eq "+") { $minLen = $len5; $plusLen = $len3; }
		else { $minLen = $len3; $plusLen = $len5; }
		#expand exons +/-length:	
		if ($wUTR) {

			##intervals
			if ($upstream) { $interval{($Starts[0]+1-$upstream)} = $Ends[0]+$plusLen; }
			else { $interval{($Starts[0]+1-$minLen)} = $Ends[0]+$plusLen; }
			for (my$i=1;$i<(scalar(@Starts)-1);$i++)
				{ $interval{($Starts[$i]+1-$minLen)} = $Ends[$i]+$plusLen; }
			if ($downstream) { $interval{($Starts[-1]+1-$minLen)} = $Ends[-1]+$downstream; }
			else { $interval{($Starts[-1]+1-$minLen)} = $Ends[-1]+$plusLen; }
			##bed
			if ($id2Bed) {
				if ($tab[3] eq "+" && $upstream)
					{ $printBed{$chr}{($Starts[0]-$upstream)}{($Starts[0]-$minLen)}{$gene}{$NM} = "upstream"; }
				elsif ($tab[3] eq "-" && $downstream)
					{ $printBed{$chr}{($Starts[0]-$downstream)}{($Starts[0]-$minLen)}{$gene}{$NM} = "downstream"; }
				for (my$i=0;$i<scalar(@Starts);$i++) {
					if ($noOverlap && $Starts[$i+1] && ($Ends[$i]+$plusLen) > ($Starts[$i+1]-$minLen)) {
						my$ecart  = ($Starts[$i+1]-$Ends[$i]) / 2;
						$Ends[$i] = int($Ends[$i]+$ecart-$plusLen);
						$Starts[$i+1] = int($Starts[$i+1]-$ecart+$minLen);
						}
					if ($id2Bed) {
						if ($tab[3] eq "+") { $exonNb = ($i+1); }
						else { $exonNb = (scalar(@Starts)-$i); }
						$printBed{$chr}{($Starts[$i]-$minLen)}{($Ends[$i]+$plusLen)}{$gene}{$NM} = "exon$exonNb";
						if (($Ends[$i] < $NMstartCod{$NM}) || ($Starts[$i] > $NMendCod{$NM}))
							{ $printBed{$chr}{($Starts[$i]-$minLen)}{($Ends[$i]+$plusLen)}{$gene}{$NM} .= ".NC"; }
						}
					}
				if ($tab[3] eq "+" && $downstream)
					{ $printBed{$chr}{($Ends[-1]+$plusLen)}{($Ends[-1]+$downstream)}{$gene}{$NM} = "downstream"; }
				elsif ($tab[3] eq "-" && $upstream)
					{ $printBed{$chr}{($Ends[-1]+$plusLen)}{($Ends[-1]+$upstream)}{$gene}{$NM} = "upstream"; }
				}
			}

		else {

			##intervals
			for (my$i=0;$i<scalar(@Starts);$i++) {
				if ($Ends[$i] < $NMstartCod{$NM}) { next; }
				elsif ( ($Ends[$i] >= $NMstartCod{$NM}) && ($Starts[$i] <= $NMstartCod{$NM}) ) {
					$firstCodingEx = $i;
					if ($Ends[$i] > $NMendCod{$NM})
						{ $interval{($NMstartCod{$NM}-$minLen)} = $NMendCod{$NM}+$plusLen; }
					else
						{ $interval{($NMstartCod{$NM}-$minLen)} = $Ends[$i]+$plusLen; }
					}
				elsif ( ($Starts[$i] > $NMstartCod{$NM}) && ($Starts[$i] <= $NMendCod{$NM}) ) {
					if ($Ends[$i] < $NMendCod{$NM})
						{ $interval{($Starts[$i]+1-$minLen)} = $Ends[$i]+$plusLen; }
					else {
						$lastCodingEx = $i;
						$interval{($Starts[$i]+1-$minLen)} = $NMendCod{$NM}+$plusLen;
						}
					}
				else { last; }
				}
			##bed
			if ($id2Bed) {
				for (my$i=0;$i<scalar(@Starts);$i++) {
					if ($noOverlap && $Starts[$i+1] && ($Ends[$i]+$plusLen) > ($Starts[$i+1]-$minLen)) {
						my$ecart  = ($Starts[$i+1]-$Ends[$i]) / 2;
						$Ends[$i] = int($Ends[$i]+$ecart-$plusLen);
						$Starts[$i+1] = int($Starts[$i+1]-$ecart+$minLen);
						}
					if ($tab[3] eq "+") { $exonNb = ($i+1); }
					else { $exonNb = (scalar(@Starts)-$i); }
					if ($Ends[$i] < $NMstartCod{$NM}) { next; }
					elsif ( ($Ends[$i] >= $NMstartCod{$NM}) && ($Starts[$i] <= $NMstartCod{$NM}) ) {
						$firstCodingEx = $i;
						if ($Ends[$i] > $NMendCod{$NM})
							{ $printBed{$chr}{($tab[6]-$minLen)}{($tab[7]+$plusLen)}{$gene}{$NM} = "exon$exonNb"; }
						else
							{ $printBed{$chr}{($tab[6]-$minLen)}{($Ends[$i]+$plusLen)}{$gene}{$NM} = "exon$exonNb"; }
						}
					elsif ( ($Starts[$i] > $NMstartCod{$NM}) && ($Starts[$i] <= $NMendCod{$NM}) ) {
						if ($Ends[$i] < $NMendCod{$NM})
							{ $printBed{$chr}{($Starts[$i]-$minLen)}{($Ends[$i]+$plusLen)}{$gene}{$NM} = "exon$exonNb"; }
						else {
							$lastCodingEx = $i;
							$printBed{$chr}{($Starts[$i]-$minLen)}{($tab[7]+$plusLen)}{$gene}{$NM} = "exon$exonNb";
							}
						}
					else { last; }
					}
				}
			}

		#eventually merges overlapping intervals of regions
		#associates real exons to intervals
		my@Starts2 = sort{$a<=>$b}(keys%interval);
		my%interval2;
		my$start = $Starts2[0];
		my$end = $interval{$start};
		if ($wUTR) {
			$NM_Ex{$NM}{$start}{$Starts[0]+1} = $Ends[0];
			for (my$i=1;$i<scalar(@Starts2);$i++) {
				if ($Starts2[$i] <= $end) { 
					$end = $interval{$Starts2[$i]}; 
					$NM_Ex{$NM}{$start}{$Starts[$i]+1} = $Ends[$i];
					}
				else { 
					$interval2{$start} = $end;
					$start = $Starts2[$i];
					$end = $interval{$start};
					$NM_Ex{$NM}{$start}{$Starts[$i]+1} = $Ends[$i];
					}
				}
			$interval2{$start} = $end;
			$NM_Ex{$NM}{$start}{$Starts[-1]+1} = $Ends[-1];
			}
		else {
			$NM_Ex{$NM}{$start}{$NMstartCod{$NM}} = $Ends[$firstCodingEx];
			for (my$i=1;$i<scalar(@Starts2);$i++) {
				if ($Starts2[$i] <= $end) { 
					$end = $interval{$Starts2[$i]}; 
					$NM_Ex{$NM}{$start}{$Starts[$i+$firstCodingEx]+1} = $Ends[$i+$firstCodingEx];
					}
				else { 
					$interval2{$start} = $end;
					$start = $Starts2[$i];
					$end = $interval{$start};
					$NM_Ex{$NM}{$start}{$Starts[$i+$firstCodingEx]+1} = $Ends[$i+$firstCodingEx];
					}
				}
			$interval2{$start} = $end;
			$NM_Ex{$NM}{$start}{$Starts[$lastCodingEx]+1} = $NMendCod{$NM};
			}
		%{ $Regions{$chr}{$NM} } = %interval2;
		foreach (keys%interval2) {
			if ( exists $hashBed{$chr}{$_} ) {
				if ( $interval2{$_} > $hashBed{$chr}{$_}) 
					{ $hashBed{$chr}{$_} = $interval2{$_}; }	
				}
			else
				{ $hashBed{$chr}{$_} = $interval2{$_}; }
			}			
		}
	}
close(IDS);

if ($id2Bed) {
	my@allChrom = ();
	if (@ChromOrder) {
		foreach my$chr (@ChromOrder) {	#print STDERR "$chr\n";
			$chr =~ s/^chr//i;
			if (exists $printBed{$chr}) { push(@allChrom,$chr); }
			}
		}
	else {
		foreach my$chr (sort(keys%printBed)) { push(@allChrom,$chr); }
		}

	open(my$fh, ">", "$id2Bed") || die "can't create $id2Bed\n";
	if ($mergeBedFromId) {
		foreach my$chr (@allChrom) {
			#exons with same start
			my%printBed2 = ();
			foreach my$start (keys%{ $printBed{$chr} }) {
				my@ends = sort{$a<=>$b}keys%{ $printBed{$chr}{$start} };
				$printBed2{$start}{"end"} = $ends[-1];
				foreach my$end (keys%{ $printBed{$chr}{$start} }) {
					foreach my$gene (keys%{ $printBed{$chr}{$start}{$end} }) {
						foreach my$NM (keys%{ $printBed{$chr}{$start}{$end}{$gene} }) {
							push(@{ $printBed2{$start}{"info"}{$gene}{$NM} }, $printBed{$chr}{$start}{$end}{$gene}{$NM});
							}
						}
					}	
				}
			#overlapping exons
			my@Starts = sort{$a<=>$b}(keys%printBed2);
			my$start = $Starts[0];
			my$end = $printBed2{$start}{"end"};
			my%printBed3 = ();
			foreach my$gene (keys%{ $printBed2{$start}{"info"} }) {
				foreach my$NM (keys%{ $printBed2{$start}{"info"}{$gene} }) {
					push(@{ $printBed3{$gene}{$NM} }, @{ $printBed2{$start}{"info"}{$gene}{$NM} });
					}
				}
			for (my$i=1;$i<scalar(@Starts);$i++) {
				if ($Starts[$i] <= $end) {
					foreach my$gene (keys%{ $printBed2{$Starts[$i]}{"info"} }) {
						foreach my$NM (keys%{ $printBed2{$Starts[$i]}{"info"}{$gene} }) {
							push(@{ $printBed3{$gene}{$NM} }, @{ $printBed2{$Starts[$i]}{"info"}{$gene}{$NM} });
							}
						}
					if ($printBed2{$Starts[$i]}{"end"} > $end)
						{ $end = $printBed2{$Starts[$i]}{"end"}; }
					else { next; }
					}
				else {
					printID2BedMerge($fh,$chr,$start,$end,\%printBed3);
					%printBed3 = ();
					foreach my$gene (keys%{ $printBed2{$Starts[$i]}{"info"} }) {
						foreach my$NM (keys%{ $printBed2{$Starts[$i]}{"info"}{$gene} }) {
							push(@{ $printBed3{$gene}{$NM} }, @{ $printBed2{$Starts[$i]}{"info"}{$gene}{$NM} });
							}
						}
					$start = $Starts[$i];
					$end = $printBed2{$start}{"end"};
					}
				}
			printID2BedMerge($fh,$chr,$start,$end,\%printBed3);
			}
		}

	else {
		foreach my$chr (@allChrom) {
			foreach my$start (sort{$a<=>$b}keys%{ $printBed{$chr} }) {
				foreach my$end (sort{$a<=>$b}keys%{ $printBed{$chr}{$start} }) {
					my$info="";
					foreach my$gene (sort(keys%{ $printBed{$chr}{$start}{$end} })) {
						$info .= "$gene:";
						foreach my$NM (sort(keys%{ $printBed{$chr}{$start}{$end}{$gene} })) {
							$info .= "$NM:".$printBed{$chr}{$start}{$end}{$gene}{$NM}.",";
							}
						chop $info;
						$info .= ";";
						}
					chop $info;
					print $fh "$chr\t$start\t$end\t$info\n";
					}	
				}
			}
		}

	close $fh;
	}

my%Genes;
foreach (keys%geneNM) { 
	$Genes{$_} = 1;
	@{ $geneNM{$_} } = sort@{ $geneNM{$_} };
	}
return (\%geneNM,\%NMgene,\%NMchr,\%NMsens,\%NMstartCod,\%NMendCod,\%Regions,\%NM_Ex,\%Genes,\%hashBed);
}
####
sub printID2BedMerge {
my($fh,$chr,$start,$end,$infoRef) = @_;
my$info = "";
foreach my$gene (sort(keys%{$infoRef})) {
	$info .= "$gene:";
	foreach my$NM (sort(keys%{ ${$infoRef}{$gene} })) {
		$info .= "$NM:";
		foreach my$ex (@{ ${$infoRef}{$gene}{$NM} }) {
			$info .= "$ex-";
			}
		chop $info;
		$info .= ",";
		}
	chop $info;
	$info .= ";";
	}
chop $info;
print $fh "$chr\t$start\t$end\t$info\n";
}


#########################
## NM2GeneRegion($Genes_r,$geneNM_r,$NMchr_r,$Regions{"raw"},$NM_Ex{"raw"});
# @{ $geneNM{$gene} } = [$NM1,...]
# %NMchr : key = NM, value = chr
# $Regions{chr}{NM}{start of region} = end of region
# %NM_Ex{NM}{start of region}{start of exon} = end of exon

sub NM2GeneRegion {

my($Genes,$geneNM,$NMchr,$RegionR,$NM_ExR) = @_;
my%RegionG;
foreach my$gene (keys%{$Genes}) {
	my@NMs =  @{ ${$geneNM}{$gene} };
	my$chr = ${$NMchr}{$NMs[0]};
	print "change intervals for ".$gene." according to:\n\t".$NMs[0];
	%{ $RegionG{$chr}{$gene} } = %{ ${$RegionR}{$chr}{$NMs[0]} };
	my%geneNM_Ex;
	%{ $geneNM_Ex{$NMs[0]} } = %{ ${$NM_ExR}{$NMs[0]} };
	for(my$i=1;$i<scalar@NMs;$i++) {
		print "\t".$NMs[$i];
		changeRegion1($NMs[$i],\%{ $RegionG{$chr}{$gene} },\%geneNM_Ex,\%{ ${$RegionR}{$chr}{$NMs[$i]} },\%{ ${$NM_ExR}{$NMs[$i]} });
		}
	print "\n";
	foreach (@NMs) {
		%{ ${$NM_ExR}{$_} } = %{ $geneNM_Ex{$_} };
		}
	}
%{$RegionR} = %RegionG;
}


#########################
#make 1 common region from all transcripts of 1 gene
## changeRegion1($NMs[$i],$gene,$chr,\%{ $RegionG{$chr}{$gene} },\%geneNM_Ex,\%{ ${$RegionR}{$chr}{$NMs[$i]} },\%{ ${$NM_ExR}{$NMs[$i]} });

sub changeRegion1 {

my($NM,$RegionG1,$geneNM_Ex1,$RegionN,$NM_Ex_r) = @_;

my@StartG = sort{$a<=>$b}(keys%{$RegionG1});
my@StartN = sort{$a<=>$b}(keys%{$RegionN});
my(%RegionG2,%geneNM_Ex2);
my$c=0;	#$c: count of @StartG
my$i=0;	#$i: count of @StartN
my$endN = ${$RegionN}{$StartN[0]};

#if regionN ends before start of regionG
#while ( ($i < scalar@StartN) && ($endN < $StartG[0]) ) {
#	$RegionG2{$StartN[$i]} = $endN;
#	foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
#		{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
#	$i++;
#	$endN = ${$RegionN}{$StartN[$i]};
#	}
while ( $i < scalar@StartN ) {
	$endN = ${$RegionN}{$StartN[$i]};				
	if ( $endN < $StartG[$c] ) {
		$RegionG2{$StartN[$i]} = $endN;
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
		$i++; next;
		}
	while ( ($c < (scalar@StartG -1)) && ($StartN[$i] > ${$RegionG1}{$StartG[$c]}) ) {
		$RegionG2{$StartG[$c]} = ${$RegionG1}{$StartG[$c]};
		foreach my$nm (keys%{$geneNM_Ex1}) {
			foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
				{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
			}
		$c++; 
		}
	while ( ($c < (scalar@StartG -1)) && ($StartN[$i] <= ${$RegionG1}{$StartG[$c]}) && ($endN >= $StartG[$c]) ) {
		if ($StartN[$i] < $StartG[$c]) {
			if ($endN > ${$RegionG1}{$StartG[$c]})
				{ $RegionG2{$StartN[$i]} = $endN; }
			else
				{ $RegionG2{$StartN[$i]} = ${$RegionG1}{$StartG[$c]}; }
			foreach my$nm (keys%{$geneNM_Ex1}) { 
				foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartN[$i]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
			}
		else	{
			if ($endN > ${$RegionG1}{$StartG[$c]})
				{ $RegionG2{$StartG[$c]} = $endN; }
			else
				{ $RegionG2{$StartG[$c]} = ${$RegionG1}{$StartG[$c]}; }
			foreach my$nm (keys%{$geneNM_Ex1}) { 
				foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartG[$c]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
			}
		$c++;
		}
	#current $c
	if ( ($endN < $StartG[$c]) && ($StartN[$i]>${$RegionG1}{$StartG[$c-1]}) ) {
		$RegionG2{$StartN[$i]} = $endN;			
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
		}
	if ( $StartN[$i] > ${$RegionG1}{$StartG[$c]} ) {
		$RegionG2{$StartG[$c]} = ${$RegionG1}{$StartG[$c]};
		foreach my$nm (keys%{$geneNM_Ex1}) {
			foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
				{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
			} 
		}
	if ( ($StartN[$i] <= ${$RegionG1}{$StartG[$c]}) && ($endN >= $StartG[$c]) ) {
		if ($StartN[$i] < $StartG[$c]) {
			if ($endN > ${$RegionG1}{$StartG[$c]})
				{ $RegionG2{$StartN[$i]} = $endN; }
			else
				{ $RegionG2{$StartN[$i]} = ${$RegionG1}{$StartG[$c]}; }
			foreach my$nm (keys%{$geneNM_Ex1}) { 
				foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartN[$i]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
			}
		else {
			if ($endN > ${$RegionG1}{$StartG[$c]})
				{ $RegionG2{$StartG[$c]} = $endN; }
			else
				{ $RegionG2{$StartG[$c]} = ${$RegionG1}{$StartG[$c]}; }
			foreach my$nm (keys%{$geneNM_Ex1}) { 
				foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartG[$c]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
			}
		}
	#if regionN keep going on after end of regionG
	if ( $StartN[$i] > ${$RegionG1}{$StartG[-1]} ) {
		$RegionG2{$StartN[$i]} = $endN;		
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = ${$NM_Ex_r}{$StartN[$i]}{$startEx}; }
		}
	$i++;
	}
#if regionG keep going on after end of regionN
while ( ($c < scalar@StartG) && ($StartG[$c] > $endN) ) {
	$RegionG2{$StartG[$c]} = ${$RegionG1}{$StartG[$c]};
	foreach my$nm (keys%{$geneNM_Ex1}) { 
		foreach my$startEx (keys%{ ${$geneNM_Ex1}{$nm}{$StartG[$c]} })
			{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = ${$geneNM_Ex1}{$nm}{$StartG[$c]}{$startEx}; }
		}
	$c++; 
	}

#merge intervals
@StartG = sort{$a<=>$b}(keys%RegionG2);
my(%RegionG3,%geneNM_Ex3);
my$startReg = $StartG[0];
my$endReg = $RegionG2{$startReg};
foreach my$nm (keys%geneNM_Ex2) { 
	foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$startReg} })
		{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$startReg}{$startEx}; }
	}
for (my$i=1;$i<scalar(@StartG);$i++) {
	if ($StartG[$i] <= $endReg) { 
		if ($RegionG2{$StartG[$i]} > $endReg)
			{ $endReg = $RegionG2{$StartG[$i]}; }
		foreach my$nm (keys%geneNM_Ex2) {
			foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$StartG[$i]} })
				{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$StartG[$i]}{$startEx}; }
			}
		}
	else	{ 
		$RegionG3{$startReg} = $endReg;
		$startReg = $StartG[$i];
		$endReg = $RegionG2{$startReg};
		foreach my$nm (keys%geneNM_Ex2) {
			foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$startReg} })
				{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$startReg}{$startEx}; }
			}
		}
	}
$RegionG3{$startReg} = $endReg;

#return(\%RegionG3,\%geneNM_Ex3);
%{$RegionG1} = %RegionG3;
%{$geneNM_Ex1} = %geneNM_Ex3;

}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#create 1 hash :
#@hashSub = changeRegion2G(\@NMs,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $NM_Ex{"raw"} },\%{ $Bed{$chr} });
#%{ $RegBed{"raw"}{$gene} } = %{$hashSub[0]};	#$RegBed{$gene}{$startReg}{$startBed} = $endBed;

sub changeRegion2G {

my($NM_r,$interval1,$NM_Ex_r,$Bed_r) = @_;
my(%interval2,%NM_Ex2,%RegBed1);

my@Starts = sort{$a<=>$b}(keys%{$interval1});
my$c=0;	#$c: count of @StartInterval			
my@startBed = sort{$a<=>$b}keys%{$Bed_r};
my$endBed = ${$Bed_r}{$startBed[0]};
for (my$i=0;$i<scalar@startBed;$i++) {
	if ($startBed[$i] > ${$interval1}{$Starts[-1]})	#if bed keep going on after end of region
		{ last; }
	$endBed = ${$Bed_r}{$startBed[$i]};	
	if ( $endBed < $Starts[0] )
		{ next; }
	if ( $endBed < $Starts[$c] ) {
		if ($startBed[$i] > ${$interval1}{$Starts[$c-1]})
			{ 
			$interval2{$startBed[$i]} = $endBed; 
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			next;
			}
		else { $c--; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] > ${$interval1}{$Starts[$c]}) ) { 
		$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
		foreach my$NM (@{$NM_r}) {
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
				{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
			}
		$c++; 
		}
	if ( $startBed[$i] > ${$interval1}{$Starts[$c]} ) { #for current $c
		$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
		foreach my$NM (@{$NM_r}) {
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
				{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
			} 
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] <= ${$interval1}{$Starts[$c]}) && ($endBed >= $Starts[$c]) ) {
		if ($startBed[$i] < $Starts[$c]) {
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$NM (@{$NM_r}) {
				foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$startBed[$i]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		else {
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$NM (@{$NM_r}) {
				foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		$c++;
		}
	if ( ($startBed[$i] <= ${$interval1}{$Starts[$c]}) && ($endBed >= $Starts[$c]) ) {	#for current $c
		if ($startBed[$i] < $Starts[$c]) {
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$NM (@{$NM_r}) {
				foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$startBed[$i]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		else {
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$NM (@{$NM_r}) {
				foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		}
	}
#if region keep going on after end of bed
while ( ($c < scalar@Starts) && ($Starts[$c] > $endBed) ) {
	$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
	foreach my$NM (@{$NM_r}) {
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$NM}{$Starts[$c]} })
			{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$NM}{$Starts[$c]}{$startEx}; }
		}
	$c++; 
	}

#merge intervals
my(%interval3,%NM_Ex3,%RegBed2);
my@Starts2 = sort{$a<=>$b}(keys%interval2);
my$startReg = $Starts2[0];
my$endReg = $interval2{$startReg};
foreach my$NM (keys%NM_Ex2) {
	foreach my$startEx (keys%{ $NM_Ex2{$NM}{$startReg} })
		{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$startReg}{$startEx}; }
	}
foreach my$startBed (keys%{ $RegBed1{$startReg} })
	{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
for (my$i=1;$i<scalar(@Starts2);$i++) {
	if ($Starts2[$i] <= $endReg) { 
		if ($interval2{$Starts2[$i]} > $endReg)
			{ $endReg = $interval2{$Starts2[$i]}; }
		foreach my$NM (keys%NM_Ex2) {
			foreach my$startEx (keys%{ $NM_Ex2{$NM}{$Starts2[$i]} })
				{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$Starts2[$i]}{$startEx}; }
			}
		foreach my$startBed (keys%{ $RegBed1{$Starts2[$i]} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$Starts2[$i]}{$startBed}; }
		}
	else { 
		$interval3{$startReg} = $endReg;
		$startReg = $Starts2[$i];
		$endReg = $interval2{$startReg};
		foreach my$NM (keys%NM_Ex2)
			{
			foreach my$startEx (keys%{ $NM_Ex2{$NM}{$startReg} })
				{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$startReg}{$startEx}; }
			}
		foreach my$startBed (keys%{ $RegBed1{$startReg} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
		}
	}
$interval3{$startReg} = $endReg;

%{$interval1} = %interval3;

foreach my$NM (keys%NM_Ex3)
	{ %{ ${$NM_Ex_r}{$NM} } = %{ $NM_Ex3{$NM} }; }

return(\%RegBed2);
}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#create 1 hash :
#@hashSub = changeRegion2N(\%{ $Regions{"raw"}{$NMchr{$NM}}{$NM} },\%{ $NM_Ex{"raw"}{$NM} },\%{ $Bed{$NMchr{$NM}} });
#%{ $RegBed{"raw"}{$NM} } = %{$hashSub[0]};	#$RegBed{$NM}{$startReg}{$startBed} = $endBed;

sub changeRegion2N {

my($interval1,$NM_Ex_r,$Bed_r) = @_;
my(%interval2,%NM_Ex2,%RegBed1);

my@Starts = sort{$a<=>$b}(keys%{$interval1});
my$c=0;	#$c: count of @StartInterval			
my@startBed = sort{$a<=>$b}keys%{$Bed_r};
my$endBed = ${$Bed_r}{$startBed[0]};
for (my$i=0;$i<scalar@startBed;$i++)
	{
	if ($startBed[$i] > ${$interval1}{$Starts[-1]})	#if bed keep going on after end of region
		{ last; }
	$endBed = ${$Bed_r}{$startBed[$i]};	
	if ( $endBed < $Starts[0] )
		{ next; }
	if ( $endBed < $Starts[$c] )
		{
		if ($startBed[$i] > ${$interval1}{$Starts[$c-1]})
			{ 
			$interval2{$startBed[$i]} = $endBed; 
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			next;
			}
		else { $c--; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] > ${$interval1}{$Starts[$c]}) )
		{ 
		$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
			{ $NM_Ex2{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
		$c++; 
		}
	if ( $startBed[$i] > ${$interval1}{$Starts[$c]} )	#for current $c
		{ 
		$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
			{ $NM_Ex2{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] <= ${$interval1}{$Starts[$c]}) && ($endBed >= $Starts[$c]) )
		{
		if ($startBed[$i] < $Starts[$c])
			{
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
				{ $NM_Ex2{$startBed[$i]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
			}
		else
			{
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
				{ $NM_Ex2{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
			}
		$c++;
		}
	if ( ($startBed[$i] <= ${$interval1}{$Starts[$c]}) && ($endBed >= $Starts[$c]) )	#for current $c
		{
		if ($startBed[$i] < $Starts[$c])
			{
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
				{ $NM_Ex2{$startBed[$i]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
			}
		else
			{
			if ($endBed > ${$interval1}{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
				{ $NM_Ex2{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
			}
		}
	}
#if region keep going on after end of bed
while ( ($c < scalar@Starts) && ($Starts[$c] > $endBed) )
	{
	$interval2{$Starts[$c]} = ${$interval1}{$Starts[$c]};
	foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$c]} })
		{ $NM_Ex2{$Starts[$c]}{$startEx} = ${$NM_Ex_r}{$Starts[$c]}{$startEx}; }
	$c++; 
	}

#merge intervals
my(%interval3,%NM_Ex3,%RegBed2);
my@Starts2 = sort{$a<=>$b}(keys%interval2);
my$startReg = $Starts2[0];
my$endReg = $interval2{$startReg};
foreach my$startEx (keys%{ $NM_Ex2{$startReg} })
	{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$startReg}{$startEx}; }
foreach my$startBed (keys%{ $RegBed1{$startReg} })
	{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
for (my$i=1;$i<scalar(@Starts2);$i++)
	{
	if ($Starts2[$i] <= $endReg)
		{ 
		if ($interval2{$Starts2[$i]} > $endReg)
			{ $endReg = $interval2{$Starts2[$i]}; }
		foreach my$startEx (keys%{ $NM_Ex2{$Starts2[$i]} })
			{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$Starts2[$i]}{$startEx}; }
		foreach my$startBed (keys%{ $RegBed1{$Starts2[$i]} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$Starts2[$i]}{$startBed}; }
		}
	else
		{ 
		$interval3{$startReg} = $endReg;
		$startReg = $Starts2[$i];
		$endReg = $interval2{$startReg};
		foreach my$startEx (keys%{ $NM_Ex2{$startReg} })
			{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$startReg}{$startEx}; }
		foreach my$startBed (keys%{ $RegBed1{$startReg} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
		}
	}
$interval3{$startReg} = $endReg;

%{$interval1} = %interval3;

%{$NM_Ex_r} = %NM_Ex3;

return(\%RegBed2);
}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#no -L option: shorten bed eventually
#create 1 hash :
#%{ $RegBed{"raw"} } = linkBed(\%{ $Regions{"raw"} },\%Bed);

sub linkBed {

my($interval,$Bed_r) = @_;

#my%covBed2;			
my%RegBed;			#$RegBed{$NM}{$startRegion}{$startBed} = $endBed;
my$c=0;			#idx of $startByChr = sort{$a<=>$b}(keys%{ $allInterval{$chr} });
foreach my$chr (keys%{$interval}) {
	foreach my$NM (keys%{ ${$interval}{$chr} }) {
		my@Starts = sort{$a<=>$b}(keys%{ ${$interval}{$chr}{$NM} });
		my$c=0;
		foreach my$start (sort{$a<=>$b}keys%{ ${$Bed_r}{$chr} }) {
			my$end = ${$Bed_r}{$chr}{$start};
			if ( $end < $Starts[$c] )
				{ next; }
			while ( ($c < (scalar(@Starts)-1)) && ($start > ${$interval}{$chr}{$NM}{$Starts[$c]}) )
				{ $c++; }
			my$c2=$c;
			while ( ($c2 < scalar@Starts) && ($start <= ${$interval}{$chr}{$NM}{$Starts[$c2]}) && ($end >= $Starts[$c2]) ) { 
				#eventually restrict %Bed
				if ($start < $Starts[$c2]) {
					if ($end > ${$interval}{$chr}{$NM}{$Starts[$c2]}) { 
						#$covBed2{$chr}{$Starts[$c2]} = ${$interval}{$chr}{$NM}{$Starts[$c2]};
						$RegBed{$NM}{$Starts[$c2]}{$Starts[$c2]} = ${$interval}{$chr}{$NM}{$Starts[$c2]};
						}
					else { 
						#$covBed2{$chr}{$Starts[$c2]} = $end;
						$RegBed{$NM}{$Starts[$c2]}{$Starts[$c2]} = $end;
						}
					}
				else
					{
					if ($end > ${$interval}{$chr}{$NM}{$Starts[$c2]}) { 
						#$covBed2{$chr}{$start} = ${$interval}{$chr}{$NM}{$Starts[$c2]}; 
						$RegBed{$NM}{$Starts[$c2]}{$start} = ${$interval}{$chr}{$NM}{$Starts[$c2]};
						}
					else {
						#$covBed2{$chr}{$start} = $end; 
						$RegBed{$NM}{$Starts[$c2]}{$start} = $end;
						}
					}
				$c2++;
				}
			}
		}
	}
#return(\%covBed2,\%RegBed);
return(\%RegBed);
}


#########################
#eliminates $NM with no corresponding cov bed
#if ($All) { notAnalysedG($geneNM_r,\%Genes,\%{ $Regions{"raw"} },\%{ $NM_Ex{"raw"} },\%{ $RegBed{"raw"} }); }

sub notAnalysedG {

my($geneNM_r,$Gene_r,$Region_r,$NM_Ex_r,$RegBed_r) = @_;
my(@Not,%Genes2,%Regions2,%NM_Ex2,%RegBed2);

foreach my$gene (keys%{$Gene_r}) {
	my@startBed = keys%{ ${$RegBed_r}{$gene} };
	unless (@startBed) {
		print "$gene not in analysed bed\n";
		push(@Not ,$gene);
		}
	}
foreach my$chr (sort(keys%{$Region_r})) {
	foreach my$gene (sort(keys%{ ${$Region_r}{$chr} })) {
		my$ok=1;
		foreach my$not(@Not) {
			if ($gene eq $not)
				{ $ok=0; last; }
			}
		if ($ok) {
			$Genes2{$gene} = 1;
			%{ $Regions2{$chr}{$gene} } = %{ ${$Region_r}{$chr}{$gene} };
			foreach (@{ ${$geneNM_r}{$gene}})
				{ %{ $NM_Ex2{$_} } = %{ ${$NM_Ex_r}{$_} }; }
			%{ $RegBed2{$gene} } = %{ ${$RegBed_r}{$gene} };
			}	
		}
	}

%{$Gene_r} = %Genes2;
%{$Region_r} = %Regions2;
%{$NM_Ex_r} = %NM_Ex2;
%{$RegBed_r} = %RegBed2;

}

#############
#eliminates $NM with no corresponding cov bed
#else  { notAnalysedN(\%Genes,\%NMgene,\%{ $Regions{"raw"} },\%{ $NM_Ex{"raw"} },\%{ $RegBed{"raw"} }); }

sub notAnalysedN {

my($Gene_r,$NMgene_r,$Region_r,$NM_Ex_r,$RegBed_r) = @_;
my(@Not,%Genes2,%Regions2,%NM_Ex2,%RegBed2);

foreach my$NM (keys%{$NM_Ex_r}) {
	my@startBed = keys%{ ${$RegBed_r}{$NM} };
	unless (@startBed) {
		print "$NM not in analysed bed\n";
		push(@Not ,$NM);
		}
	}
foreach my$chr (sort(keys%{$Region_r})) {
	foreach my$NM (sort(keys%{ ${$Region_r}{$chr} })) {
		my$ok=1;
		foreach my$not(@Not) {
			if ($NM eq $not)
				{ $ok=0; last; }
			}
		if ($ok) {
			$Genes2{${$NMgene_r}{$NM}} = 1;
			%{ $Regions2{$chr}{$NM} } = %{ ${$Region_r}{$chr}{$NM} };
			%{ $NM_Ex2{$NM} } = %{ ${$NM_Ex_r}{$NM} };
			%{ $RegBed2{$NM} } = %{ ${$RegBed_r}{$NM} };
			}	
		}
	}

%{$Gene_r} = %Genes2;
%{$Region_r} = %Regions2;
%{$NM_Ex_r} = %NM_Ex2;
%{$RegBed_r} = %RegBed2;

}


#########################

sub readMut {

my($file) = @_;
my(%Mut);			#$covbed{$chr}{$start} = $end;
open(BED, $file) || die "can't open file $file\n";
while (my$line=<BED>) {
	unless($line =~ /^\s*$/ || $line =~ /^#/) {
		$line =~ s/\s+$//;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//i;
		$Mut{$tab[0]}{$tab[1]} = $tab[2];	#already in 1-based coord
		}
	}
close BED;
return(%Mut);

}


#########################
## %{ $RegMut{"raw"} } = linkMut(\%{ $Regions{"raw"} },\%Mut);
sub linkMut {

my($NM_interval_r,$Mut_r) = @_;
# ${$NM_interval_r}{chr}{NM}{start of region} = end of region
# ${$Mut_r}{$chr}{$startMut} = $infoMut;

my%RegMut;				#$RegMut{$NM}{$startRegion}{$startMut} = $MutInfo;
my$c=0;				#idx of $Starts = sort{$a<=>$b}(keys%{ ${$NM_interval_r}{$chr} });
foreach my$chr (keys%{$NM_interval_r}) {
	foreach my$NM (keys%{ ${$NM_interval_r}{$chr} }) {
		my%interval = %{ ${$NM_interval_r}{$chr}{$NM} };
		my@Starts = sort{$a<=>$b}(keys%interval);
		my$c=0;
		foreach my$mut (sort{$a<=>$b}keys%{ ${$Mut_r}{$chr} }) {
			if ( $mut < $Starts[$c] )
				{ next; }
			while ( ($c < (scalar(@Starts)-1)) && ($mut > $interval{$Starts[$c]}) )
				{ $c++; }
			if ( ($mut <= $interval{$Starts[$c]}) && ($mut >= $Starts[$c]) )
				{ $RegMut{$NM}{$Starts[$c]}{$mut} = ${$Mut_r}{$chr}{$mut}; }
			}
		}
	}

return(\%RegMut);

}


#########################
sub depthMut {

#%tmpFile = depthMut($mutFile,\%path,$extenS,\@Files,\%fName,\%Mut,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$mbq,$dedup,$bedT,$samT,$picard,$gatk,$genom);
my($mutFile,$h1,$extenS,$h2,$h3,$h4,$h5,$h6,$outdir,$h7,$keepTmp,$h8,$mmq,$mbq,$dedup,$threads,$chromLength,$bedT,$bedTversion,$samT,$picard,$gatk,$genom) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName = %$h4;
my%sName2 = %$h5;
my%Mut = %$h6;
my%withChr = %$h7;
my%tmpFile = %$h8;

#print bed
open(MUT0,">$outdir/mut_0Chr.bed") or die "cannot create $outdir/mut_0Chr.bed";
open(MUTw,">$outdir/mut_wChr.bed") or die "cannot create $outdir/mut_wChr.bed";
foreach my$chr (sort(keys%Mut)) {
	foreach my$pos (sort{$a<=>$b}keys%{ $Mut{$chr} }) {
		print MUT0 $chr."\t".($pos-1)."\t".$pos."\n";
		print MUTw "chr".$chr."\t".($pos-1)."\t".$pos."\n";
		}
	}
close(MUT0);close(MUTw);
#coveragedepth
my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}
my%depthMut;
my@Pos;
if($gatk) { 
	my($r1,$r2) = gatkCov("mut",\%path,$extenS,\@Files,\%fName,\%sName,$outdir,"all.covMut",$withChr{"all"},$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom);
	my%gatkIdx = %$r1;
	open(IN, "$outdir/all.covMut");
	while (<IN>) { 
		my$line = $_;
		chomp $line;
		my@tab = split(/\t/,$line);
		my@tab2 = split(/:/,$tab[0]);
		my$chr = $tab2[0];
		$chr =~ s/^chr//i;
		push(@Pos, $chr."\t".$tab2[1]);
		foreach(@Files)
			{ push (@{ $depthMut{$_} }, $tab[$gatkIdx{$_}]) ; }
		}
	close(IN);
	unlink glob "$outdir/all.covMut*";
	}
else {
	foreach (@Files) {
		$tmpFile{$_} = bedToolCmd("mut",$fName{$_},$path{$_},$extenS,$outdir,".covMut",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
		unless ($withChr{$_}) {
			open(COV, "$outdir/$fName{$_}.covMut") || die "can't open file $outdir/$fName{$_}.covMut\n";
			my$ok=0;
			while (my$line=<COV>) {
				chomp $line;
				my@tab = split(/\t/,$line);
				if ($tab[-1] != 0)
					{ $ok=1; last; }
				}
			close COV;
			unless ($ok) {
				print "try other reference genome:\n";
				foreach my$f (@Files) { 
					unless ($withChr{$f}) { 
						if ($isChr{$f}eq"_0Chr.bed") { $isChr{$f} = "_wChr.bed"; }
						else { $isChr{$f} = "_0Chr.bed"; }
						} 
					}
				$tmpFile{$_} = bedToolCmd("mut",$fName{$_},$path{$_},$extenS,$outdir,".covMut",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$samT,$picard);
				}
			}
		my$cmd = "sort -k 1,1 -k 2n,2n -k 4n,4n -o $outdir/$fName{$_}.covMut $outdir/$fName{$_}.covMut";
		print "$cmd\n";
		system "$cmd";
		open(IN, "$outdir/$fName{$_}.covMut");
		while (my$line=<IN>) {
			chomp $line;
			push (@{ $depthMut{$_} }, $line) ;
			}
		close(IN);
		unlink "$outdir/$fName{$_}.covMut";
		}
	}
unlink "$outdir/mut_0Chr.bed";
unlink "$outdir/mut_wChr.bed";

#print mut_depth.txt
my@mutName = split(/\//, $mutFile);
$mutName[-1] =~ s/.list$//;
open(COV, ">$outdir/$mutName[-1]\_depth.txt") or die "cannot create $outdir/$mutName[-1]\_depth.txt";
print COV "chr\t1-based position\tmutation";
foreach (@Files) { print COV "\t$sName2{$_}"; }
print COV "\n";
unless ($gatk) {
	foreach (@{ $depthMut{$Files[0]} }) {
		my@tab = split(/\t/,$_); 
		my$chr = $tab[0]; 
		$chr =~ s/^chr//i;
		push(@Pos, $chr."\t".($tab[1]+1));
		}
	}
for my$i (0 .. $#Pos) {
	print COV $Pos[$i];
	my@loc = split(/\t/,$Pos[$i]);
	print COV "\t".$Mut{$loc[0]}{$loc[1]};
	foreach my$file(@Files) {
		if ($gatk) { print COV "\t".$depthMut{$file}[$i]; }
		else {
			my@tab = split(/\t/,$depthMut{$file}[$i]); 
			print COV "\t".$tab[-1];
			}
		}
	print COV "\n";
	}
close(COV);
return(%tmpFile)

}


#########################
#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#if end of exon = x, start of next exon = x

#@hashSub = transposeReg($spacer,\%{ $Regions{"raw"} });
#$spacer = $hashSub[0];
#%NMlength = %{$hashSub[1]};			#$NMlength{$NM} = $end of region (for start of region = 0)
#%{ $Regions{"coord0"} } = %{$hashSub[2]};	#$Regions{"coord0"}{$NM}{start of region} = $end of region (for start of region = 0)

sub transposeReg {

my($spacer,$Region_r) = @_;
my(%Reg_00,%NMlength);

#$Reg_00{$NM}{$startReg} = endReg (for start of region = 0)
foreach my$chr (keys%{$Region_r}) {
	#$gene or $NM
	foreach my$gene ( keys%{ ${$Region_r}{$chr} } ) {
		print "transpose and splice $gene\n";
		my@Starts = sort{$a<=>$b}(keys%{ ${$Region_r}{$chr}{$gene} });
		#find $spacer as $NMlength/100
		#unless((exists $opts{S}) && ($opts{S} eq "N")) {
			$NMlength{$gene}=0;
			for (my$reg=0;$reg<scalar@Starts;$reg++)
				{ $NMlength{$gene} += (${$Region_r}{$chr}{$gene}{$Starts[$reg]} - $Starts[$reg] +1); }
			$spacer = int($NMlength{$gene}/100);
		#	}
		#transpose $Regions{$chr}{$gene}
		my$start00 = 0;
		my$end00 =  ${$Region_r}{$chr}{$gene}{$Starts[0]} - $Starts[0] + $start00 +1;
		$Reg_00{$gene}{$start00} = $end00;
		for (my$reg=1;$reg<scalar@Starts;$reg++) {
			$start00 = $end00 + $spacer;
			$end00 = ${$Region_r}{$chr}{$gene}{$Starts[$reg]} - $Starts[$reg] + $start00 +1;
			$Reg_00{$gene}{$start00} = $end00;
			}
		#re-calculates $NMlength
		my@Starts00 = sort{$a<=>$b}(keys%{ $Reg_00{$gene} });
		$NMlength{$gene} = $Reg_00{$gene}{$Starts00[-1]};
		}
	}

return($spacer,\%NMlength,\%Reg_00);

}

#########################
#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#if end of exon = x, start of next exon = x

#@hashSub = transposeNM($wUTR,$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%{ $Regions{"raw"}{$NMchr{$NM}}{$gene} },\%{ $Regions{"coord0"}{$gene} },\%{ $NM_Ex{"raw"}{$NM} }); 
#$NMstartCod{"coord0"}{$NM} = $hashSub[0];
#$NMendCod{"coord0"}{$NM} = $hashSub[1];
#%{ $NM_Ex{"coord0"}{$NM} } = %{$hashSub[2]};

sub transposeNM {

my($wUTR,$NMstartCod,$NMendCod,$Reg_raw,$Reg_00,$NM_Ex_r) = @_;

my(%NM_Ex00,$NMstartCod00,$NMendCod00);	
#NM_Ex00{$startReg}{$startExon} = endExon (for start of region = 0)
my@Starts = sort{$a<=>$b}(keys%{$Reg_raw});
my@Starts00 = sort{$a<=>$b}(keys%{$Reg_00});

my$r=0;
if ($wUTR) {
	#transpose $NMstartCod and $NMendCod
	if (($NMstartCod-1)!=$NMendCod) { 
		while ($NMstartCod > ${$Reg_raw}{$Starts[$r]}) { $r++; }
		$NMstartCod00 = $NMstartCod - $Starts[$r] + $Starts00[$r];
		while ( ($NMendCod > ${$Reg_raw}{$Starts[$r]}) ) { $r++; }
		$NMendCod00 = $NMendCod - $Starts[$r] + $Starts00[$r] +1;
		}
	else { $NMstartCod00=0; $NMendCod00=0; }
	#transpose %NM_Ex
	for ($r=0;$r<scalar@Starts;$r++) {
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$r]} }) {
			$NM_Ex00{$Starts00[$r]}{($startEx-$Starts[$r]+$Starts00[$r])} = ${$NM_Ex_r}{$Starts[$r]}{$startEx}-$Starts[$r]+$Starts00[$r]+1;
			}
		}
	}
else {
	my($rIni,$rFin);
	my@startsNM = sort{$a<=>$b}keys%{$NM_Ex_r};
	while ($r <= $#Starts && $Starts[$r] != $startsNM[0]) { $r++; }
	$rIni = $r;
	#transpose $NMstartCod and $NMendCod
	my@StartsEx1 = sort{$a<=>$b}keys%{ ${$NM_Ex_r}{$startsNM[0]} };
	$NMstartCod00 = $StartsEx1[0]-$startsNM[0] + $Starts00[$r];
	$r = $#Starts;
	while ($r > 0 && $Starts[$r] != $startsNM[-1]) { $r--; }
	$rFin = $r;
	my@StartsExf = sort{$a<=>$b}(keys%{ ${$NM_Ex_r}{$startsNM[-1]} });	
	$NMendCod00 = ${$Reg_raw}{$startsNM[-1]}-${$NM_Ex_r}{$startsNM[-1]}{$StartsExf[-1]} + $Starts00[$r] +1;
	#transpose %NM_Ex
	for ($r=$rIni;$r<=$rFin;$r++) {
		foreach my$startEx (keys%{ ${$NM_Ex_r}{$Starts[$r]} }) {
			$NM_Ex00{$Starts00[$r]}{($startEx-$Starts[$r]+$Starts00[$r])} = ${$NM_Ex_r}{$Starts[$r]}{$startEx}-$Starts[$r]+$Starts00[$r]+1;
			}
		}
	}

return($NMstartCod00,$NMendCod00,\%NM_Ex00);

}


#########################
#if ($All):
#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons
#@hashSub = designExons1($wUTR,\%Genes,\%geneNM,\%{ $Regions{"coord0"} },\%{ $NM_Ex{"coord0"} },\%{ $NMstartCod{"coord0"} },\%{ $NMendCod{"coord0"} });

sub designExons1 {

my($wUTR,$Gene_r,$geneNM_r,$Reg_00,$NM_Ex_00,$NMstartCod00,$NMendCod00) = @_;
my(%intron,%UTR,%Cod);
#$intron{$NM}{$startInt} = $endInt;
#$UTR{$NM}{$startUTR} = $endUTR;
#$Cod{$NM}{$startCod} = $endCod;

foreach my$gene (keys%{$Gene_r}) {
	print "design exons of $gene\n";
	my@startReg = sort{$a<=>$b}keys%{ ${$Reg_00}{$gene} } ; 
	foreach my$NM (@{ ${$geneNM_r}{$gene} }) {
		print "\tfor $NM\n";
		my(%Exons,@startEx);
		#introns:
		foreach my$startR (@startReg) {
			my@Starts = sort{$a<=>$b}(keys%{ ${$NM_Ex_00}{$NM}{$startR} });
			if (@Starts) {
				$intron{$NM}{$startR} = $Starts[0];
				for (my$ex=0;$ex<(scalar@Starts-1);$ex++)
					{ $intron{$NM}{ ${$NM_Ex_00}{$NM}{$startR}{$Starts[$ex]} } = $Starts[$ex+1]; }
				$intron{$NM}{ ${$NM_Ex_00}{$NM}{$startR}{$Starts[-1]} } = ${$Reg_00}{$gene}{$startR};
				push (@startEx , @Starts); 
				for (my$ex=0;$ex<scalar@Starts;$ex++)
					{ $Exons{$Starts[$ex]} = ${$NM_Ex_00}{$NM}{$startR}{$Starts[$ex]}; }
				}
			else
				{ $intron{$NM}{$startR} = ${$Reg_00}{$gene}{$startR}; }
			}
		#exons:
		my$i=0;
		if ($wUTR) {
			if (${$NMstartCod00}{$NM} == ${$NMendCod00}{$NM}) {
				while ($i<scalar@startEx) {
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;
					}
				}
			else {
					#UTRpreCod
				while ( $Exons{$startEx[$i]} < ${$NMstartCod00}{$NM} && $i<(scalar@startEx-1) ) {
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;						
					}
				if ( $startEx[$i] < ${$NMstartCod00}{$NM} ) 
					{ $UTR{$NM}{$startEx[$i]} = ${$NMstartCod00}{$NM}; }
					#Cod
				if( $Exons{$startEx[$i]} >= ${$NMendCod00}{$NM} )
					{ $Cod{$NM}{${$NMstartCod00}{$NM}} = ${$NMendCod00}{$NM}; }
				else {
					$Cod{$NM}{${$NMstartCod00}{$NM}} = $Exons{$startEx[$i]}; 
					$i++;
					while ( $Exons{$startEx[$i]} < ${$NMendCod00}{$NM} && $i<(scalar@startEx-1) ) {
						$Cod{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
						$i++;	
						}
					if ( $Exons{$startEx[$i]} >= ${$NMendCod00}{$NM} ) 
						{ $Cod{$NM}{$startEx[$i]} = ${$NMendCod00}{$NM}; }
					}
					#UTRpostCod
				if ( $Exons{$startEx[$i]} > ${$NMendCod00}{$NM} ) 
					{ $UTR{$NM}{${$NMendCod00}{$NM}} = $Exons{$startEx[$i]}; }
				while ($i<(scalar@startEx-1)) {
					$i++;
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					}
				}
			}
		else {
			foreach (@startEx)
				{ $Cod{$NM}{$_} = $Exons{$_}; }
			}
		}
	}

return(\%intron,\%UTR,\%Cod);

}

#########################
#foreach $NM
#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons
#@hashSub = designExons2($wUTR,\%{ $Regions{"coord0"} },\%{ $NM_Ex{"coord0"} },\%{ $NMstartCod{"coord0"} },\%{ $NMendCod{"coord0"} });

sub designExons2 {

my($wUTR,$Reg_00,$NM_Ex00,$NMstartCod00,$NMendCod00) = @_;
my(%intron,%UTR,%Cod);
#$intron{$NM}{$startInt} = $endInt;
#$UTR{$NM}{$startUTR} = $endUTR;
#$Cod{$NM}{$startCod} = $endCod;

foreach my$NM (keys%{$Reg_00}) {
	print "design exons of $NM\n";
	my@startReg = sort{$a<=>$b}keys%{ ${$Reg_00}{$NM} } ;
	my(%Exons,@startEx);
	#introns:
	foreach my$startR (@startReg) {
		my@Starts = sort{$a<=>$b}(keys%{ ${$NM_Ex00}{$NM}{$startR} });
		if (@Starts)
			{
			$intron{$NM}{$startR} = $Starts[0];
			for (my$ex=0;$ex<(scalar@Starts-1);$ex++)
				{ $intron{$NM}{ ${$NM_Ex00}{$NM}{$startR}{$Starts[$ex]} } = $Starts[$ex+1]; }
			$intron{$NM}{ ${$NM_Ex00}{$NM}{$startR}{$Starts[-1]} } = ${$Reg_00}{$NM}{$startR};
			push (@startEx , @Starts);
			for (my$ex=0;$ex<scalar@Starts;$ex++)
				{ $Exons{$Starts[$ex]} = ${$NM_Ex00}{$NM}{$startR}{$Starts[$ex]}; }
			}
		else
			{ $intron{$NM}{$startR} = ${$Reg_00}{$NM}{$startR}; }
		}
	#exons:
	my$i=0;
	if ($wUTR) {
		if (${$NMstartCod00}{$NM}==${$NMendCod00}{$NM}) {
			while ($i<scalar@startEx) {
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				$i++;
				}
			}
		else {
				#UTRpreCod
			while ( $Exons{$startEx[$i]}<${$NMstartCod00}{$NM} && $i<(scalar@startEx-1) ) {
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				$i++;						
				}
			if ( $startEx[$i] < ${$NMstartCod00}{$NM} ) 
				{ $UTR{$NM}{$startEx[$i]} = ${$NMstartCod00}{$NM}; }
				#Cod
			if( $Exons{$startEx[$i]} >= ${$NMendCod00}{$NM} )
				{ $Cod{$NM}{${$NMstartCod00}{$NM}} = ${$NMendCod00}{$NM}; }
			else {
				$Cod{$NM}{${$NMstartCod00}{$NM}} = $Exons{$startEx[$i]}; 
				$i++;
				while ( $Exons{$startEx[$i]}<${$NMendCod00}{$NM} && $i<(scalar@startEx-1) ) {
					$Cod{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;	
					}
				if ( $Exons{$startEx[$i]} >= ${$NMendCod00}{$NM} ) 
					{ $Cod{$NM}{$startEx[$i]} = ${$NMendCod00}{$NM}; }
				}
				#UTRpostCod
			if ( $Exons{$startEx[$i]} > ${$NMendCod00}{$NM} ) 
				{ $UTR{$NM}{${$NMendCod00}{$NM}} = $Exons{$startEx[$i]}; }
			while ($i<(scalar@startEx-1)) {
				$i++;
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				}
			}
		}
	else {
		foreach (@startEx)
			{ $Cod{$NM}{$_} = $Exons{$_}; }
		}
	}

return(\%intron,\%UTR,\%Cod);

}


#########################
#transposition and splicing of RegBed and RegMut
#@hashSub = transposeBed(\%{ $Regions{"raw"} },\%{ $Regions{"coord0"} },\%{ $RegBed{"raw"} },\%{ $RegMut{"raw"} });
#%{ $RegBed{"coord0"} } = %{$hashSub[0]};
#%{ $RegMut{"coord0"} } = %{$hashSub[1]};

sub transposeBed {

my($Reg_raw,$Reg_00,$RegBed_raw,$RegMut_raw) = @_;

my(%NMbed00,%NMmut00);		#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
					#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
foreach my$chr (keys%{$Reg_raw}) {
	foreach my$NM ( keys%{ ${$Reg_raw}{$chr} } )	#$gene or $NM
		{
		my@startReg = sort{$a<=>$b}(keys%{ ${$Reg_raw}{$chr}{$NM} });
		my@start00 = sort{$a<=>$b}(keys%{ ${$Reg_00}{$NM} });
		for (my$i=0;$i<scalar@startReg;$i++)
			{
			my$sub = $startReg[$i] - $start00[$i];
			foreach my$startBed ( keys%{ ${$RegBed_raw}{$NM}{$startReg[$i]} } )
				{ $NMbed00{$NM}{($startBed-$sub)} = ${$RegBed_raw}{$NM}{$startReg[$i]}{$startBed}-$sub+1; }
			foreach my$mut ( keys%{ ${$RegMut_raw}{$NM}{$startReg[$i]} } )
				{ $NMmut00{$NM}{($mut-$sub)} = ${$RegMut_raw}{$NM}{$startReg[$i]}{$mut}; }
			}
		}
	}

return(\%NMbed00,\%NMmut00);

}


##########################
#@hashSub = ReverseGene1($gene,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $RegBed{"coord0"}{$gene} },\%{ $RegMut{"coord0"}{$gene} });
#%{ $Regions{"rev"}{$gene} } = %{$hashSub[0]};
#%{ $RegBed{"rev"}{$gene} } = %{$hashSub[1]};
#%{ $RegMut{"rev"}{$gene} } = %{$hashSub[2]};

sub ReverseGene1 {

my($gene,$length,$Reg_00,$RegBed_00,$RegMut_00) = @_;

print "reverse $gene\n";
my(%Reg_rev,%NMbed_rev,%NMmut_rev);

foreach my$startReg (keys%{$Reg_00}) {
	$Reg_rev{($length - ${$Reg_00}{$startReg})} = $length - $startReg;
	}

%NMbed_rev = reverseEx($length,$RegBed_00);

#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
foreach (keys%{$RegMut_00}) {
	$NMmut_rev{($length - $_)} = ${$RegMut_00}{$_};
	}

return(\%Reg_rev,\%NMbed_rev,\%NMmut_rev);

}

##########################
#@hashSub = ReverseGene2($NM,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} });
#%{ $NM_Ex{"rev"}{$NM} } = %{$hashSub[0]};
#%{ $intron{"rev"}{$NM} } = %{$hashSub[1]};
#%{ $UTR{"rev"}{$NM} } = %{$hashSub[2]};
#%{ $Cod{"rev"}{$NM} } = %{$hashSub[3]};

sub ReverseGene2 {

my($NM,$length,$Reg_00,$NM_Ex_00,$intron_00,$UTR_00,$CDS_00) = @_;

print "reverse $NM\n";
my(%NM_Ex_rev,%intron_rev,%UTR_rev,%CDS_rev);

foreach my$startReg (keys%{$Reg_00}) {
	%{ $NM_Ex_rev{($length-${$Reg_00}{$startReg})} } = reverseEx( $length,\%{ ${$NM_Ex_00}{$startReg} } );
	}
	
# $intron{$NM}{$startIntron} = $endIntron (for start of region = 0)
%intron_rev = reverseEx($length,$intron_00);
# $UTR{$NM}{$startUTR} = $endUTR (for start of region = 0)
%UTR_rev = reverseEx($length,$UTR_00);
# $Cod{$NM}{$startCod} = $endCod (for start of region = 0)}
%CDS_rev = reverseEx($length,$CDS_00);

return(\%NM_Ex_rev,\%intron_rev,\%UTR_rev,\%CDS_rev);

}

##########################
#@hashSub = ReverseNMs($NM,$NMlength{$NM},\%{ $Regions{"coord0"}{$NM} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} },\%{ $RegBed{"coord0"}{$NM} },\%{ $RegMut{"coord0"}{$NM} });
#%{ $Regions{"rev"}{$NM} } = %{$hashSub[0]};
#%{ $NM_Ex{"rev"}{$NM} } = %{$hashSub[1]};
#%{ $intron{"rev"}{$NM} } = %{$hashSub[2]};
#%{ $UTR{"rev"}{$NM} } = %{$hashSub[3]};
#%{ $Cod{"rev"}{$NM} }= %{$hashSub[4]};
#%{ $RegBed{"rev"}{$NM} } = %{$hashSub[5]};
#%{ $RegMut{"rev"}{$NM} } = %{$hashSub[6]};

sub ReverseNMs {

my($NM,$length,$Reg_00,$NM_Ex_00,$intron_00,$UTR_00,$CDS_00,$RegBed_00,$RegMut_00) = @_;

print "reverse $NM\n";
my(%Reg_rev,%NM_Ex_rev,%intron_rev,%UTR_rev,%CDS_rev,%RegBed_rev,%RegMut_rev);

foreach my$startReg (keys%{$Reg_00}) {
	$Reg_rev{($length - ${$Reg_00}{$startReg})} = $length-$startReg;
	%{ $NM_Ex_rev{($length - ${$Reg_00}{$startReg})} } = reverseEx( $length,\%{ ${$NM_Ex_00}{$startReg} } );
	}

# $intron{$NM}{$startIntron} = $endIntron (for start of region = 0)
%intron_rev = reverseEx($length,$intron_00);
# $UTR{$NM}{$startUTR} = $endUTR (for start of region = 0)
%UTR_rev = reverseEx($length,$UTR_00);
# $Cod{$NM}{$startCod} = $endCod (for start of region = 0)}
%CDS_rev = reverseEx($length,$CDS_00);

#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
%RegBed_rev = reverseEx($length,$RegBed_00);

#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
foreach (keys%{$RegMut_00}) {
	$RegMut_rev{($length-$_)} = ${$RegMut_00}{$_};
	}

return(\%Reg_rev,\%NM_Ex_rev,\%intron_rev,\%UTR_rev,\%CDS_rev,\%RegBed_rev,\%RegMut_rev);

}


###########################
#merge intervals from %Regions: 
#$Regions{chr}{NM}{start of region} = end of region
#@hashSub = mergeRegions(\%{ $Regions{"raw"} });
#%allInterval = %{$hashSub[0]};

sub mergeRegions {

my($interval1) = @_;

print "merge overlapping intervals from RefSeq selected transcripts\n";
#$interval1{$chr}{$NM}{$start} = $end;
#$interval2{$chr}{$start} = $end;

#for each same starts, keep longer intervals
my(%interval2,%chrom);
foreach my$chr (keys%{$interval1}) {
	foreach my$NM (keys%{ ${$interval1}{$chr} }) {
		$chrom{$chr} = 1;
		foreach my$start ( sort{$a<=>$b}(keys%{ ${$interval1}{$chr}{$NM} }) ) {
			if ( exists $interval2{$chr}{$start} ) {
				if ( ${$interval1}{$chr}{$NM}{$start} > $interval2{$chr}{$start} )
					{  $interval2{$chr}{$start} = ${$interval1}{$chr}{$NM}{$start}; }	
				else { next; }
				}
			else
				{ $interval2{$chr}{$start} = ${$interval1}{$chr}{$NM}{$start}; }
			}
		}
	}
my@chrom = sort(keys%chrom);

#merge overlapping intervals
my(%interval3);
foreach my$chr (@chrom) { 
	my@Starts = sort{$a<=>$b}(keys%{ $interval2{$chr} }); 	#hash{chr}=@sortedStart
	my$start = $Starts[0];
	my$end = $interval2{$chr}{$start};
	$interval3{$chr}{$start} = $end;
	for (my$i=1;$i<scalar(@Starts);$i++) {
		if ($Starts[$i] <= $end) {
			if ($interval2{$chr}{$Starts[$i]} > $end)
				{ $end = $interval2{$chr}{$Starts[$i]}; }
			else { next; }
			}
		else {
			$interval3{$chr}{$start} = $end;
			$start = $Starts[$i];
			$end = $interval2{$chr}{$start};
			}
		}
	$interval3{$chr}{$start} = $end;
	}

return (\%interval3)	#$interval3{$chr}{$start} = $end;

}


#####################
#printBed("original",\%Bed,\@ChromOrder);

sub printBed {

my($bedFile,$interval_r,$ChromOrder_r) = @_;
open (OUT0, ">$outdir/$bedFile\_0Chr.bed")  || die "cannot create $outdir/$bedFile\_0Chr.bed\n";
open (OUTw, ">$outdir/$bedFile\_wChr.bed")  || die "cannot create $outdir/$bedFile\_wChr.bed\n";
if (@{$ChromOrder_r}) {
	foreach my$chrom (@{$ChromOrder_r}) {
		my$chr = $chrom;
		$chr =~ s/^chr//i;
		if (exists ${$interval_r}{$chr}) {
			foreach my$start (sort{$a<=>$b}keys%{ ${$interval_r}{$chr} }) {
				print OUT0 $chr."\t".($start-1)."\t".${$interval_r}{$chr}{$start}."\n";
				print OUTw "chr".$chr."\t".($start-1)."\t".${$interval_r}{$chr}{$start}."\n";
				}
			}
		}
	}
else {
	foreach my$chr (sort(keys%{$interval_r})) {
		foreach my$start (sort{$a<=>$b}keys%{ ${$interval_r}{$chr} }) {
			print OUT0 $chr."\t".($start-1)."\t".${$interval_r}{$chr}{$start}."\n";
			print OUTw "chr".$chr."\t".($start-1)."\t".${$interval_r}{$chr}{$start}."\n";
			}
		}
	}
close OUT0;
close OUTw;

}


####################
#no longer used

sub withChr {

my($bedName,$h1,$extenS,$h2,$h3,$outdir) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%withChr;
foreach (@Files) {
	#intersect: to know which bed to use (with or without chr prefix)
	$withChr{$_}="_0Chr.bed";
	print "bedtools intersect -a $path{$_}$fName{$_}$extenS -b $outdir/$bedName\_0Chr.bed -bed > $outdir/$fName{$_}\_inter.bed\n";
	system "bedtools intersect -a $path{$_}$fName{$_}$extenS -b $outdir/$bedName\_0Chr.bed -bed > $outdir/$fName{$_}\_inter.bed";
	if ( -z "$outdir/$fName{$_}\_inter.bed" ) { 
		print "no overlap between refseq and $fName{$_}\n";
		$withChr{$_}="_wChr.bed"; 
		}
	unlink "$outdir/$fName{$_}\_inter.bed";
	}

return(%withChr);

}


####################
#bedtools cov
sub bedToolsCov {

my($bedName,$h1,$extenS,$h2,$h3,$outdir,$h4,$keepTmp,$h5,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%withChr = %$h4;
my%tmpFile = %$h5;

my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}
foreach (@Files) {
	$tmpFile{$_} = bedToolCmd($bedName,$fName{$_},$path{$_},$extenS,$outdir,".cov",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
	unless ($withChr{$_}) {
		open(COV, "$outdir/$fName{$_}.cov") || die "can't open file $outdir/$fName{$_}.cov\n";
		my$ok=0;
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			if ($tab[-1] != 0)
				{ $ok=1; last; }
			}
		close COV;
		unless ($ok) {
			print "try other reference genome:\n";
			foreach (@Files) { 
				unless ($withChr{$_}) { 
					if ($isChr{$_}eq"_0Chr.bed") { $isChr{$_} = "_wChr.bed"; }
					else { $isChr{$_} = "_0Chr.bed"; }
					} 
				}
			$tmpFile{$_} = bedToolCmd($bedName,$fName{$_},$path{$_},$extenS,$outdir,".cov",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
			}
		$withChr{$_} = $isChr{$_};
		}

	my$cmd = "sort -k 1,1 -k 2n,2n -k 4n,4n -o $outdir/$fName{$_}.cov $outdir/$fName{$_}.cov";
	print "$cmd\n";
	system "$cmd";
	}
}

##
sub bedToolCmd {

my($bedName,$file,$path,$extenS,$outdir,$outname,$withChr,$keepTmp,$tmpFile,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard) = @_;
print "perform bedtools coverageBed on $file\n";
my$cmd="";
if ($tmpFile) {
	if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $tmpFile -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
	else	{ $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $tmpFile -d -sorted -g $chromLength > $outdir/$file$outname"; }
	}
else {
	if ($mmq) { 
		$cmd = "$samT view -u -q $mmq $path$file$extenS"; #-L $outdir/$bedName$withChr ?
		if ($keepTmp && !$dedup) {
			$cmd .= " > $outdir/$file.tmp.bam";
			print "$cmd\n";
			system "$cmd";
			$tmpFile = "$outdir/$file.tmp.bam";
			}		
		}
	if ($dedup) { 
		if ($mmq) { 
			$cmd .= " > $outdir/tmp.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "samtools not happy\n"; }
			$cmd = "$picard MarkDuplicates I=$outdir/tmp.bam O=/dev/stdout M=$outdir/$file.dedup-metrics REMOVE_DUPLICATES=true QUIET=true COMPRESSION_LEVEL=0"; 
			}
		else { $cmd = "$picard MarkDuplicates I=$path$file$extenS O=/dev/stdout M=$outdir/$file.dedup-metrics REMOVE_DUPLICATES=true QUIET=true COMPRESSION_LEVEL=0"; }
		if ($keepTmp) {
			$cmd .= " > $outdir/$file.tmp.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "picard tools not happy\n"; }
			$tmpFile = "$outdir/$file.tmp.bam";
			}
		}
	if ($mmq || $dedup) { 
		if ($keepTmp) {
			if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $tmpFile -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
			else { $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $tmpFile -d -sorted -g $chromLength > $outdir/$file$outname"; }
			}
		else {
			if ($bedTversion == 1) { $cmd .= " | $bedT coverage -abam stdin -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
			else { $cmd .= " | $bedT coverage -a $outdir/$bedName$withChr -b stdin -d -sorted -g $chromLength > $outdir/$file$outname"; }
			}
		}
	else { 
		if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $path$file$extenS -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
		else { $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $path$file$extenS -d -sorted -g $chromLength > $outdir/$file$outname"; }
		}
	}
print "$cmd\n";
system "$cmd";
if ($?) { die "bedtools not happy\n"; }
if (-e "$outdir/tmp.bam") { unlink "$outdir/tmp.bam"; }
if ($dedup) { unlink "$outdir/$file.dedup-metrics"; } 
return($tmpFile);

}


####################
#GATK cov
#%gatkIdx = gatkCov($intervalName,\%path,$extenS,\@Files,\%fName,$outdir,"all.cov",$withChr{"all"},$mmq,$mbq,$dedup,$gatk,$picard,$genom);
sub gatkCov {

my($intervalFile,$h1,$extenS,$h2,$h3,$h4,$outdir,$outName,$withChr,$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName = %$h4;

my$cmd="";
if ($dedup eq "do") {
	foreach (@Files) {
		unless (-e "$outdir/$fName{$_}-dedup.bam") {
			$cmd = "$picard MarkDuplicates I=$path{$_}$fName{$_}$extenS O=$outdir/$fName{$_}-dedup.bam M=$outdir/$fName{$_}.dedup-metrics QUIET=true  COMPRESSION_LEVEL=0";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "picard tools not happy\n"; }
			$cmd = "$samT index $outdir/$fName{$_}-dedup.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "samtools not happy\n"; }
			}
		}
	$cmd = "$gatk -T DepthOfCoverage -R $genom -L $outdir/$intervalFile$withChr";
	foreach (@Files) { $cmd .= " -I $outdir/$fName{$_}-dedup.bam"; }
	}
else { 
	$cmd = "$gatk -T DepthOfCoverage -R $genom -L $outdir/$intervalFile$withChr";
	foreach (@Files) { $cmd .= " -I $path{$_}$fName{$_}$extenS"; }
	}
unless ($dedup) { $cmd .= " -drf DuplicateRead"; }
if ($threads) { $cmd .= " -nt $threads"; }
$cmd .= " -mbq ";
if ($mbq) { $cmd .= "$mbq"; }
else { $cmd .= "0"; }
$cmd .= " -mmq ";
if ($mmq) { $cmd .= "$mmq"; }
else { $cmd .= "0"; }
$cmd .= " --countType COUNT_FRAGMENTS -omitLocusTable -omitSampleSummary -omitIntervals -o $outdir/$outName";
print "$cmd\n";
system "$cmd";
if ($?) { die "GATK not happy\n"; }

my%gatkIdx;
open(COV, "$outdir/$outName");
my$firstLine = <COV>;
print $firstLine;
chomp $firstLine;
my@header_cov = split(/\t/,$firstLine);
foreach my$file(@Files) {
	for (my$i=0;$i<scalar@header_cov;$i++) {
		if ($header_cov[$i] eq "Depth_for_$sName{$file}")
			{ $gatkIdx{$file} = $i; last; }
		}
	}
close COV;

#$cmd = "sed -i '1d' $outdir/$bedName-$outName";
#my@header_cov = `head -n 1 $outdir/$outName`;
$cmd = "head -n 1 $outdir/$outName > $outdir/$outName.headers.txt";
print "$cmd\n";
system "$cmd";
$cmd = "tail -n +2 $outdir/$outName > $outdir/tmpTail; mv $outdir/tmpTail $outdir/$outName";
print "$cmd\n";
system "$cmd";
return(\%gatkIdx,\@header_cov);

}


####################
#if bedtools covfile and interval not identical (in previous versions)
#scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
#create 2 hash : 
# - %allDepth: depth foreach position in intervals from %allInterval : $allCov{$chr}{$loc} = $cov
# - %notCov: start and end of each not covered domain within %allInterval

sub intersect {

#if ($gatk) { @hashSub = intersect($gatkIdx{$file},"$outdir/$intervalName-all.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{$chr}{$gene} },$gatk); }
#else { @hashSub = intersect($fName{$file},"$outdir/$file.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{$chr}{$gene} },$gatk); }
my($file,$covName,$maxD,$chr,$Thresholds_r,$Intervals_r,$gatk,$doNotCov) = @_;

my@Starts = sort{$a<=>$b}(keys%{$Intervals_r});
my%allDepth;		#for depth line : $allDepth{$loc} = $cov
my$c=0;			#idx of $startByChr

my$ok=0;
if ($gatk) {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		my@tab2 = split(/:/,$tab[0]);
		if ($tab2[0] eq $chr) {
			while ( ($tab2[1] > ${$Intervals_r}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			if ( ($tab2[1] >= $Starts[$c]) && ($tab2[1] <= ${$Intervals_r}{$Starts[$c]}) ) {
				my$loc = $tab2[1]; #already 1-based coordinate
				my$cov = $tab[$file];
				if ($maxD) { if ($cov > $maxD) { $cov = $maxD; } }
				$allDepth{$loc} = $cov; 
				}
			if ( $tab2[1] > ${$Intervals_r}{$Starts[-1]} )
				{ $ok = 1; }
			}
		if ($ok) { last; }
		}
	}
else {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		if ($tab[0] eq $chr) {
			while ( (($tab[1]+1) > ${$Intervals_r}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			if ( ($tab[2] >= $Starts[$c]) && (($tab[1]+1) <= ${$Intervals_r}{$Starts[$c]}) ) {
				my$loc = $tab[1]+$tab[-2]; #so now 1-based coordinate
				my$cov = $tab[-1];
				if ($maxD) { if ($cov > $maxD) { $cov = $maxD; } }
				$allDepth{$loc} = $cov; 
				}
			if ( ($tab[1]+1) > ${$Intervals_r}{$Starts[-1]} )
				{ $ok = 1; }
			}
		if ($ok) { last; }	
		}
	}
close COV;

##if some regions not present in cov file, put depth at 0
#foreach my$start (@Starts) {
#	my$pos = $start;
#	while ($pos <= ${$Intervals_r}{$start}) {
#		unless (exists $allDepth{$pos})
#			{  $allDepth{$pos} = 0; }
#		$pos++;
#		}
#	}

#cov-domains:
my%notCov;		#for cov-domains: foreach threshold, for regions < threshold: $notCov{$chr}{$start} = $end
my%notCovStarts;	#for cov-domains: foreach threshold, ordered starts of regions < threshold
if ($doNotCov) {
	my$noCovStart=0; my$noCovEnd=0;
	foreach my$threshold (@{$Thresholds_r}) {
		foreach my$start (@Starts) {
			my$pos=$start;
			while ($pos<=${$Intervals_r}{$start}) {
				if ( $allDepth{$pos} < $threshold ) {
					if ( $pos == ($noCovEnd + 1) ) { 
						$notCov{$threshold}{$noCovStart} = $pos ; 
						$noCovEnd = $pos; 
						}
					else { 
						$notCov{$threshold}{$pos} = $pos ; 
						$noCovStart = $pos; 
						$noCovEnd = $pos; 
						}
					}
				$pos++;
				}
			}
		@{ $notCovStarts{$threshold} } = sort{$a<=>$b}keys%{ $notCov{$threshold} };
		}
	return(\%allDepth,\%notCov,\%notCovStarts);
	}
else { return(\%allDepth); }

}


####################
#scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
#create 2 hash : 
# - %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = $cov
# - %notCov: start and end of each not covered domain within %allInterval
sub intersect2
{
my($file,$fileName,$outdir,$maxD,$Thresholds_r) = @_;

#all cov values:
my%allDepth;		#for cov-line : $allDepth{$loc} = $cov 

unless ( -s "$outdir/$fileName\_cov" ) { die "$outdir/$fileName\_cov is empty\n"; }
open(COV, "$outdir/$fileName\_cov") || die "can't open file $outdir/$fileName\_cov\n";
while (my$line=<COV>){
	if ($line =~ /^\s*$/) { die "bedtools file $file\_cov_sort.bed empty\n"; }
	chomp $line;
	my@tab = split(/\t/,$line);
	$tab[0] =~ s/chr//;
	$allDepth{($tab[1]+$tab[-2])} = $tab[-1]; #now 1-based coordinate
	if ($maxD) { 
		if ($tab[-1] > $maxD) 
			{ $allDepth{($tab[1]+$tab[-2])} = $maxD; } 
		}
	}
close COV;

#cov-domains:
my%notCov;		#for cov-domains: foreach chr, for regions > threshold: $notCov{$chr}{$start} = $end
my%notCovStarts;	#for cov-domains: foreach chr, ordered starts of regions < threshold
my$noCovStart=-1; my$noCovEnd=-1;
foreach my$threshold (@{$Thresholds_r})
	{
	foreach my$pos (sort{$a<=>$b}keys%allDepth)
		{
		if ( $allDepth{$pos} < $threshold )
			{
			if ( $pos == ($noCovEnd + 1) )
				{ 
				$notCov{$threshold}{$noCovStart} = $pos ; 
				$noCovEnd = $pos; 
				}
			else 
				{ 
				$notCov{$threshold}{$pos} = $pos ; 
				$noCovStart = $pos; 
				$noCovEnd = $pos; 
				}
			}
		}
	@{ $notCovStarts{$threshold} } = sort{$a<=>$b}keys%{ $notCov{$threshold} };
	}
return(\%allDepth,\%notCov,\%notCovStarts);
}


#########################
#for cov-line :
#create a hash : foreach file, foreach NM, foreach exon, return an array of values for ordered positions
# %NMcov: key = $file, value = %(key = $NM, value = %( key = $ex, value = @(cov foreach ordered bp of exon) ) )
sub depthLine {

my($Regions_r,$allDepth_r)=@_; 
# ${$Regions_r}{start of region} = end of region
# ${$allDepth_r}{$loc} = $cov

my%depthLine;		#@{ $depthLine{$startReg} } = [$allDepth{$posByChr[$c]}, ]
my@Pos = sort{$a<=>$b}keys%{$allDepth_r};
my@startReg = sort{$a<=>$b}keys%{$Regions_r};
my$c=0;
for (my$r=0;$r<scalar@startReg;$r++) { 
	while ( ( $startReg[$r] > $Pos[$c] ) && ( $c < (scalar@Pos -1) ) )
		{ $c++; }
	while ( ( ${$Regions_r}{$startReg[$r]} >= $Pos[$c] ) && ( $c < (scalar@Pos -1) ) ) {
		push( @{ $depthLine{$r} } , ${$allDepth_r}{$Pos[$c]} );
		$c++;
		}
	}
return(\%depthLine);

}	


########################
#for cov-domains:
#intersections not covered regions and exons 
	#starts and ends of not covered regions within exons
sub notCovDomains1 {

#@hashSub = notCovDomains1($All,$fName{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $Regions{$chr}{$gene} },\%{ $NM_Ex{$NM} },\%notCov,\%notCovStarts,\%NMnotCov);
my($All,$file2,$sName2,$outdir,$outfile,$gene,$chr,$NM,$sens,$Thresholds_r,$printThreshold,$Regions_r,$NM_Ex_r,$NMstartCod,$NMendCod,$notCov_r,$notCovStarts_r,$NMnotCov_r,$printReports) = @_;
# ${$Regions_r}{start of region} = end of region
# ${$NM_Ex_r}{start of region}{start of exon} = end of exon
# ${$notCov_r}{$threshold}{$start} = $end
# ${$notCovStarts_r}
# ${$NMnotCov_r}

my(%NMcovStart,%NMcovEnd);
#$NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
#@{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]

my$nExon=0;	#total nber of $Exons
foreach my$startR (keys%{$NM_Ex_r})
	{ $nExon+=scalar(keys%{ ${$NM_Ex_r}{$startR} }); }
my@startReg = sort{$a<=>$b}keys%{$Regions_r};

#my$txt1 = "\nsample: $sName2\ngene: $gene\ntranscript: $NM\ncoding sequence: chr $chr : $NMstartCod - $NMendCod\n";
my$txt1 = "\ngene: $gene\ntranscript: $NM\ncoding sequence: chr $chr : $NMstartCod - $NMendCod\n";
my%txt;
my($geneL,%geneUC,%NM_UC);
foreach my$threshold (@{$Thresholds_r}) {

	#$txt{$threshold} .= "\ndepth threshold = $threshold\n\n";
	my$nEx=0;	#idx of $Exons (for printing)
	my$posix=0;	#idx of $notCovStarts
	$geneUC{$threshold}=0; $geneL=0;
	for (my$r=0;$r<scalar@startReg;$r++)
		{
		my$startEx = $startReg[$r]; 
		my$endEx = ${$Regions_r}{$startReg[$r]};
		$geneL += ${$Regions_r}{$startReg[$r]}-$startReg[$r];

		unless ( scalar@{ ${$notCovStarts_r}{$threshold} } == 0 )
			{
			while ( ( $startEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]} ) && ( $posix < (scalar@{ ${$notCovStarts_r}{$threshold} }-1) ) )
				{ $posix++; }
	
			while ( ( $endEx >= ${$notCovStarts_r}{$threshold}[$posix] ) && ( $posix < (scalar@{ ${$notCovStarts_r}{$threshold} }-1) ) )
				{
				if ($startEx >= ${$notCovStarts_r}{$threshold}[$posix]) 
					{
					if ($endEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					else	#$endEx <= ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < ${$notCovStarts_r}{$chr}[$posix]
					{
					if ($endEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = $endEx; }
					else	#$end > $notCov{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					}
				$posix++;
				}
			#for last [posix]:
			if ( ($startEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}) && ($endEx >= ${$notCovStarts_r}{$threshold}[$posix]) )
				{
				if ($startEx >= ${$notCovStarts_r}{$threshold}[$posix]) 
					{
					if ($endEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					else	#$endEx <= ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < ${$notCovStarts_r}{$chr}[$posix]
					{
					if ($endEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = $endEx; }
					else	#$end > ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					}
				}
			}
		if ($printThreshold) {
			if ($sens eq "+") {
				foreach my$ex (sort{$a<=>$b}keys%{ ${$NM_Ex_r}{$startReg[$r]} }) {
					$nEx++;
					if (exists $NMcovEnd{$threshold}{$r})
						{ $txt{$threshold} .= "exon $nEx : ".$ex." - ".${$NM_Ex_r}{$startReg[$r]}{$ex}."\n"; } 
					}
				}
			else {
				foreach my$ex (sort{$a<=>$b}keys%{ ${$NM_Ex_r}{$startReg[$r]} }) {
					if (exists $NMcovEnd{$threshold}{$r}) 
						{ $txt{$threshold} .= "exon ".($nExon-$nEx)." : ".$ex." - ".${$NM_Ex_r}{$startReg[$r]}{$ex}."\n"; }
					$nEx++; 
					}
				}
			if ((exists $NMcovEnd{$threshold}{$r}) && (scalar(keys%{ ${$NM_Ex_r}{$startReg[$r]} })!=0)) {
				${$NMnotCov_r}{$NM}{$file2}{$threshold} = 1;
				$txt{$threshold} .= "\tnot covered from :\n";
				foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} })) { 
					push(@{ $NMcovStart{$threshold}{$r} }, $pos);
					$txt{$threshold} .= "\t$pos\tto\t".$NMcovEnd{$threshold}{$r}{$pos}."\n";
					$geneUC{$threshold} += $NMcovEnd{$threshold}{$r}{$pos} - $pos;
					}
				}
			}
		else {
			if ($sens eq "+") {
				foreach my$ex ( sort{$a<=>$b}keys%{ ${$NM_Ex_r}{$startReg[$r]} } ) {
					$nEx++;
					$txt{$threshold} .= "exon $nEx : ".$ex." - ".${$NM_Ex_r}{$startReg[$r]}{$ex}."\n"; 
					}
				}
			else {
				foreach my$ex ( sort{$a<=>$b}keys%{ ${$NM_Ex_r}{$startReg[$r]} } ) { 
					$txt{$threshold} .= "exon ".($nExon-$nEx)." : ".$ex." - ".${$NM_Ex_r}{$startReg[$r]}{$ex}."\n"; 
					$nEx++; 
					}
				}
			if ((exists $NMcovEnd{$threshold}{$r}) && (scalar(keys%{ ${$NM_Ex_r}{$startReg[$r]} })!=0)) {
				$txt{$threshold} .= "\tnot covered from :\n";
				foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} })) { 
					push(@{ $NMcovStart{$threshold}{$r} }, $pos);
					$txt{$threshold} .= "\t$pos\tto\t".$NMcovEnd{$threshold}{$r}{$pos}."\n";
					$geneUC{$threshold} += $NMcovEnd{$threshold}{$r}{$pos} - $pos;
					}
				}
			}
		}
	$NM_UC{$threshold} = ($geneUC{$threshold}/$geneL)*100;
	print "$gene\_$NM\t".sprintf("%.1f",$NM_UC{$threshold})."\n";
	}
if($printReports) {
	if ($printThreshold) {
		if (exists ${$NMnotCov_r}{$NM}{$file2}{$printThreshold}) {
			#open(OUT, ">$outdir/cov\_$sName2/$outfile$sName2\_$gene\_$NM.txt") || die "can't create file $outdir/$outfile$file2\_$NM.txt\n";
			open(OUT, ">>", "$outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt\n";
			print OUT $txt1;
			#foreach my$threshold (@{$Thresholds_r}) {
			#	print OUT "\ndepth threshold = $threshold\n\n";
			#	print OUT "not covered over ".sprintf("%.1f",$NM_UC{$threshold})."% of exons\n\n";
			#	if (exists $txt{$threshold}) { print OUT $txt{$threshold}; }
			#	}
			print OUT "not covered over ".sprintf("%.1f",$NM_UC{$printThreshold})."% of exons\n\n";
			if (exists $txt{$printThreshold}) { print OUT $txt{$printThreshold}; }
			close OUT;
			}
		}
	else {
		#open(OUT, ">$outdir/cov\_$sName2/$outfile$sName2\_$gene\_$NM.txt") || die "can't create file $outdir/$outfile$file2\_$NM.txt\n";
		open(OUT, ">>", "$outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt\n";
		print OUT $txt1;
		foreach my$threshold (@{$Thresholds_r}) {
			print OUT "\ndepth threshold = $threshold\n\n";
			print OUT "not covered over ".sprintf("%.1f",$NM_UC{$threshold})."% of exons:\n\n";
			print OUT $txt{$threshold};
			}
		 close OUT;
		}
	}

return(\%NMcovStart,\%NMcovEnd,\%NM_UC);

}


########################
#for cov-domains:
#intersections not covered regions and exons 
	#starts and ends of not covered regions within exons
# @hashSub = notCovDomains2(\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%notCov,\%notCovStarts);

sub notCovDomains2 {

my($Thresholds_r,$Regions_r,$notCov_r,$notCovStarts_r) = @_;
# ${$Thresholds_r}
# ${$Regions_r}{start of region} = end of region
# ${$notCov_r}{$threshold}{$start} = $end
# ${$notCovStarts_r}

my(%NMcovStart, %NMcovEnd);
#$NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
#@{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]

my@startReg = sort{$a<=>$b}keys%{$Regions_r};
foreach my$threshold (@{$Thresholds_r})
	{
	my$posix=0;	#idx of $notCovStarts
	for (my$r=0;$r<scalar@startReg;$r++)
		{
		my$startEx = $startReg[$r]; 
		my$endEx = ${$Regions_r}{$startReg[$r]}; 

		unless ( scalar@{ ${$notCovStarts_r}{$threshold} } == 0 )
			{
			while ( ( $startEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]} ) && ( $posix < (scalar@{ ${$notCovStarts_r}{$threshold} }-1) ) )
				{ $posix++; }
	
			while ( ( $endEx >= ${$notCovStarts_r}{$threshold}[$posix] ) && ( $posix < (scalar@{ ${$notCovStarts_r}{$threshold} }-1) ) )
				{
				if ($startEx >= ${$notCovStarts_r}{$threshold}[$posix]) 
					{
					if ($endEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					else	#$endEx <= ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < ${$notCovStarts_r}{$chr}[$posix]
					{
					if ($endEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = $endEx; }
					else	#$end > ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					}
				$posix++;
				}
			#for last [posix]:
			if ( ($startEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}) && ($endEx >= ${$notCovStarts_r}{$threshold}[$posix]) )
				{
				if ($startEx >= ${$notCovStarts_r}{$threshold}[$posix]) 
					{
					if ($endEx > ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					else	#$endEx <= ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < ${$notCovStarts_r}{$chr}[$posix]
					{
					if ($endEx <= ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = $endEx; }
					else	#$end > ${$notCov_r}{$chr}{${$notCovStarts_r}{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{${$notCovStarts_r}{$threshold}[$posix]} = ${$notCov_r}{$threshold}{${$notCovStarts_r}{$threshold}[$posix]}; }
					}
				}
			}
		if (exists $NMcovEnd{$threshold}{$r})
			{
			foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} }))
				{ push(@{ $NMcovStart{$threshold}{$r} }, $pos); }
			}
		}
	}
close OUT;
return(\%NMcovStart,\%NMcovEnd);

}


#########################
#transposition and splicing, for %NMcovStart and %NMcovEnd
#for $gene and $NM
#@hashSub = transposeCov(\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"coord0"}{$gene} },\%{ $NMcovStart{$gene} },\%{ $NMcovEnd{$gene} });

sub transposeCov {

my($Thresholds_r,$Regions_r,$Reg_00_r,$NMcovStart_r,$NMcovEnd_r) = @_;
# ${$Thresholds_r}
# ${$Regions_r}{start of region} = end of region
# ${$Reg_00_r}{start of region} = end of region (start of region =0)
# ${$NMcovStart_r}
# ${$NMcovEnd_r}

my(%covStart01,%covEnd01);

my@startReg = sort{$a<=>$b}keys%{$Regions_r};
my@start00 = sort{$a<=>$b}keys%{$Reg_00_r};
foreach my$threshold (@{$Thresholds_r})
	{
	my$sub = $startReg[0];
	for (my$i=0;$i<scalar(keys%{ ${$NMcovEnd_r}{$threshold}{0} });$i++)
		{ $covEnd01{$threshold}{0}{(${$NMcovStart_r}{$threshold}{0}[$i]-$sub)} = ${$NMcovEnd_r}{$threshold}{0}{${$NMcovStart_r}{$threshold}{0}[$i]}-$sub+1; }

	for (my$ex=1;$ex<scalar@startReg;$ex++)
		{
		$sub = $startReg[$ex] - $start00[$ex];
		for (my$i=0;$i<scalar(keys%{ ${$NMcovEnd_r}{$threshold}{$ex} });$i++)
			{ $covEnd01{$threshold}{$ex}{(${$NMcovStart_r}{$threshold}{$ex}[$i]-$sub)} = ${$NMcovEnd_r}{$threshold}{$ex}{${$NMcovStart_r}{$threshold}{$ex}[$i]}-$sub+1; }
		}

	for (my$ex=0;$ex<scalar@startReg;$ex++)
		{
		foreach my$pos ( sort{$a<=>$b}(keys%{ $covEnd01{$threshold}{$ex} }) )
			{  push(@{ $covStart01{$threshold}{$ex} }, $pos); }
		}
	}

return(\%covStart01,\%covEnd01);

}


#########################
# covByThreshold($threshold,\%{ $Regions{"raw"}{$chr}{$gene} },\%allDepth,\%{ $NMCov{$gene}{$threshold} });
sub covByThreshold {

my($threshold,$Regions_r,$Depth_r,$Cov_r)=@_;
# ${$Regions_r}{start of region} = end of region
# ${$Depth_r}{$loc} = $cov
# @{ ${$Cov_r}{$reg} } = [nbr of covered samples foreach pos of reg], for defined threshold
#print"for threshold $threshold, add covered positions\n";
my@Pos = sort{$a<=>$b}keys%{$Depth_r};
my@startReg = sort{$a<=>$b}keys%{$Regions_r};
my$d=0;	#index of @posByChr=keys%{ ${$Depth_r}{$chr} }
for (my$r=0;$r<scalar@startReg;$r++) {
	my$c=0;	#index of @{ $NMCov{$threshold}{$NM}{$r} }
	while ( ( $startReg[$r] > $Pos[$d] ) && ( $d < (scalar@Pos -1) ) )
		{ $d++; }
	while ( ( ${$Regions_r}{$startReg[$r]} >= $Pos[$d] ) && ( $d < (scalar@Pos -1) ) ) {
		if ((${$Depth_r}{$Pos[$d]}ne"") && (${$Depth_r}{$Pos[$d]}>=$threshold))
			{ ${$Cov_r}{$r}[$c]++; }
		$d++; $c++;
		}
	}

}


############################
#foreach NM, find max cov, among all samples
# @hashSub = maxCov(\@Files,\%{ $NMdepth{$gene} },\%{ $Regions{"coord0"}{$gene} });

sub maxCov {

my($Files_r,$NMdepth_r,$Reg_00_r) = @_;
# @{ ${$NMdepth_r}{$file}{$startReg} } = [ cov foreach ordered bp of exon ]
# ${$Reg_00_r}{start of region} = $end of region (for start of region = 0)

my$maxCovA = 0;		#for all samples
my(%maxCovS);		#for each sample
foreach my$file (@{$Files_r}) {
	my$maxD = 0;
	for (my$ex=0;$ex<scalar(keys%{$Reg_00_r});$ex++) {
		foreach my$cov (@{ ${$NMdepth_r}{$file}{$ex} }) {
			if ($cov > $maxD) { $maxD = $cov; }
			if ($cov > $maxCovA) { $maxCovA = $cov; }
			}
		}
	$maxCovS{$file} = $maxD;
	}
return($maxCovA,\%maxCovS);

}


##########################
# ReverseCov_Gene($Sum,$allS,$byS,$gene,$NMlength{$gene},\@Thresholds,\%{ $NMdepth{$gene} },\%{ $covEnd01{$gene} },\%{ $covStart01{$gene} },\%{ $NMCov{$gene} });

sub ReverseCov_Gene {

my($Sum,$allS,$byS,$gene,$length,$Thresholds_r,$NMdepth_r,$covEnd01_r,$covStart01_r,$NMcov_r) = @_;

print "reverse cov for $gene\n";

if ($allS || $byS) {		
	# @{ ${$NMdepth_r}{$file}{$startReg} } = [ cov foreach ordered bp of exon ]
	foreach my$file (keys%{$NMdepth_r}) {
		my$nEx=scalar(keys%{ ${$NMdepth_r}{$file} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ ${$NMdepth_r}{$file} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ ${$NMdepth_r}{$file}{$ex} }; }
		%{ ${$NMdepth_r}{$file} } = %tmp;
		}
	# ${$covEnd01_r}{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	# @{ ${$covStart01_r}{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	foreach my$file (keys%{$covEnd01_r}) {
		foreach my$threshold (keys%{ ${$covEnd01_r}{$file} }) {
			my%tmp;
			my$nEx=scalar(keys%{ ${$covEnd01_r}{$file}{$threshold} })-1;
			foreach my$ex (keys%{ ${$covEnd01_r}{$file}{$threshold} })
				{ %{ $tmp{($nEx-$ex)} } = reverseEx($length,\%{ ${$covEnd01_r}{$file}{$threshold}{$ex} }); }
			%{ ${$covEnd01_r}{$file}{$threshold} } = %tmp;
			foreach my$ex (keys%{ ${$covEnd01_r}{$file}{$threshold} })
				{ @{ ${$covStart01_r}{$file}{$threshold}{$ex} } = sort{$a<=>$b}keys%{ ${$covEnd01_r}{$file}{$threshold}{$ex} }; }
			}
		}
	}

if ($Sum) {
	# @{ ${$NMcov_r}{$threshold}{$NM}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
	foreach my$threshold (@{$Thresholds_r}) {
		my$nEx = scalar(keys%{ ${$NMcov_r}{$threshold} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ ${$NMcov_r}{$threshold} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ ${$NMcov_r}{$threshold}{$ex} }; }
		%{ ${$NMcov_r}{$threshold} } = %tmp;
		}
	}

}

##########################
# ReverseCov_NMs($Sum,$allS,$byS,$NM,$NMlength{$NM},\@Thresholds,\%{ $NMdepth{$NM} },\%{ $covEnd01{$NM} },\%{ $covStart01{$NM} },\%{ $NMCov{$NM} });

sub ReverseCov_NMs {

my($Sum,$allS,$byS,$NM,$length,$Thresholds_r,$NMdepth_r,$covEnd01_r,$covStart01_r,$NMCov_r) = @_;

print "reverse cov for $NM\n";

if ($allS || $byS) {		
	# @{ ${$NMdepth_r}{$file}{$startReg} } = [ cov foreach ordered bp of exon ]
	foreach my$file (keys%{$NMdepth_r}) {
		my$nEx=scalar(keys%{ ${$NMdepth_r}{$file} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ ${$NMdepth_r}{$file} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ ${$NMdepth_r}{$file}{$ex} }; }
		%{ ${$NMdepth_r}{$file} } = %tmp;
		}
	# ${$covEnd01_r}{$file}{$NM}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	# @{ ${$covStart01_r}{$file}{$NM}{$threshold}{$ex} } = [ordered $notCovStarts00]
	foreach my$file (keys%{$covEnd01_r}) {
		foreach my$threshold (keys%{ ${$covEnd01_r}{$file} }) {
			my%tmp;
			my$nEx=scalar(keys%{ ${$covEnd01_r}{$file}{$threshold} })-1;
			foreach my$ex (keys%{ ${$covEnd01_r}{$file}{$threshold} })
				{ %{ $tmp{($nEx-$ex)} } = reverseEx($length,\%{ ${$covEnd01_r}{$file}{$threshold}{$ex} }); }
			%{ ${$covEnd01_r}{$file}{$threshold} } = %tmp;
			foreach my$ex (keys%{ ${$covEnd01_r}{$file}{$threshold} })
				{ @{ ${$covStart01_r}{$file}{$threshold}{$ex} } = sort{$a<=>$b}keys%{ ${$covEnd01_r}{$file}{$threshold}{$ex} }; }
			}
		}
	}

if ($Sum) {
	# @{ ${$NMCov_r}{$threshold}{$NM}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
	foreach my$threshold (@{$Thresholds_r}) {
		my$nEx = scalar(keys%{ ${$NMCov_r}{$threshold} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ ${$NMCov_r}{$threshold} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ ${$NMCov_r}{$threshold}{$ex} }; }
		%{ ${$NMCov_r}{$threshold} } = %tmp;
		}
	}

}

##########################
sub reverseEx {
my($NMlength,$coord_r) = @_;
my(%coordRev);
foreach (keys%{$coord_r}) {
	$coordRev{($NMlength-${$coord_r}{$_})} = $NMlength-$_;
	}
return(%coordRev);
}


#################################
#merge overlapping intervals 
#%interval2 = mergeIntervals(\%interval);
sub mergeIntervals {
my($interval_r) = @_;
my@Starts = sort{$a<=>$b}(keys%{$interval_r});
my$start = $Starts[0];
my$end = ${$interval_r}{$start};
my%interval2;
for (my$i=1;$i<scalar(@Starts);$i++) {
	if ($Starts[$i] <= $end) {
		if (${$interval_r}{$Starts[$i]} > $end)
			{ $end = ${$interval_r}{$Starts[$i]}; }
		else { next; }
		}
	else {
		$interval2{$start} = $end;
		$start = $Starts[$i];
		$end = ${$interval_r}{$start};
		}
	}
$interval2{$start} = $end;
return(%interval2);
}


#####################
#@hashSub= covDomains(\@Thresholds,\%{ $Reg_00{$NM} },\%{ $NMCov{$NM} });
#$NMCovEnd{$NM}{$threshold}{$ex}{$start}=$end
#$NMCovVal{$NM}{$threshold}{$ex}{$start}=$value
sub covDomains {

my($Thresholds_r,$Reg_00_r,$NMCov_r) = @_;
# ${$Reg_00_r}{start of region} = $end of region (for start of region = 0)
# @{ ${$NMCov_r}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]

my(%NMCovEnd,%NMCovVal);
# $NMCovEnd{$threshold}{$ex}{$start}=$end
# $NMCovVal{$threshold}{$ex}{$start}=$value

my@startR = sort{$a<=>$b}keys%{$Reg_00_r};
foreach my$threshold (@{$Thresholds_r}) {
	foreach my$r (sort{$a<=>$b}(keys%{ ${$NMCov_r}{$threshold} })) {
		my$start = $startR[$r];
		my$end = $start+1; 
		my$cov = ${$NMCov_r}{$threshold}{$r}[0];
		for (my$i=1;$i<scalar@{ ${$NMCov_r}{$threshold}{$r} };$i++) {
			if (${$NMCov_r}{$threshold}{$r}[$i] == $cov)
				{ $end++; }
			else {
				$NMCovEnd{$threshold}{$r}{$start} = $end;
				$NMCovVal{$threshold}{$r}{$start} = $cov;
				$start = $startR[$r]+$i;
				$end = $start+1;
				$cov = ${$NMCov_r}{$threshold}{$r}[$i];
				}
			$NMCovEnd{$threshold}{$r}{$start} = $end;
			$NMCovVal{$threshold}{$r}{$start} = $cov;
			}
		}
	}
return(\%NMCovEnd,\%NMCovVal);

}


########################
#for $All $NM on same graph
# graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2);

sub graphAllSampleG_old {	# = all in 1 sheet, in png
my($nGraf,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$NMlength,$NMs_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$Reg_00_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r,$covStart01_r,$covEnd01_r,$NMmut00_r,$sampleName_r)= @_;

print "print CMDR graphAllSampleG: $gene\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my$nNMs = scalar@{$NMs_r};
my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$gene} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$gene}{$Starts[-1]};

if ($nGraf eq "max") { $nGraf = scalar@{$Files_r}; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$file (@{$Files_r}) {

	my($Y,$Y1,$Y2);

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
	$Y1=(0.5+0.25*$nNMs);$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$line2="";
	for(my$i=0;$i<$nNMs;$i++) { 
		$Y=(0.425+0.25*$i);
		$line2 .= line2($maxY,$Y,\%{ $intron_r->{${$NMs_r}[$i]} });
		}

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$gene} });
	my$line3b = line3a($maxY,$Y1,$Y2,\%{ $Reg_00_r->{$gene} });

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$gene} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	my$line4a="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $UTR_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
			$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{${$NMs_r}[$i]} });
			}
		}

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	my$line4b="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $Cod_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
			$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{${$NMs_r}[$i]} });
			}
		}
	
	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	my$line4c="";
	for(my$i=0;$i<$nNMs;$i++) {
		$Y=(0.3+0.25*$i);
		$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
		}
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00_r->{$gene} }) != 0) {
		$Y1=0.05;$Y2=(0.3+0.25*$nNMs);
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$gene} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=(0.3+0.25*$nNMs);
		$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$gene} });
		}

	#$line7: NM names
	my$line7 = line7($NMlength,$maxY,$NMs_r);

	#print CMDR:
	$cmdR .= 
"plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2)\n";

	$cmdR .= $line1a.$line1b;

	$cmdR .= 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
	my$col=0;
	foreach my$threshold (@{$Thresholds_r}) {
		$cmdR .= 
"abline(h=$threshold, col=\"".${$colors_r}[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

	$cmdR .= $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@{$Thresholds_r}) {
		if ($line3{$threshold}) 
			{ $cmdR .= $line3{$threshold}; }
		}
	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($i==(scalar@{$Files_r}) || $n==$nGraf) {
		open (CMDR, ">$outdir/$gene\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==scalar@{$Files_r}) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_bySample.png\", 1500, ".($nGraf*(400*(0.875+(0.125*$nNMs)))).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_bySample_$N.png\", 1500, ".($nGraf*(400*(0.875+(0.125*$nNMs)))).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_bySample_$N.png\", 1500, ".($n*(400*(0.875+(0.125*$nNMs)))).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		if ($sens eq "+") { print CMDR
"mtext(\"$gene\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		else { print CMDR 
"mtext(\"$gene\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$gene\_temp.R";
		unlink "$outdir/$gene\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}

}

########################
#for $All $NM on same graph
# graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2);

sub graphAllSampleG {		#1sample by sheet, 1 doc in pdf

my($nGraf,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$NMlength,$NMs_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$Reg_00_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r,$covStart01_r,$covEnd01_r,$NMmut00_r,$sampleName_r) = @_;

print "print CMDR graphAllSampleG: $gene\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my$nNMs = scalar@{$NMs_r};
my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$gene} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$gene}{$Starts[-1]};

open (CMDR, ">$outdir/$gene\_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "pdf(\"".$outdir."/cov_All/".$gene."_bySample.pdf\", width=11.69, height=".(4.135*(0.75+0.875+(0.125*$nNMs))/1.75).")\n";

foreach my$file (@{$Files_r}) {

	my$cmdR = "";

	my($Y,$Y1,$Y2);

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
	$Y1=(0.5+0.25*$nNMs);$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$line2="";
	for(my$i=0;$i<$nNMs;$i++) { 
		$Y=(0.425+0.25*$i);
		$line2 .= line2($maxY,$Y,\%{ $intron_r->{${$NMs_r}[$i]} });
		}

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$gene} });
	my$line3b = line3a($maxY,$Y1,$Y2,\%{ $Reg_00_r->{$gene} });

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$gene} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	my$line4a="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $UTR_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
			$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{${$NMs_r}[$i]} });
			}
		}

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	my$line4b="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $Cod_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
			$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{${$NMs_r}[$i]} });
			}
		}
	
	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	my$line4c="";
	for(my$i=0;$i<$nNMs;$i++) {
		$Y=(0.3+0.25*$i);
		$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
		}
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00_r->{$gene} }) != 0) {
		$Y1=0.05;$Y2=(0.3+0.25*$nNMs);
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$gene} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=(0.3+0.25*$nNMs);
		$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$gene} });
		}

	#$line7: NM names
	my$line7 = line7($NMlength,$maxY,$NMs_r);

	#print CMDR:
	$cmdR .= "plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"Depth\", cex.lab=1, cex.axis=0.8, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2, cex.axis=0.8)\n";

	$cmdR .= $line1a.$line1b;

	$cmdR .= "abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=1.5)\n";
	my$col=0;
	foreach my$threshold (@{$Thresholds_r}) {
		$cmdR .= "abline(h=$threshold, col=\"".${$colors_r}[$col]."\", lty = \"dotted\", lwd=1.5)\n"; 
		$col++;
		}

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

	$cmdR .= $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@{$Thresholds_r}) {
		if ($line3{$threshold}) 
			{ $cmdR .= $line3{$threshold}; }
		}
	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($sens eq "+") {
		$cmdR .= "mtext(\"$gene : chr $chr:$startReg >>> $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
		}
	else {
		$cmdR .= "mtext(\"$gene : chr $chr:$startReg <<< $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
		}
	
	print CMDR "$cmdR\n";

	}

print CMDR "dev.off();\n";
close CMDR;
system "Rscript $outdir/$gene\_temp.R";
unlink "$outdir/$gene\_temp.R";

}


########################
#graph foreach $NM 
# graphAllSampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$NM},$NMlength{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2);

sub graphAllSampleN {	#still in png, but not used anymore

my($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$NMlength,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$Reg_00_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r,$covStart01_r,$covEnd01_r,$NMmut00_r,$sampleName_r)= @_;

print "print CMDR graphAllSampleN: $gene\t$NM\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$NM} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$NM}{$Starts[-1]};

if ($nGraf eq "max") { $nGraf = scalar@{$Files_r}; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$file (@{$Files_r}) {

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	my$Y1=0.75;my$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$NM} },\%{ $NMdepth_r->{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$Y=0.425;
	my$line2 = line2($maxY,$Y,\%{ $intron_r->{$NM} });

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$NM} });	#empty black squares
	my$line3b = line3a($maxY,$Y1,$Y2,\%{ $Reg_00_r->{$NM} });	#full green squares

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$NM} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%{ $UTR_r->{$NM} }) != 0) { $line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{$NM} }); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%{ $Cod_r->{$NM} }) != 0) { $line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{$NM} }); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00_r->{$NM} });
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00_r->{$NM} }) != 0) {
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$NM} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.55;
		$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$NM} });
		}

	#print CMDR:
	$cmdR .= 
"plot (c(0,0), xlim=c(0,".$NMlength."), ylim=c(-".(0.75*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5),labels=seq(0, $maxY, length = 5), las=2)\n";

	$cmdR .= $line1a.$line1b;

	$cmdR .= 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
	my$col=0;
	foreach my$threshold (@{$Thresholds_r}) {
		$cmdR .= 
"abline(h=$threshold, col=\"".${$colors_r}[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	$cmdR .= $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@{$Thresholds_r}) {
		if ($line3{$threshold}) 
			{ $cmdR .= $line3{$threshold}; }
		}
	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	

	if ($i==(scalar@{$Files_r}) || $n==$nGraf) {
		open (CMDR, ">$outdir/$NM\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==scalar@{$Files_r}) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample_$N.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample_$N.png\", 1500, ".($n*400).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		if ($sens eq "+") { print CMDR 
"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		else { print CMDR 
"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$NM\_temp.R";
		unlink "$outdir/$NM\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}

}


########################
#for $All $NM on same graph
# graphBySampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$gene},$maxCovS{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2);

sub graphBySampleG {

my($nGraf,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$NMlength,$maxCov_r,$NMs_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$Reg_00_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r,$covStart01_r,$covEnd01_r,$NMmut00_r,$sampleName_r)= @_;

my$nNMs = scalar@{$NMs_r};
my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$gene} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$gene}{$Starts[-1]};

foreach my$file (@{$Files_r}) {

	print "print CMDR graphBySampleG: $gene\n";
	open (CMDR, ">$outdir/$gene\_temp.R") || die;
	print CMDR "#!/usr/bin/env Rscript\n\n" ;
	#print CMDR "png(\"$outdir/cov\_".${$sampleName_r}{$file}."/$gene\_".${$sampleName_r}{$file}.".png\", 1500, ".(400*(0.875+(0.125*$nNMs))).")\n";
	print CMDR "pdf(\"$outdir/cov\_".${$sampleName_r}{$file}."/$gene\_".${$sampleName_r}{$file}.".pdf\", width=11.69, height=".(4.135*(0.75+0.875+(0.125*$nNMs))/1.75).")\n";

	my$maxY = $maxCov_r->{$file};
	unless ($maxD) {
		if ($maxY<10) { $maxY = 10; }
		}

	my($Y,$Y1,$Y2);
	#$line1: cmdR for plot depth line
	#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
	$Y1=(0.5+0.25*$nNMs);$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$line2="";
	for(my$i=0;$i<$nNMs;$i++) { 
		$Y=(0.425+0.25*$i);
		$line2 .= line2($maxY,$Y,\%{ $intron_r->{${$NMs_r}[$i]} });
		}

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$gene} });
	my$line3b = line3a($maxY,$Y1,$Y2,\%{ $Reg_00_r->{$gene} });

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$gene} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	my$line4a="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $UTR_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
			$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{${$NMs_r}[$i]} });
			}
		}

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	my$line4b="";
	for(my$i=0;$i<$nNMs;$i++) {
		if (scalar(keys%{ $Cod_r->{${$NMs_r}[$i]} }) != 0) {
			$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
			$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{${$NMs_r}[$i]} });
			}
		}
	
	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	my$line4c="";
	for(my$i=0;$i<$nNMs;$i++) {
		$Y=(0.3+0.25*$i);
		$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
		}
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00_r->{$gene} }) != 0) {
		$Y1=0.05;$Y2=(0.3+0.25*$nNMs);
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$gene} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=(0.3+0.25*$nNMs);
		$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$gene} });
		}

	#$line7: NM names
	my$line7 = line7($NMlength,$maxY,$NMs_r);

	#print CMDR:
	print CMDR "plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"depth\", cex.lab=1, cex.axis=0.8, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5),labels=seq(0, $maxY, length = 5), las=2, cex.axis=0.8)\n";
	#png:"plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
#axis(2, at=seq(0, $maxY, length = 5),labels=seq(0, $maxY, length = 5), las=2, cex.axis=1.2)\n";

	print CMDR $line1a.$line1b;

	print CMDR "abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=1.5)\n";
	my$col=0;
	foreach my$threshold (@{$Thresholds_r}) {
		print CMDR "abline(h=$threshold, col=\"".${$colors_r}[$col]."\", lty = \"dotted\", lwd=1.5)\n"; 
		$col++;
		}

	print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

	print CMDR $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@{$Thresholds_r}) {
		if ($line3{$threshold}) 
			{ print CMDR $line3{$threshold}; }
		}
	print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($sens eq "+") {
		#png: print CMDR "mtext(\"$gene\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		print CMDR "mtext(\"$gene : chr $chr:$startReg >>> $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
		}
	else {
		#png: print CMDR "mtext(\"$gene\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		print CMDR "mtext(\"$gene : chr $chr:$startReg <<< $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
		}

	print CMDR "dev.off();\n";
	close CMDR;
	system "Rscript $outdir/$gene\_temp.R";
	unlink "$outdir/$gene\_temp.R";
	}

}


########################
#graph foreach $NM
# graphBySampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$NM},$maxCovS{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2);

sub graphBySampleN {	#still in png, but not used anymore

my($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$NMlength,$maxCov_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$Reg_00_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r,$covStart01_r,$covEnd01_r,$NMmut00_r,$sampleName_r)= @_;

my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$NM} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$NM}{$Starts[-1]};

foreach my$file (@{$Files_r}) {

	print "print CMDR graphBySampleN: $gene\t$NM\n";
	open (CMDR, ">$outdir/$NM\_temp.R") || die;
	print CMDR "#!/usr/bin/env Rscript\n\n" ;
	print CMDR 
	"png(\"$outdir/cov\_".${$sampleName_r}{$file}."/$gene\_$NM\_".${$sampleName_r}{$file}.".png\", 1500, 400)\n"; 

	my$maxY = $maxCov_r->{$file};
	unless ($maxD) {
		if ($maxY<10) { $maxY = 10; }
		}

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	my$Y1=0.75;my$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$NM} },\%{ $NMdepth_r->{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
	my$Y=0.425;
	my$line2 = line2($maxY,$Y,\%{ $intron_r->{$NM} });

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$NM} });	#empty black squares
	my$line3b = line3a($maxY,$Y1,$Y2,\%{ $Reg_00_r->{$NM} });	#full green squares

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$NM} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%{ $UTR_r->{$NM} }) !=0 ) { $line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{$NM} }); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%{ $Cod_r->{$NM} }) !=0 ) { $line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{$NM} }); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00_r->{$NM} });
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00_r->{$NM} }) != 0) {
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$NM} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.55;
		$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$NM} });
		}

	#print CMDR:
	print CMDR 
"plot (c(0,0), xlim=c(0,".$NMlength."), ylim=c(-".(0.75*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2)\n";

	print CMDR $line1a.$line1b;


	print CMDR 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n"; 
	my$col=0;
	foreach my$threshold (@{$Thresholds_r}) {
		print CMDR 
"abline(h=$threshold, col=\"".${$colors_r}[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	print CMDR $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@{$Thresholds_r}) {
		if ($line3{$threshold}) 
			{ print CMDR $line3{$threshold}; }
		}
	print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($sens eq "+") {
		print CMDR 
	"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	else {
		print CMDR 
	"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	print CMDR "dev.off();\n";
	close CMDR;
	system "Rscript $outdir/$NM\_temp.R";
	unlink "$outdir/$NM\_temp.R";
	}

}


############################
#$line1: cmdR for plot cov line
#@{ $NMdepth{$NM}{$file}{$ex} } = [ cov foreach ordered bp of exon ]
#my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });

sub line1 {
my($maxY,$NMlength,$Y1,$Y2,$Reg_00_r,$NMdepth_r) = @_;
my@startR = sort{$a<=>$b}keys%{$Reg_00_r};
my$line1a="";my$line1b="";
my$p = 0; my$i = 0;
for (my$n=0;$n<scalar@startR;$n++) {
	$line1a .= "par(new=TRUE)\nplot( c(";
	$p=$startR[$n]; $i=0;
	while ($i < scalar@{ ${$NMdepth_r}{$n} })
		{ $line1a .= $p.","; $p++; $i++; }
	chop $line1a;
	$line1a .= "), c(";
	$p=$startR[$n]; $i=0;
	while ($i < scalar@{ ${$NMdepth_r}{$n} }) {
		if (${$NMdepth_r}{$n}[$i] eq "") { 
			$line1a .= "0,";
# png: 			$line1b .= "lines (c($p,".($p+1)."), c(0,0), lwd=2, col=\"grey\")\n";
# pdf:
 				$line1b .= "lines (c($p,".($p+1)."), c(0,0), lwd=1.5, col=\"grey\")\n";
			}
		else { $line1a .= ${$NMdepth_r}{$n}[$i].","; }
		$p++; $i++;
		}
	chop $line1a;
# png:	$line1a .= "), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".($Y1*$maxY).",".($Y2*$maxY)."), type =\"l\", lwd=2, col=\"black\", axes=FALSE, ann=FALSE)\n";
# pdf:
		$line1a .= "), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".($Y1*$maxY).",".($Y2*$maxY)."), type =\"l\", lwd=1.5, col=\"black\", axes=FALSE, ann=FALSE)\n";
	}
return($line1a,$line1b);
}

###########################
#$line2: cmdR for cmdR for lines(intron)
#$line2 .= line2($maxY,$Y,\%{ ${$intron_r}{${$NMs_r}[$i]} });
#${$intron_r}{$startInt} = $endInt;
sub line2 {
my($maxY,$Y,$intron_r) = @_;
my$line="";
my@startIntron = sort{$a<=>$b}keys%{$intron_r}; 
for (my$ex=0;$ex<scalar@startIntron;$ex++) {
	$line .= "lines (c(".$startIntron[$ex].",".${$intron_r}{$startIntron[$ex]}."),c(-".($Y*$maxY).",-".($Y*$maxY)."), lwd=3)\n";
	}
return($line);
}

###########################
#cmdR for rect(bed) empty
#$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);	#empty black squares
#$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);	#full green squares
#${$NMbed00_r}{$startBed00} = $endBed00 (start of Region=0 )
sub line3a {
my($maxY,$Y1,$Y2,$NMbed00_r) = @_;
my@startBed = sort{$a<=>$b}keys%{$NMbed00_r};
my$line = "rect (c(";
foreach my$start (@startBed)
	{ $line .= $start.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(@startBed);$i++)
	{ $line .= "-".($Y1*$maxY).","; }			
chop $line;
$line .= "), c(";
foreach my$start (@startBed)
	{ $line .= ${$NMbed00_r}{$start}.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(@startBed);$i++)
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
$line .= "),";
return($line);
}

##########################
#$line3: cmdR for rect(not covered domains)
#$covEnd01{$file}{$NM}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
#@{ $covStart01{$file}{$NM}{$threshold}{$ex} } = [ordered $notCovStarts00]
#my%line3 = line3($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,scalar(keys%{ $Reg_00_r->{$gene} }),\%{ $covStart01_r->{$file} },\%{ $covEnd01_r->{$file} });
sub line3 {
my($maxY,$Y1,$Y2,$Thresholds_r,$colors_r,$N_Reg,$covStart01_r,$covEnd01_r) = @_;
my$col=0;
my%line;
foreach my$threshold (@{$Thresholds_r}) {
	my$ok=0;
	for (my$ex=0;$ex<$N_Reg;$ex++) {
		if ( scalar(keys(%{ ${$covEnd01_r}{$threshold}{$ex} })) != 0) 
			{ $ok = 1; last; } 
		}
	if ($ok) {
		$line{$threshold} = "rect (c(";
		for (my$ex=0;$ex<$N_Reg;$ex++) {			
			foreach my$pos (@{ ${$covStart01_r}{$threshold}{$ex} })
				{ $line{$threshold} .= $pos.","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<$N_Reg;$ex++) {			
			for (my$i=0;$i<scalar@{ ${$covStart01_r}{$threshold}{$ex} };$i++)
				{ $line{$threshold} .= "-".($Y1*$maxY).","; }
			}			
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<$N_Reg;$ex++) {
			foreach my$pos (@{ ${$covStart01_r}{$threshold}{$ex} })
				{ $line{$threshold} .= ${$covEnd01_r}{$threshold}{$ex}{$pos}.","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<$N_Reg;$ex++) {
			for (my$i=0;$i<scalar@{ ${$covStart01_r}{$threshold}{$ex} };$i++)
				{ $line{$threshold} .= "-".($Y2*$maxY).","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), lwd=0.01, col=\"".${$colors_r}[$col]."\", border =\"".${$colors_r}[$col]."\")\n";
		}
	$col++;
	}
return(%line);
}

#############################
#$line4a: cmdR for cmdR for rect(UTR exons)
#$line4a .= line4a($maxY,$Y1,$Y2,\%{ ${$UTR_r}{${$NMs_r}[$i]} });	
#${$UTR_r}{$startUTR} = $endUTR;
sub line4a {
my($maxY,$Y1,$Y2,$UTR_r) = @_;
my@startUTR = sort{$a<=>$b}keys%{$UTR_r};
my$line = "rect (c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= $startUTR[$ex].","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= "-".($Y1*$maxY).","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= ${$UTR_r}{$startUTR[$ex]}.","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
#png: $line .= "), lwd=2, col=\"blue\")\n";
#pdf:
$line .= "), lwd=1.5, col=\"blue\")\n";
return($line);
}

##########################
#$line4b: cmdR for rect(coding exons)
#$line4b .= line4b($maxY,$Y1,$Y2,\%{ ${$Cod_r}{${$NMs_r}[$i]} });	
#${$Cod_r}{$startCod} = $endCod;
sub line4b {
my($maxY,$Y1,$Y2,$Cod_r) = @_;
my@startCod = sort{$a<=>$b}keys%{$Cod_r};
my$line = "rect (c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= $startCod[$ex].","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= "-".($Y1*$maxY).","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= ${$Cod_r}{$startCod[$ex]}.","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
#png: $line .= "), lwd=2, col=\"blue\")\n";
#pdf:
$line .= "), lwd=1.5, col=\"blue\")\n";
return($line);
}

###########################
#$line4c: text Nb exon
#$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
#${$NM_Ex00_r}{start of region}{start of exon} = end of exon (for start of region = 0)
sub line4c {
my($sens,$Rev,$maxY,$Y,$NM_Ex00_r) = @_;
my$line = "text( c(";
foreach my$startR (sort{$a<=>$b}keys%{$NM_Ex00_r}) {
	foreach my$startBed (sort{$a<=>$b}keys%{ ${$NM_Ex00_r}{$startR} })
		{ $line .= ((${$NM_Ex00_r}{$startR}{$startBed}+$startBed)/2).","; }
	}
chop $line;
$line .= "), c(";
my$nEx=0;
foreach my$startR (keys%{$NM_Ex00_r}) {
	for (my$i=0;$i<scalar(keys%{ ${$NM_Ex00_r}{$startR} });$i++)
		{ $line .= "-".($Y*$maxY).","; $nEx++; }
	}		
chop $line;
$line .= "), c(";
my$i=1;
if ($Rev) {
	foreach my$startR (keys%{$NM_Ex00_r}) {
		while ($i<=$nEx)
			{ $line .= "\"$i\" ,"; $i++; }
		}			
	}
else {
	if ($sens eq "-") {
		$i=$nEx;
		foreach my$startR (keys%{$NM_Ex00_r}) {
			while ($i>0)
				{ $line .= "\"$i\" ,"; $i--; }
			}			
		}
	}
chop $line;
## png: $line .= "), cex = 1)\n";
##pdf:
$line .= "), cex = 0.66)\n";
return($line);
}

##########################
#$line5: cmdR for legends
#my$line5 = line5a($comp,$colors_r,$Thresholds_r);
sub line5a {
my($comp,$colors_r,$Thresholds_r) = @_;
my$line = "legend(\"topright\", legend = c(\">=".${$Thresholds_r}[0]."\",";
foreach my$threshold (@{$Thresholds_r})
	{ $line .="\"$comp$threshold\","; }
chop $line;
$line .= "), col = c(\"green\",";
for (my$i=0;$i<scalar(@{$Thresholds_r});$i++)
	{ $line .="\"".${$colors_r}[$i]."\","; }
chop $line;
# png: $line .= "), pch = 15, bty = \"n\", pt.cex = 2.5, cex = 1, horiz = TRUE, inset = c(0, 0))\n";
# pdf:
$line .= "), pch = 15, bty = \"n\", pt.cex = 2, cex = 0.75, horiz = TRUE, inset = c(0, 0))\n";
return($line);
}

##########################
#$line5: cmdR for legends
sub line5b {
my($comp,$colors_r,$Thresholds_r) = @_;
my$line = "legend(\"topright\", legend = c(";
foreach my$threshold (@{$Thresholds_r})
	{ $line .="\"$comp$threshold\","; }
chop $line;
$line .= "), col = c(";
for (my$i=0;$i<scalar(@{$Thresholds_r});$i++)
	{ $line .="\"".${$colors_r}[$i]."\","; }
chop $line;
# png: $line .= "), pch = 15, bty = \"n\", pt.cex = 2.5, cex = 1, horiz = TRUE, inset = c(0, 0))\n";
# pdf:
$line .= "), pch = 15, bty = \"n\", pt.cex = 2, cex = 0.75, horiz = TRUE, inset = c(0, 0))\n";
return($line);
}

#############################
#$line6: cmdR for mutations (symbol)
#$line6a = line6a($maxY,$Y1,$Y2,$NMmut00_r);
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
sub line6a {
my($maxY,$Y1,$Y2,$NMmut00_r) = @_;
my$line="";
#above
$line .= "points(c(";
foreach my$mut (keys%{$NMmut00_r})
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%{$NMmut00_r});$i++)
	{ $line .= "-".($Y1*$maxY).","; }			
chop $line;
#png: $line .= "), pch = 6, col = \"black\", lwd = 2, cex = 1)\n";
#pdf:
$line .= "), pch = 6, col = \"black\", lwd = 1.5, cex = 0.75)\n";
#below
$line .= "points(c(";
foreach my$mut (keys%{$NMmut00_r})
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%{$NMmut00_r});$i++)
	{ $line .= "-".($Y2*$maxY).","; }			
chop $line;
#png: $line .= "), pch = 2, col = \"black\", lwd = 2, cex = 1)\n";
#pdf:
$line .= "), pch = 2, col = \"black\", lwd = 1.5, cex = 0.75)\n";
return($line);
}

##############################
#$line6b: cmdR for mutations (text)
#$line6b = line6b($maxY,$Y,$NMmut00_r);
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
sub line6b {
my($maxY,$Y,$NMmut00_r) = @_;
my$line="";
$line = "text( c(";
foreach my$mut (keys%{$NMmut00_r})
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%{$NMmut00_r});$i++)
	{ $line .= "-".($Y*$maxY).","; }			
chop $line;
$line .= "), c(";
foreach my$mut (keys%{$NMmut00_r})
	{ $line .= "\"".${$NMmut00_r}{$mut}."\" ,"; }			
chop $line;
#png: $line .= "), adj = c(0.5,1.75), cex = 1.25, srt = -15)\n";
#pdf:
$line .= "), adj = c(0.5,1.75), cex = 1, srt = -15)\n";
#$line .= "), pos = 1, cex = 1)\n";
#$line .= "), cex = 1)\n";
return($line);
}

##############################
#$line7: cmdR for text NM
#my$line7 = line7($length,$maxY,$NMs_r);
sub line7 {
my($NMlength,$maxY,$NMs_r) = @_;
my$line="";
$line = "text( c(";
for (my$i=0;$i<scalar@{$NMs_r};$i++)
	{ $line .= "-".(0.6*$NMlength/10).","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar@{$NMs_r};$i++)
	{ $line .= "-".((0.425+0.25*$i)*$maxY).","; }		
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar@{$NMs_r};$i++)
	{ $line .= "\"".${$NMs_r}[$i]."\" ,"; }			
chop $line;
#$line .= "), adj = c(0,2), cex = 1)\n";
## png: $line .= "), cex = 1.2)\n";
##pdf:
$line .= "), cex = 0.75)\n";
return($line);
}


##############################
#graph with all transcripts of a gene
# graphSumG($nGraf,$gene,$suff,$outdir,$sens,$chr,$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},$NMCovEnd{$gene},$NMCovVal{$gene});

sub graphSumG {

my($nGraf,$gene,$suff,$outdir,$sens,$chr,$length,$NMs_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMmut00_r,$NMCovEnd_r,$NMCovVal_r) = @_;

print "print CMDR graphSumG: $gene\n";
open (CMDR, ">$outdir/$gene\_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
my$nNMs=scalar(@{$NMs_r});
my$maxY=scalar(@{$Files_r});
my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$gene} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$gene}{$Starts[-1]};

print CMDR "pdf(\"".$outdir."/cov_All/".$gene."_covSum.pdf\", width=11.69, height=".(4.135*(0.75+0.875+(0.125*$nNMs))/1.75).")\n";

if ($sens eq "+")
	{ print CMDR 
#png: "plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr\t$startReg >>> $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
#axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2)\n";
#pdf:
"plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr: $startReg >>> $endReg\", ylab = \"nber of covered samples\", cex.lab=1, cex.axis=0.8, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2, cex.axis=0.8)\n";
	}
else
	{ print CMDR 
#png: "plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr\t$startReg <<< $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
#axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2)\n";
#pdf:
"plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr: $startReg <<< $endReg\", ylab = \"nber of covered samples\", cex.lab=1, cex.axis=0.8, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2, cex.axis=0.8)\n";
	}

my($Y,$Y1,$Y2);
#$line1
#$NMCovEnd{$threshold}{$r}{$start}=$end
#$NMCovVal{$threshold}{$r}{$start}=$value
my$col=0;
my%line1;
#$line1: cmdR for plot cov line
foreach my$threshold (@{$Thresholds_r}) {
	$line1{$threshold} = line1g2(${$colors_r}[$col],\%{ ${$NMCovEnd_r}{$threshold} },\%{ ${$NMCovVal_r}{$threshold} });
	$col++;
	}

#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
my$line2="";
for(my$i=0;$i<$nNMs;$i++) { 
	$Y=(0.425+0.25*$i);
	$line2 .= line2($maxY,$Y,\%{ ${$intron_r}{${$NMs_r}[$i]} });
	}

#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
$Y1=0.1;$Y2=0.25;
my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$gene} });			#\%{ ${$NMbed00_r}{$gene} }	${$NMbed00_r}{$gene}

#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
my$line4a="";
for(my$i=0;$i<$nNMs;$i++) {
	if (scalar(keys%{ ${$UTR_r}{${$NMs_r}[$i]} }) != 0) {
		$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
		$line4a .= line4a($maxY,$Y1,$Y2,\%{ ${$UTR_r}{${$NMs_r}[$i]} });
		}
	}

#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
my$line4b="";
for(my$i=0;$i<$nNMs;$i++) {
	if (scalar(keys%{ ${$Cod_r}{${$NMs_r}[$i]} }) != 0) {
		$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
		$line4b .= line4b($maxY,$Y1,$Y2,\%{ ${$Cod_r}{${$NMs_r}[$i]} });
		}
	}

#$line4c: Nb exon
#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my$line4c="";
for(my$i=0;$i<$nNMs;$i++) {
	$Y=(0.3+0.25*$i);
	$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
	}

#$line5: cmdR for legends
my$comp = ">=";
my$line5 = line5b($comp,$colors_r,$Thresholds_r);

#$line6: cmdR for mutations (symbol)
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
my$line6a = ""; my$line6b = "";
if (scalar(keys%{ $NMmut00_r->{$gene} }) != 0) {
	$Y1=0.05;$Y2=(0.3+0.25*$nNMs);
	$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00_r->{$gene} });
	#$line6b: cmdR for mutations (text)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	$Y=(0.3+0.25*$nNMs);
	$line6b = line6b($maxY,$Y,\%{ $NMmut00_r->{$gene} });
	}

#$line7: NM names
my$line7 = line7($length,$maxY,$NMs_r);

print CMDR "abline(h=0, col=\"black\", lty = \"dotted\", lwd=1)\n"; 
print CMDR "abline(h=$maxY, col=\"darkgrey\", lty = \"dotted\", lwd=1)\n"; 

foreach my$threshold (reverse@{$Thresholds_r})
	{ print CMDR $line1{$threshold}; }

print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";


#png: print CMDR "mtext(\"$gene\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
#pdf:
print CMDR "mtext(\"$gene\", side = 3, outer=TRUE, line=-3, cex=1)\n";
print CMDR "dev.off();\n";
close CMDR;
system "Rscript $outdir/$gene\_temp.R";
unlink "$outdir/$gene\_temp.R";

}


##############################
#graph foreach transcript of a gene
#graphSumN($nGraf,$gene,$suff,$outdir,$sens,$chr,\%NMlength,\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},\%NMCovEnd,\%NMCovVal);

sub graphSumN {	#still in png, but not used anymore

my($nGraf,$gene,$suff,$outdir,$sens,$chr,$lengths_r,$NMs_r,$Files_r,$colors_r,$Thresholds_r,$Regions_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMmut00_r,$NMCovEnd_r,$NMCovVal_r)= @_;

print "print CMDR graphSumN: $gene\n";

my$nNM=scalar@{$NMs_r};
my$maxY=scalar(@{$Files_r});
if ($nGraf eq "max") { $nGraf = $nNM; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$NM (sort(@{$NMs_r})) {
	my@Starts = sort{$a<=>$b}(keys%{ ${$Regions_r}{$chr}{$NM} });
	my$startReg = $Starts[0];
	my$endReg = ${$Regions_r}{$chr}{$NM}{$Starts[-1]};

	if ($sens eq "+") {
		$cmdR .= 
"plot (c(0,0), xlim=c(0,".${$lengths_r}{$NM}."), ylim=c(-".(0.6*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"transcript : $NM\t\tchr $chr\t$startReg >>> $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2), labels=seq(0, $maxY, length = 2), las=2)\n";
		}
	else
		{ $cmdR .= 
"plot (c(0,0), xlim=c(0,".${$lengths_r}{$NM}."), ylim=c(-".(0.6*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"transcript : $NM\t\tchr $chr\t$startReg <<< $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2), labels=seq(0, $maxY, length = 2), las=2)\n";
		}

	#$line1: cmdR for plot cov line
	#$NMCovEnd{$threshold}{$r}{$start}=$end
	#$NMCovVal{$threshold}{$r}{$start}=$value
	my$col=0;my($Y,$Y1,$Y2);
	my%line1;
	foreach my$threshold (@{$Thresholds_r}) {
		$line1{$threshold} = line1g2(${$colors_r}[$col],\%{ ${$NMCovEnd_r}{$NM}{$threshold} },\%{ ${$NMCovVal_r}{$NM}{$threshold} });
		$col++;
		}

	#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
	$Y=0.425;
	my$line2 = line2($maxY,$Y,\%{ ${$intron_r}{$NM} });

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$NM} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%{ ${$UTR_r}{$NM} }) != 0 ) { $line4a .= line4a($maxY,$Y1,$Y2,\%{ ${$UTR_r}{$NM} }); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%{ ${$Cod_r}{$NM} }) != 0) { $line4b .= line4b($maxY,$Y1,$Y2,\%{ ${$Cod_r}{$NM} }); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{$NM} });

	#$line5: cmdR for legends
	my$comp = ">=";
	my$line5 = line5b($comp,$colors_r,$Thresholds_r);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ ${$NMmut00_r}{$NM} }) != 0) {
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%{ ${$NMmut00_r}{$NM} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.5;
		$line6b = line6b($maxY,$Y,\%{ ${$NMmut00_r}{$NM} });
		}
	
	$cmdR .= "abline(h=0, col=\"black\", lty = \"dotted\", lwd=1)\n";
	$cmdR .= "abline(h=$maxY, col=\"darkgrey\", lty = \"dotted\", lwd=1)\n"; 

	foreach my$threshold (reverse@{$Thresholds_r})
		{ $cmdR .= $line1{$threshold}; }

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	

	if ($i==($nNM) || $n==$nGraf) {

		open (CMDR, ">$outdir/$gene\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==$nNM) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_covSum.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_covSum_$N.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_covSum_$N.png\", 1500, ".($n*400).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		print CMDR "mtext(\"$gene\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$gene\_temp.R";
		unlink "$outdir/$gene\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}
}


###############################
#graph line (disabled)
sub line1g {

my($NM,$maxY,$Y1,$Y2,$NMlength,$color,$h1,$h2) = @_;
my%Reg_00=%$h1;
my%NMCov=%$h2;
my@startR = sort{$a<=>$b}keys%Reg_00;
my$line="";
for (my$n=0;$n<scalar@startR;$n++)
	{
	$line .= "par(new=TRUE)\nplot( c(";
	my$p=$startR[$n]; my$i=0;
	while ($i<scalar@{ $NMCov{$n} })
		{ $line .= $p.","; $p++; $i++; }
	chop $line;
	$line .= "), c(";
	$i=0;
	while ($i<scalar@{ $NMCov{$n} })
		{ $line .= $NMCov{$n}[$i].","; $i++; }
	chop $line;
	$line .= "), xlim=c(0,".$NMlength."), ylim=c(-".($Y1*$maxY).",".($Y2*$maxY)."), type =\"l\", lwd=2, col=\"$color\", axes=FALSE, ann=FALSE)\n";
	}
return($line);

}
####################################
#same but graph rect
sub line1g2 {
my($color,$NMCovEnd_r,$NMCovVal_r) = @_;

#$NMCovEnd{$NM}{$ex}{$start}=$end
#$NMCovVal{$NM}{$ex}{$start}=$value
my@startR = sort{$a<=>$b}keys%{$NMCovEnd_r};
my$line = "";
for (my$r=0;$r<scalar@startR;$r++) {
	my@Starts= sort{$a<=>$b}keys%{ ${$NMCovEnd_r}{$startR[$r]} };
	$line .= "rect (c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= $Starts[$i].","; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= "0,"; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= ${$NMCovEnd_r}{$startR[$r]}{$Starts[$i]}.","; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= ${$NMCovVal_r}{$startR[$r]}{$Starts[$i]}.","; }
	chop $line;
	$line .= "), border=NA, col=\"$color\")\n";
	}
return($line);

}


############################
#	if (!$bedFile || $jobs{"genePlot"}) 
#		{ %withChr = covPlot($bin,$maxPl,"all_Genes_Regions",\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,$coordBed_r); }
#	if ($bedFile) 
#		{ %withChr = covPlot($bin,$maxPl,$bedName,\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,$Bed_r); }

sub covPlot {

my($bin,$max2,$outName,$h1,$extenS,$h2,$h3,$h4,$outdir,$allInterval_r)=@_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName2 = %$h4;

open(OUT1, ">$outdir/covPlot/$outName\_binCovPlot.txt") || die "can't create $outdir/covPlot/$outName\_binCovPlot.txt\n";
open(OUT2, ">$outdir/covPlot/$outName\_sumCovPlot.txt") || die "can't create $outdir/covPlot/$outName\_sumCovPlot.txt\n";

print OUT1 "depth\t";
print OUT2 "depth\t";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	print OUT1 ($bin*$i)."-".(($bin*($i+1))-1)."\t";
	print OUT2 ">".($bin*$i)."\t";
	$i++;
	}
print OUT1 ">=$max2\n";
print OUT2 "\n";

my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}

my($hist_r,$lengthBed);

foreach my$file (@Files) {

	print "analysing ".$sName2{$file}." for plot on $outName\n";
	if ($gatk) {
		print "intersect $outdir/all.cov with $outName for histPlot\n";
		my@hashSub = intersectForHist($gatkIdx{$file},"$outdir/all.cov",$maxPl,$allInterval_r,$gatk);
		$lengthBed = $hashSub[0];
		$hist_r = $hashSub[1];
		}
	else {
		print "intersect $outdir/$fName{$file}.cov with $outName for histPlot\n";
		my@hashSub = intersectForHist($fName{$file},"$outdir/$fName{$file}.cov",$maxPl,$allInterval_r,$gatk);
		$lengthBed = $hashSub[0];
		$hist_r = $hashSub[1];
		}

	print OUT1 "sample_$sName2{$file}\t";
	my$histCount;
	my$i=0;
	while ( ($i*$bin) <= $max2 ) {
		$histCount=0;
		for (my$j=($bin*$i);$j<($bin*($i+1));$j++)
			{ if (exists${$hist_r}{$j}) { $histCount += ${$hist_r}{$j}; } }
		print OUT1 $histCount."\t";
		$i++;
		}
	my@array=sort{$a<=>$b}keys%{$hist_r};
	$histCount=0;
	for ($i=$max2;$i<=$#array;$i++)
		{ $histCount += ${$hist_r}{$array[$i]}; }
	print OUT1 $histCount."\n";

	print OUT2 "sample_$sName2{$file}\t";
	my$totCount=0;
	if (exists ${$hist_r}{0}) { $totCount += ${$hist_r}{0}; }
	print OUT2 (1-$totCount)."\t";
	$i=0;
	while ( ($i*$bin) < $max2 ) {
		$histCount=0;
		for (my$j=(($bin*$i)+1);$j<=($bin*($i+1));$j++)
			{ if (exists ${$hist_r}{$j}) { $histCount += ${$hist_r}{$j}; } }
		$totCount += $histCount;
		print OUT2 (1-$totCount)."\t";
		$i++;
		}
	print OUT2 "\n";
	}
close(OUT1); 
close(OUT2);
#R barplot -sum, mean of all samples
if (scalar@Files>1)
	{ meanCovPlot($bin,$max2,$outdir,$outName,$lengthBed); }
#R barplot -sum, 1graph / sample
allCovPlot($bin,$max2,$outdir,$outName,$lengthBed,\@Files,\%sName2,$extenS);

return(%withChr);

}

##
#if ($gatk) { my@hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxPl,\%allInterval,$gatk); }
#else { my@hashSub = intersect($fName{$file},"$outdir/$file.cov",$maxPl,\%allInterval,$gatk); }

sub intersectForHist {

my($file,$covName,$maxPl,$Intervals_r,$gatk) = @_;

my$lengthBed=0;
my%allDepth;		#for hist depth : $allDepth{depth value} = nber pos with this depth

my$c=0;			#idx of $startByChr
my$chr = "";
my(%allChr,@Starts);
foreach (keys%{$Intervals_r}) { $allChr{$_} = 1; }

if ($gatk) {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		my@tab2 = split(/:/,$tab[0]);
		if ($chr ne $tab2[0]) {
			if (exists $allChr{$tab2[0]}) {
				$chr = $tab2[0];
				@Starts = sort{$a<=>$b}(keys%{ ${$Intervals_r}{$chr} });
				$c=0;
				}
			else { next; }
			}
		while ( ($tab2[1] > ${$Intervals_r}{$chr}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
			{ $c++; }
		if ( ($tab2[1] >= $Starts[$c]) && ($tab2[1] <= ${$Intervals_r}{$chr}{$Starts[$c]}) ) {
			$lengthBed++;
			my$cov = $tab[$file];
			if ($maxPl) { if ($cov > $maxPl) { $cov = ($maxPl+1); } }
			$allDepth{$cov}++; 
			}
		if ( $tab2[1] > ${$Intervals_r}{$chr}{$Starts[-1]} ) {
			my%tmp;
			foreach (keys%allChr) { 
				unless ($_ eq $chr) { $tmp{$_} = 1; }
				}
			%allChr = %tmp;
			}
		if (scalar(keys%allChr) == 0) { last; }
		}
	}
else {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		if ($chr ne $tab[0]) {
			if (exists $allChr{$tab[0]}) {
				$chr = $tab[0];
				@Starts = sort{$a<=>$b}(keys%{ ${$Intervals_r}{$chr} });
				$c=0;
				}
			else { next; }
			}
		while ( (($tab[1]+1) > ${$Intervals_r}{$chr}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
			{ $c++; }
		if ( ($tab[2] >= $Starts[$c]) && (($tab[1]+1) <= ${$Intervals_r}{$chr}{$Starts[$c]}) ) {
			$lengthBed++;
			my$cov = $tab[-1];
			if ($maxPl) { if ($cov > $maxPl) { $cov = ($maxPl+1); } }
			$allDepth{$cov}++; 
			}
		if ( ($tab[1]+1) > ${$Intervals_r}{$chr}{$Starts[-1]} ) {
			my%tmp;
			foreach (keys%allChr) { 
				unless ($_ eq $chr) { $tmp{$_} = 1; }
				}
			%allChr = %tmp;
			}
		if (scalar(keys%allChr) == 0) { last; }	
		}
	close COV;
	}
foreach (keys%allDepth) { $allDepth{$_} = $allDepth{$_}/$lengthBed; }
return($lengthBed,\%allDepth);

}

##
sub meanCovPlot {
my($bin,$max2,$outdir,$outName,$lengthBed) = @_;
print "doing meanCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_meanCovPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_sumCovPlot.txt\",header=T, row.names=1)
allMean = apply(mat,2,mean)
std = apply(mat,2,sd)
error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop(\"vectors must be same length\")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
}
barx <- barplot(allMean, names.arg=c(";
print CMDR $line;
print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"mean of all samples\", xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\")
error.bar(barx,allMean, 1.96*std/10)
dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}

##
sub allCovPlot {
my($bin,$max2,$outdir,$outName,$lengthBed,$h1,$h2,$extenS) = @_;
my@Files = @$h1;
my%sampleName = %$h2;
print "doing allCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/hist_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_allCovPlot.png\", 800, ".(scalar@Files*250).")
par(mfrow=c(".scalar@Files.",1))
mat <- read.table(\"$outdir/covPlot/$outName\_sumCovPlot.txt\",header=T, row.names=1)\n";
foreach my$file (@Files) {
	print CMDR "barplot(t(matrix(mat[\"sample_$sampleName{$file}\",])), names.arg=c(";
	print CMDR $line;
	print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"$sampleName{$file}\",xlab=\"Depth\", ylab=\"fraction of $outName\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
	}
print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/hist_temp.R";
unlink "$outdir/hist_temp.R";
}

##
#R barplot -bin , mean of all samples
#binCovPlot($bin,$max2,$outdir,$outName,$lengthBed);
sub binCovPlot {
my($bin,$max2,$outdir,$outName,$lengthBed) = @_;
print "doing binCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\"".($bin*$i)."-\",";
	$i++;
	}
$line .= "\">100\"";
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_binCovPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_binCovPlot.txt\",header=T, row.names=1)
mean1 = apply(mat,2,mean)
mean2 = mean1[1:length(mean1)-1] 
std1 = apply(mat,2,sd)
std2 = std1[1:length(std1)-1]
error.bar <- function(x, y, upper, lower=upper, length=0.1,...) {
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop(\"vectors must be same length\")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...) }
barx <- barplot(mean1, names.arg=c(";
print CMDR $line;
print CMDR "), col=\"blue\", axis.lty=1, main=\"mean of all samples\", xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\")
error.bar(barx,mean1, 1.96*std1/10)
dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}

##
#R barplot -bin , 1graph / sample
#allBinCovPlot($bin,$max2,$outdir,$outName,$lengthBed,\@Files,\%sName2);
sub allBinCovPlot {
my($bin,$max2,$outdir,$outName,$lengthBed,$h1,$h2) = @_;
my@Files = @$h1;
my%sampleName = %$h2;
print "doing allBinCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 )
	{
	$line .= "\"".($bin*$i)."-\",";
	$i++;
	}
$line .= "\">100\"";
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_allBinCovPlot.png\", 800, ".(scalar@Files*250).")
par(mfrow=c(".scalar@Files.",1))
mat <- read.table(\"$outdir/covPlot/$outName\_binCovPlot.txt\",header=T, row.names=1)\n";
foreach my$file (@Files)
	{
	print CMDR "barplot(t(matrix(mat[\"sample_$sampleName{$file}\",])), names.arg=c(";
	print CMDR $line;
	print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"$sampleName{$file}\",xlab=\"Depth\", ylab=\"fraction of $outName\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
	}

print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}


############################
# InterS($bin,$maxPl,$maxGr,$Bed_r,$bedName,\@Files,\%fName,$outdir,$gatk,\%gatkIdx);

sub InterS {

my($bin,$maxPl,$maxGr,$intervals_r,$outName,$Files_r,$fName_r,$outdir,$gatk,$gatkIdx_r)=@_;
print "doing interPlot for $outName\n";
if (scalar(keys%{$intervals_r}) != 0) {
	my@allBins; my$i=0;
	while ( ($i*$bin) <= $maxPl ) {
		push(@allBins,($bin*$i+1));
		$i++;
		}
	my(%nPos,%nCov);
	foreach (@allBins) 
		{ $nPos{$_}=0; $nCov{$_}=0; }
	#intersection
	foreach my$chr (keys%{$intervals_r}) {
		#initialyzes %regCov
		my%regCov;
		foreach (@allBins) {
			my$r=0; #idx of reg of $NM
			foreach my$startReg (sort{$a<=>$b}keys%{ ${$intervals_r}{$chr} }) {
				my$pos=$startReg;
				while ($pos <= ${$intervals_r}{$chr}{$startReg} ) {
					push (@{ $regCov{$_}{$r} }, 0);
					$pos++;
					}
				$r++;
				}
			}
		foreach my$file (@{$Files_r}) {
			#$depth{$loc} = depth
			if ($gatk)
				{ @hashSub = intersect(${$gatkIdx_r}{$file},"$outdir/all.cov",$maxGr,$chr,\@allBins,\%{ ${$intervals_r}{$chr} },$gatk); }
			else 
				{ @hashSub = intersect(${$fName_r}{$file},"$outdir/".${$fName_r}{$file}.".cov",$maxGr,$chr,\@allBins,\%{ ${$intervals_r}{$chr} },$gatk); }
			my%depth = %{ $hashSub[0] };
			#@{ $regCov{$threshold}{$nReg} } = [nber of covered samples foreach pos]
			foreach (@allBins)
				{ covByThreshold($_,\%{ ${$intervals_r}{$chr} },\%depth,\%{ $regCov{$_} }); }
			}
		foreach (@allBins) {
			foreach my$r (keys%{ $regCov{$_} }) {
				foreach my$d (@{ $regCov{$_}{$r} }) {
					$nPos{$_}++;
					if ($d==scalar@{$Files_r}) 
						{ $nCov{$_}++; }
					}
				}
			}
		}
	#plot
	my$hist = "depth\t";
	$i=0;
	while ( ($i*$bin) <= $maxPl ) {
		$hist .= ">".($bin*$i)."\t";
		$i++;
		}
	chop $hist;
	$hist .= "\ncov\t";
	foreach (@allBins) 
		{ $hist .=  ($nCov{$_}/$nPos{$_})."\t"; }
	chop $hist; $hist .= "\n";
	open(OUT, ">$outdir/covPlot/$outName\_interPlot.txt") || die "can't create $outdir/covPlot/$outName\_interPlot.txt\n";
	print OUT $hist;
	close(OUT); 

	#R barplot -sum, 1graph / sample
	interPlot($bin,$maxPl,$nPos{$allBins[0]},$outdir,$outName);

	}

}

##
sub interPlot {
my($bin,$max2,$lengthBed,$outdir,$outName) = @_;
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/hist_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_interPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_interPlot.txt\",header=T, row.names=1)\n";
print CMDR "barplot(t(matrix(mat[\"cov\",])), names.arg=c(";
print CMDR $line;
print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"intersection of all samples\",xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/hist_temp.R";
unlink "$outdir/hist_temp.R";
}


################################

##$bedLines_r = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$bedFile,$bedName,\%Bed,$pThreshold,$toReseq,\@covFields,$gatk,\%gatkIdx,\%CNV_opt);
##$bedLines_r = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$id2Bed,$bedName,\%coordBed,$pThreshold,$toReseq,\@covFields,$gatk,\%gatkIdx,\%CNV_opt);

sub Bed_Cov {

my($Files_r,$fName_r,$sName_r,$outdir,$bedFile,$bedName,$mergeBed_r,$threshold,$toReseq,$bedReport,$covFields_r,$gatk,$gatkIdx_r,$CNV_opt_r) = @_;

print "perform bed coverage by interval";
if ($threshold) { print " ($threshold X)\n"; }
else { print "\n"; }
open(BED, "$bedFile") || die "can't open file $bedFile\n";
my(@allLines,@bedLines,%Chr,%Start,%End,%Intervals,%Intervals2);
my$i=0;my$j=0;
while (my$line=<BED>) {
	$line =~ s/\s+$//;
	$allLines[$i] = $line;
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		my@tab = split(/\t/,$line);
		if ($tab[1] < $tab[2]) {
	#		$tab[0] =~ s/chr//i;
			$bedLines[$j]{"allLine"} = $line;
			$bedLines[$j]{"Chrom"} = $tab[0]; $bedLines[$j]{"Start"} = ($tab[1]+1); $bedLines[$j]{"End"} = $tab[2];
			if ($tab[3] && $tab[3] !~ /^\s*$/) { $bedLines[$j]{"Infos"} = $tab[3]; }
			$tab[0] =~ s/chr//i;
			$Chr{$i} = $tab[0]; $Start{$i} = ($tab[1]+1); $End{$i} = $tab[2];		##1-based
			$Intervals{$Chr{$i}}{$Start{$i}}{$End{$i}} = 1;
			$j++;
			}
		}
	$i++;
	}
close BED;
foreach my$chr (keys%{$mergeBed_r}) {
	foreach my$start (keys%{ ${$mergeBed_r}{$chr} })
		{ $Intervals{$chr}{$start}{${$mergeBed_r}{$chr}{$start}} = 1; }
	}
foreach my$chr (keys%Intervals) {
	foreach my$start (keys%{ $Intervals{$chr} })
		{ @{ $Intervals2{$chr}{$start} } = sort{$a<=>$b}(keys%{ $Intervals{$chr}{$start} }); }
	}

my(%min,%max,%sum,%mean,%median,%cov,%notCov,%TotBases,%TotByCov);
foreach my$file (@{$Files_r}) {
	print "\tfile ${$fName_r}{$file}\n";
	my(%vals);
	foreach my$chr (keys%Intervals) {
		foreach my$start (keys%{ $Intervals{$chr} }) {
			foreach my$end (@{ $Intervals2{$chr}{$start} }) {
			#foreach my$end (keys%{ $Intervals{$chr}{$start} }) {
				$cov{$file}{$chr}{$start}{$end} = 0;
				$min{$file}{$chr}{$start}{$end} = 0;
				$max{$file}{$chr}{$start}{$end} = 0;
				@{ $vals{$chr}{$start}{$end} } = ();
				}
			}
		}
	my$c=0;			#idx of $startByChr
	my$chr = "";
	my(%allChr,@Starts,%noCovStart,%noCovEnd);
	foreach (keys%Intervals) { $allChr{$_} = 1; }

	if ($gatk) {
		unless ( -s "$outdir/all.cov" ) { die "$outdir/all.cov not found or empty\n"; }
		open(COV, "$outdir/all.cov") || die "can't open file $outdir/all.cov\n";
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			$tab[0] =~ s/chr//;
			my@tab2 = split(/:/,$tab[0]);
			my$pos = $tab2[1];
			if ($chr ne $tab2[0]) {
				if (exists $allChr{$tab2[0]}) {
					$chr = $tab2[0];
					@Starts = sort{$a<=>$b}(keys%{ $Intervals{$chr} });
					undef(%noCovStart); undef(%noCovEnd);
					foreach my$start (@Starts) {
						foreach (@{ $Intervals2{$chr}{$start} })
							{ $noCovStart{$start}{$_}=0; $noCovEnd{$start}{$_}=0; }
						}
					$c=0;		##@Starts iteration
					}
				else { next; }
				}
			while ( ($pos > $Intervals2{$chr}{$Starts[$c]}[-1]) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			my$c2 = $c;			##@Starts iteration within while loop
			if ($pos == $Starts[$c2]) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					$min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}];
					$max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}];
					}
				}
			while ( ($pos >= $Starts[$c2]) && ($c2 < (scalar@Starts-1)) ) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					if ($pos <= $end) {
						if ($threshold && $tab[${$gatkIdx_r}{$file}] >= $threshold)
							{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
						else {
							if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							else { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos;
								$noCovStart{$Starts[$c2]}{$end} = $pos;
								$noCovEnd{$Starts[$c2]}{$end} = $pos;
								}
							}
						if ($tab[${$gatkIdx_r}{$file}] < $min{$file}{$chr}{$Starts[$c2]}{$end})
							{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}]; }
						if ($tab[${$gatkIdx_r}{$file}] > $max{$file}{$chr}{$Starts[$c2]}{$end})
							{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}]; }
						push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[${$gatkIdx_r}{$file}]);
						}
				 	}
				$c2++;
				}
			foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
				if (($pos >= $Starts[$c2]) && ($pos <= $end)) {
					if ($threshold && $tab[${$gatkIdx_r}{$file}] >= $threshold)
						{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
					else {
						if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
							$noCovEnd{$Starts[$c2]}{$end} = $pos; 
							}
						else { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
							$noCovStart{$Starts[$c2]}{$end} = $pos; 
							$noCovEnd{$Starts[$c2]}{$end} = $pos; 
							}
						}
					if ($tab[${$gatkIdx_r}{$file}] < $min{$file}{$chr}{$Starts[$c2]}{$end})
						{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}]; }
					if ($tab[${$gatkIdx_r}{$file}] > $max{$file}{$chr}{$Starts[$c2]}{$end})
						{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[${$gatkIdx_r}{$file}]; }
					push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[${$gatkIdx_r}{$file}]);
					}
				}
			if ( $pos > $Intervals2{$chr}{$Starts[-1]}[-1] ) {
				my%tmp;
				foreach (keys%allChr) { 
					unless ($_ eq $chr) { $tmp{$_} = 1; }
					}
				%allChr = %tmp;
				}
			if (scalar(keys%allChr) == 0) { last; }
			}
		}

	else {
		unless ( -s "$outdir/${$fName_r}{$file}.cov" ) { die "$outdir/${$fName_r}{$file}.cov not found or empty\n"; }
		open(COV, "$outdir/${$fName_r}{$file}.cov") || die "can't open file $outdir/${$fName_r}{$file}.cov\n";
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			$tab[0] =~ s/chr//;
			if ($chr ne $tab[0]) {
				if (exists $allChr{$tab[0]}) {
					$chr = $tab[0];
					@Starts = sort{$a<=>$b}(keys%{ $Intervals{$chr} });
					undef(%noCovStart); undef(%noCovEnd);
					foreach my$start (@Starts) {
						foreach (@{ $Intervals2{$chr}{$start} })
							{ $noCovStart{$start}{$_}=0; $noCovEnd{$start}{$_}=0; }
						}
					$c=0;
					}
				else { next; }
				}
			my$pos=$tab[1]+$tab[-2];
			while ( ($pos > $Intervals2{$chr}{$Starts[$c]}[-1]) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			my$c2 = $c;
			if ($pos == $Starts[$c2]) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					$min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1];
					$max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1];
					}
				}
			while ( ($pos >= $Starts[$c2]) && ($c2 < (scalar@Starts-1)) ) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					if ($pos <= $end) {
						if ($threshold && $tab[-1] >= $threshold)
							{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
						else {
							if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							else { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
								$noCovStart{$Starts[$c2]}{$end} = $pos; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							}
						if ($tab[-1] < $min{$file}{$chr}{$Starts[$c2]}{$end}) 
							{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
						if ($tab[-1] > $max{$file}{$chr}{$Starts[$c2]}{$end}) 
							{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
						push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[-1]);
						}
				 	}
				$c2++;
				}
			foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
				if (($pos >= $Starts[$c2]) && ($pos <= $end)) {
					if ($threshold && $tab[-1] >= $threshold)
						{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
					else {
						if ( $pos == ($noCovEnd{$Starts[$c2]} + 1) ) { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}} = $pos ; 
							$noCovEnd{$Starts[$c2]} = $pos; 
							}
						else { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
							$noCovStart{$Starts[$c2]} = $pos; 
							$noCovEnd{$Starts[$c2]} = $pos; 
							}
						}
					if ($tab[-1] < $min{$file}{$chr}{$Starts[$c2]}{$end})
						{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
					if ($tab[-1] > $max{$file}{$chr}{$Starts[$c2]}{$end})
						{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
					push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[-1]);
					}
				 }
			if ( $pos > $Intervals2{$chr}{$Starts[-1]}[-1] ) {
				my%tmp;
				foreach (keys%allChr) { 
					unless ($_ eq $chr) { $tmp{$_} = 1; }
					}
				%allChr = %tmp;
				}
			if (scalar(keys%allChr) == 0) { last; }	
			}
		close COV;
		}
	foreach my$chr (keys%Intervals) {
		foreach my$start (keys%{ $Intervals{$chr} }) {
			foreach my$end (@{ $Intervals2{$chr}{$start} }) {
				my$len = $end-$start+1;
				#cov
				$cov{$file}{$chr}{$start}{$end} /= $len;
				#sum
				$sum{$file}{$chr}{$start}{$end} = 0;
				foreach (@{ $vals{$chr}{$start}{$end} }) 
					{ $sum{$file}{$chr}{$start}{$end} += $_; }
				#mean
				$mean{$file}{$chr}{$start}{$end} = ($sum{$file}{$chr}{$start}{$end} / $len);
				#median
				my@sortDepth=();
				for (my$i=0;$i<($len - scalar@{ $vals{$chr}{$start}{$end} });$i++) { push(@sortDepth,0); }
				push(@sortDepth,@{ $vals{$chr}{$start}{$end} });
				@sortDepth = sort{$a<=>$b}@sortDepth;
				#odd?
				if($len%2) 
					{ $median{$file}{$chr}{$start}{$end} = $sortDepth[int($len/2)]; }
				#even
				else 
					{ $median{$file}{$chr}{$start}{$end} = (($sortDepth[int($len/2)-1]+$sortDepth[int($len/2)])/2 ); }
				}
			}
		}
	foreach my$chr (keys%{$mergeBed_r}) {
		foreach my$start (keys%{ ${$mergeBed_r}{$chr} }) {
			foreach (@{ $vals{$chr}{$start}{${$mergeBed_r}{$chr}{$start}} }) {
				$TotBases{$file} += $_;
				if ($threshold && $_ >= $threshold)
					{ $TotByCov{$file} ++; }
				}
			}
		}
	}

my$meanTotBases=0;
foreach (@{$Files_r}) { $meanTotBases += $TotBases{$_}; }
if ($meanTotBases)
	{ $meanTotBases /= scalar@{$Files_r}; }
else { print "no bases sequenced within bed in all samples!\n"; }

my$TotLength = 0;
foreach my$chr (keys%{$mergeBed_r}) {
	foreach my$start (keys%{ ${$mergeBed_r}{$chr} })
		{ $TotLength += (${$mergeBed_r}{$chr}{$start} - $start + 1); }
	}


my$nCol;
foreach (@allLines) {
	if (($_ =~ /^\w+\t\d+\t\d+/) && ($_ !~ /^#/)) {
		my@Col = split(/\t/,$_);
		$nCol = scalar@Col;
		}
	if ($nCol) { last; }
	}

open(OUT1, ">$outdir/$bedName.cov.txt") || die "can't create file $outdir/$bedName.cov.bed\n";
print OUT1 "##samples:";
for (my$i=0;$i<($nCol-1);$i++) { print OUT1 "\t"; }
foreach (@{$Files_r}) { 
	print OUT1 "\t${$sName_r}{$_}";
	for (my$i=1;$i<scalar@{$covFields_r};$i++) { print OUT1 "\t"; }
	}
print OUT1 "\n##bed col.";
for (my$i=0;$i<($nCol-1);$i++) { print OUT1 "\t"; }
foreach (@{$Files_r}) {
	foreach(@{$covFields_r}) {
		if ($_ eq "cov") { print OUT1 "\t%>=$threshold"."X"; }
		else { print OUT1 "\t$_"; }
		}
	}
print OUT1 "\n";
my%reseq;
if ($toReseq)
	{ open(OUT2, ">$outdir/$bedName.toReseq.txt") || die "can't create file $outdir/$bedName.toReseq.txt\n"; }
$j=0;
for (my$i=0;$i<scalar@allLines;$i++) {
	print OUT1 $allLines[$i];
	if (exists $Chr{$i}) {
		foreach my$file (@{$Files_r}) {
			$bedLines[$j]{$file}{"mean"} = $mean{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}};
			if (exists ${$CNV_opt_r}{"seuil_cov"}) { $bedLines[$j]{$file}{"cov"} = $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
			if (${$CNV_opt_r}{"RefDepth"} eq "tot") { $bedLines[$j]{$file}{"tot"} = $sum{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
			foreach(@{$covFields_r}) {
				if ($_ eq "min") { print OUT1 "\t".$min{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "max") { print OUT1 "\t".$max{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "tot") { print OUT1 "\t".$sum{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "mean") { print OUT1 "\t".sprintf("%.1f",$mean{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}); }
				elsif ($_ eq "median") { print OUT1 "\t".sprintf("%.1f",$median{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}); }
				elsif ($_ eq "cov") { print OUT1 "\t".100*(sprintf("%.3f", $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}))."%"; }
				}
			if ($toReseq && $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}} < $toReseq) 
				{ push(@{ $reseq{$i} },"${$sName_r}{$file} (".100*(sprintf("%.3f", $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}))."%)"); print STDERR "$toReseq ${$sName_r}{$file} $i $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}\n";}
			}
		$j++;
		}
	print OUT1 "\n";
	if ($toReseq && exists $reseq{$i}) {
		print OUT2 $allLines[$i];
		foreach (@{ $reseq{$i} })
			{ print OUT2 "\t$_"; }
		print OUT2 "\n";
		}
	}
close OUT1; 
if ($toReseq) { close OUT2; }

if ($bedReport && $threshold) {
	foreach my$file (@{$Files_r}) {
		open(OUT, ">$outdir/cov\_${$sName_r}{$file}/$bedName.${$sName_r}{$file}.notCov.txt") || die "can't create file $outdir/cov\_${$sName_r}{$file}/$bedName.${$sName_r}{$file}.notCov.bed\n";
		print OUT "depthAnd Coverage report on $bedName.bed for ${$sName_r}{$file} sample\n\n";
		print OUT "total length of bed : $TotLength bp\n\n";
		print OUT "total cov >=$threshold"."x : ".100*(sprintf("%.3f", ($TotByCov{$file}/$TotLength)))." %\n\n";
		print OUT "mean depth : ".sprintf("%.1f", ($TotBases{$file}/$TotLength))." x\n\n";
		print OUT "domains covered less than $threshold"."x\n";
		for (my$i=0;$i<scalar@allLines;$i++) {
			if (exists $Chr{$i}) {
				if (exists $notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}) {
					print OUT "\n".$allLines[$i]."\n";
					foreach (sort{$a<=>$b}keys%{ $notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}} }) {
						print OUT "\t".($_-1)."\t".$notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}{$_}."\n";
						}
					}
				}
			}
		close OUT;
		}
	}

return(\@bedLines);
}



########################
#for $All $NM on same graph
# CNVgraphByGene($file,$suff,"$outdir/CNV_analysis/$sName2{$file}",$gene,$sens,$maxGr,$Rev,$chr,$CNV_maxCov{$gene},$pThreshold,$NMlength{$gene},\@Files,\%sName2,$Regions{"raw"},$Regions{"rev"},\@NMs,$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$CNV_NMdepth{$gene});

sub CNVgraphByGene {

my($file,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$threshold,$NMlength,$Files_r,$sampleName_r,$Regions_r,$Reg_00_r,$NMs_r,$NM_Ex00_r,$NMbed00_r,$intron_r,$UTR_r,$Cod_r,$NMdepth_r) = @_;

print "print CMDR CNVgraphByGene: ".${$sampleName_r}{$file}." , in $gene\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my$nNMs = scalar@{$NMs_r};
my@Starts = sort{$a<=>$b}(keys%{ $Regions_r->{$chr}{$gene} });
my$startReg = $Starts[0];
my$endReg = $Regions_r->{$chr}{$gene}{$Starts[-1]};

my($Y,$Y1,$Y2);
#$line1: cmdR for plot cov line
my$line1="";
foreach my$f2 (@{$Files_r}) {
	unless ($f2 eq $file) {
		#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
		$line1 .= line1c("black",\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$f2} });
		}
	}
$line1 .= line1c("green",\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });

#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
my$line2="";
for(my$i=0;$i<$nNMs;$i++) { 
	$Y=(0.425+0.25*$i);
	$line2 .= line2($maxY,$Y,\%{ $intron_r->{${$NMs_r}[$i]} });
	}

#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
$Y1=0.1;$Y2=0.25;
my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00_r->{$gene} });


#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
my$line4a="";
for(my$i=0;$i<$nNMs;$i++) {
	if (scalar(keys%{ $UTR_r->{${$NMs_r}[$i]} })!=0) {
		$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
		$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR_r->{${$NMs_r}[$i]} });
		}
	}

#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
my$line4b="";
for(my$i=0;$i<$nNMs;$i++) {
	if (scalar(keys%{ $Cod_r->{${$NMs_r}[$i]} })) {
		$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
		$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod_r->{${$NMs_r}[$i]} });
		}
	}

#$line4c: Nb exon
#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my$line4c="";
for(my$i=0;$i<$nNMs;$i++) {
	$Y=(0.3+0.25*$i);
	$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ ${$NM_Ex00_r}{${$NMs_r}[$i]} });
	}

#$line7: NM names
my$line7 = line7($NMlength,$maxY,$NMs_r);

#print CMDR:
open (CMDR, ">$outdir/".${$sampleName_r}{$file}.".$gene.temp.R") || die "cannot create $outdir/".${$sampleName_r}{$file}.".$gene.temp.R";
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "pdf(\"$outdir/".${$sampleName_r}{$file}.".$gene.pdf\", width=11.69, height=".(4.135*(0.75+0.875+(0.125*$nNMs))/1.75).")\n";
 
#png: my$cmdR = "plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"normalized_depth\", cex.lab=1.5, cex.axis=1.2)\n";
#pdf:
my$cmdR = "plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*$nNMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : ".${$sampleName_r}{$file}."\", ylab = \"normalized_depth\", cex.lab=1, cex.axis=0.8)\n";

$cmdR .= $line1;

$cmdR .= "abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=1.5)\n";
if ($threshold) { $cmdR .= "abline(h=$threshold, col=\"darkgrey\", lty = \"dotted\", lwd=1.5)\n"; }

$cmdR .= $line2.$line4a.$line4b.$line4c.$line7;

$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";

print CMDR "$cmdR";
if ($sens eq "+") {
	print CMDR "mtext(\"$gene : chr $chr:$startReg >>> $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
	}
else {
	print CMDR "mtext(\"$gene : chr $chr:$startReg <<< $endReg\", side = 3, outer=TRUE, line=-3, cex=1)\n";
	}
print CMDR "dev.off();\n";
close CMDR;
system "Rscript $outdir/".${$sampleName_r}{$file}.".$gene.temp.R";
unlink "$outdir/".${$sampleName_r}{$file}.".$gene.temp.R";

}


########################
#$line1 .= line1c("green",\%{ $Reg_00_r->{$gene} },\%{ $NMdepth_r->{$file} });
sub line1c {
my($col,$Reg_00_r,$NMdepth_r) = @_;
my@startR = sort{$a<=>$b}keys%{$Reg_00_r};
my$line1="";
my$p=0;my$i=0;
for (my$n=0;$n<scalar@startR;$n++) {
	$line1 .= "lines( c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ ${$NMdepth_r}{$n} })
		{ $line1 .= $p.","; $p++; $i++; }
	chop $line1;
	$line1 .= "), c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ ${$NMdepth_r}{$n} }) {
		if (${$NMdepth_r}{$n}[$i] eq "") { $line1 .= "0,"; }
		else { $line1 .= ${$NMdepth_r}{$n}[$i].","; }
		$p++; $i++;
		}
	chop $line1;
	$line1 .= "), type =\"l\", lwd=1.5, col=\"$col\")\n";
	}
return($line1);
}


############################
#print tests:

#	print "Regions:\n";	# $Regions{chr}{NM}{start of region} = end of region
#	foreach my$chr(sort(keys%Regions)) {
#		foreach my$NM (sort(keys%{ $Regions{$chr} })) {
#			foreach my$startR (sort{$a<=>$b}keys%{ $Regions{$chr}{$NM} })
#				{ print $chr."\t".$NM."\t".$startR."\t".$Regions{$chr}{$NM}{$startR}."\n"; }
#			}
#		}

#	print "NM_Ex:\n";	# %NM_Ex{NM}{start of region}{start of exon} = end of exon
#	foreach (sort(keys%NM_Ex)) {
#		foreach my$startR (sort{$a<=>$b}keys%{ $NM_Ex{$_} }) {
#			foreach my$startN (sort{$a<=>$b}keys%{ $NM_Ex{$_}{$startR} })
#				{ print $_."\t".$startR."\t".$Regions{$NMchr{$_}}{$NMgene{$_}}{$startR}."\n\t\t".$startN."\t".$NM_Ex{$_}{$startR}{$startN}."\n"; }
#			}
#		}

#	print "introns:\n";	# $intron{$NM}{$startIntron} = $endIntron
#	foreach my$NM (sort(keys%intron)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $intron{$NM} }))
#			{ print $NM."\t".$start."\t".$intron{$NM}{$start}."\n"; }
#		}
#	print "UTRs:\n";	# $UTR{$NM}{$startUTR} = $endUTR
#	foreach my$NM (sort(keys%UTR)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $UTR{$NM} }))
#			{ print $NM."\t".$start."\t".$UTR{$NM}{$start}."\n"; }
#		}
#	print "Cods:\n";	# $Cod{$NM}{$startCod} = $endCod
#	foreach my$NM (sort(keys%Cod)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $Cod{$NM} }))
#			{ print $NM."\t".$start."\t".$Cod{$NM}{$start}."\n"; }
#		}


##############
#gatk:
#-omitIntervals	
#outName.sample_interval_statistics	not used (eq to sum)
#outName.sample_interval_summary		for bed (remove 4,5,6e col)

#-omitLocusTable				not used
#outName.sample_cumulative_coverage_counts
#outName.sample_cumulative_coverage_proportions

#-omitSampleSummary		
#outName.sample_statistics		for hist
#outName.sample_summary

#-omitBaseOutput				if only plot

#options:
#--nBins	499 	Number of bins to use for granular binning

#--start	1 	Starting (left endpoint) for granular binning

#--stop		500 	Ending (right endpoint) for granular binning

#$intervalName-all.cov
#Locus	Total_Depth	Average_Depth_sample	Depth_for_01	Depth_for_02	Depth_for_03
#chr1:43390947	244	81.33	43	124	77
#chr1:43390948	248	82.67	44	125	79

