#!/usr/bin/perl


##depth analysis of bam files
##at regions defined by a bed file or a list of genes
##makes R graphs, with depth line and not covered domains, at different thresholds

##thomas Simonet, CHU de Lyon, 2014 (thomas.simonet@chu-lyon.fr)
##Pierre-Antoine Rollat-Farnier, CHU de Lyon, 2015
##Vincent Danjean, 2016

##This program is a free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>


our $VERSION="1.6.2c";

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Find;
use Cwd 'abs_path';
use lib dirname(abs_path($0))."/../lib";
use DeCovA::bedProcessing;
use DeCovA::refIDs;

require File::Which;
require IO::Zlib;
require File::Copy;
require File::Path;
require IO::Compress::Gzip;


############
#parameters:

Getopt::Long::Configure ("bundling");
my %opt = ();
GetOptions (\%opt, 
	"file|f=s@",
	"fList|F=s",
	"dir|d=s@",
	"suffix|s=s",
	"ref|r=s",
	"fmt=s",
	"bed|b=s",
	"mut|m=s",
	"outdir|O=s",
	"outfile|o=s",
	"id|i=s@",
	"idList|I=s",
	"nonCoding|N",
	"depthThreshold|t=s@",
	"printThreshold|T=i",
	"noGraphThreshold",
	"noUTR|U",
	"noUTRinTxt|u",
	"maxDepth=i",
	"expand2val|l=s",
	"UDstream=s",
	"splitBedFromId",
	"mergeBedFromId",
	"expand2bed|L",
	"Ltxt:s",
	"UDtxt:s",
	"Lbed=i",
	"noReverse|R",
	"graphSum|S",
	"allSample|A",
	"bySample|X",
	"noAllTranscripts",
	"noDepthMut|M",
	"covPlot|P",
	"covBed|B",
	"bedReport",
	"Reseq=f",
	"cov_fields=s@",
	"geneReport",
	"summary:s",
	"keepCov|k",
	"keepBed|K:s",
	"keepTmpBed:s",
	"raw_cov=s",
	"binPlot=i",
	"maxPlot=i",
	"genePlot",
	"interPlot",
	"gatk3:s",
	"gatk4:s",
	"ram|x=i",
	"cpu=i",
	"bedtools=s",
	"samtools=s",
	"picard=s",
	"genome|g=s",
	"dedup:s",
	"mbq=i",
	"mmq=i",
	"CNV|C",
	"sex_file=s",
	"bed_cov=s",
	"split_bed",
	"no_overlap_bed",
	"cut_bed:s",
	"reAnnot_bed:s",
	"level2=s",
	"spread2=s",
	"level_del=f",
	"level_dup=f",
	"spread_del=f",
	"spread_dup=f",
	"range=f",
	"highQual=s",
	"ex_region=f",
	"ex_sample=f",
	"ex_cov=f",
	"ex_DP=i",
	"max_nonCNVcons=i",
	"max_nonCNVrate=f",
	"ratioByGender=s",
	"normAllChr",
	"normDepth=s",
	"graph_byGene:s",
	"graph_byChr:s",
	"graph_byCNV:s",
	"CNV_fields=s@",
	"compress|z",
	"nGraph:i",
	"version|v",
	"help|h") or die "!!!\n\tInvalid parameters: $! \n";

unless(%opt) { usage(); }

if (exists $opt{help}) { usage(); }

if (exists $opt{version}) { die "$VERSION\n"; }

if (@ARGV) {
	print"Invalid parameters:\n";
	foreach(@ARGV) { print"\t$_\n"; }
	die "(forgotten \"-\"?)\n";
}

sub usage {
die "usage:
	as a script:		perl /path/to/DeCovA/bin/DeCovA [options]
	or after installation:	DeCovA [options]

options:

inputs:
    -f / --file [file]: list of bam files (comma separated, or set several times)
    -F / --fList [file]: file with such a list of bam files (one bam per line)
    -d / --dir [dir]: directory(ies) where to find bam files (comma separated, or set several times)
    -s / --suffix [str]: suffix to add before opening bam files
    -r / --ref [file]: gene annotation file (can be .gz)
    --fmt [gtf/gff3/ucsc] : gene annotation file format (ucsc <=> UCSC refGene) ; if not provided, determined from extension (txt => UCSC refGene)
    -b / --bed [file]: bed file, used to analyse depth coverage
    -m / --mut [file]: mut file, used to plot known mutations ; format: \"chr<tab>pos(1-based)<tab>info\" (vcf files are ok ; can be .gz)
    -i / --id [str]: list of of genes/transcripts ids (comma separated, or set several times)
    -I / --idList [file]: file with a list of of genes/transcripts ids (one id per line)
    -g / --genome [file]: path to genome.fa file, if available (required if using GATK)
    --sex_file [file]: format: patient<tab>sex
    --raw_cov [file]: use this coverage tool output .cov file (to skip bam analysis)
    --bed_cov [file]: use this DeCovA's output .cov.txt file (to skip cov bed analysis in CNV detect)

outputs:
    -O / --outdir [dir]: out directory (default: folder named with date)
    -S / --graphSum : will perform graphSums (sum of covered samples by position)
    -A / --allSample : will perform graphAllSample (depthline by gene and by sample, all samples graph on same .png file)
    -X / --bySample : will perform graphBySample (depthline by gene and by sample, one sample by .png file)
    -M / --noDepthMut : does not print, foreach file, depth at known mutations provided by opt -m (default: yes if -opt m)
    -P / --covPlot : will perform covPlots
    -B / --covBed : will output cov of bed intervals
    -C / --CNV : will output CNV foreach bed intervals
    --Reseq : [float,0-1] : print bed interval if cov < value (def: do not print)
    --geneReport : will print all uncovered genomic intervals (within gene region) in 1 txt file per sample (default: no)
    --bedReport : will print all uncovered intervals (within bed intervals) in 1 txt file per sample (default: no)
    --summary [Y/N] : to print summary txt file (default: yes if -S -A -X)
    -k / --keepCov : do not discard coverage file at the end of the process
    -K / --keepBed : do not discard bed file inferred from gene list, at the end of the process (and eventually rename)
    --keepTmpBed : do not discard temp. bed file processed for depth analysis (and eventually rename)

parameters:
  *gene/transcript regions analysis param.:
    -N / --nonCoding : analyse also Non coding transcripts (default: no)
    -U / --noUTR : does not take into account UTR regions, for graphs (default: yes)
    -u / --noUTRinTxt : does not take into account UTR regions, for summary txt file and plots (default: yes)
    -t / --depthThreshold [int]: depth thresholds (comma separated, or set several times)
    -T / --printThreshold [int]: depth threshold used for txt outputs (must be one of those in opt -t; default : the smallest one)
    --noGraphThreshold : all graphs will be printed, whatever the coverage 
        (default: only the genes not fully covered at threshold in -opt -T will be drawn)
    --noAllTranscripts : does not print All transcripts on same file, in graphBySample (default: yes)
    --maxDepth [int]: max depth value when printing graph (optional)
    -l / --expand2val [int]: length to add at each ends of exons, on graphs (default: 0) ; or [int1,int2] : lengths to add in 5' and 3'
    --UDstream [int]: length to add at each ends of genes, on graphs ; or [int1,int2] : lengths to add upstram and downstream
    --splitBedFromId : if padding creates overlapping exons, take the mid between them (for report)
    --mergeBedFromId : merge overlapping exons
    -L / --expand2bed : expand length of gene analysed regions to bed coord, if -l < bed , on graphs (default: no)
    --Ltxt [+/-int]: does take into account expanded length (from -l and -L) for txt outputs (default: no), or add a different length
    --UDtxt [+/-int]: does take into account up/downStream length for txt outputs (default: no), or add a different length
    -R / --noReverse : does not reverse regions if sens of transcript = (-) (default: yes)
    --nGraph : max nber of graphs per sheet (default : all samples or all transcripts)

  *plot param:
    --binPlot [int]: bin width for covPlot (default=10)
    --maxPlot [int]: max depth for covPlot (default=100)
    --genePlot : will perform plots for regions extracted from genes coord, not only for bed intervals (default: no)
    --interPlot : will produce intersection covPlot (default: no)

  *bam filters
    --dedup : do not take in account dup reads (default keep all reads; enter \"do\" to perform Picard deduplication) 
    --mbq : minimum base quality (default 0; requires gatk)
    --mmq : minimum mapping quality (default 0)

  *cov_bed param:
    --cov_fields [min/max/tot/mean/median/cov]: fields foreach intervals in covBed (comma separated) (default: min,mean,cov)
    --Lbed [int]: length added out of bed interval ends (default: 0)
    --split_bed : splits overlapping bed intervals for Cov and CNV analyses
    --no_overlap_bed : removes overlapping bed intervals for Cov and CNV analyses
    --cut_bed [+/-cutL:x,minL:y,maxL:z,keepLast:s]: cut bed intervals in shorter fragments:
                cutL : length of segmentation (def: 150)
                minL : min length required to keep the last interval, after segmentation (def: --cutL/2)
                maxL : length above which bed intervals will be segmented, in N segments of \"cutL\" length (def: as --cutL)
                keepLast : if last interval shorter than minL :
                        enter m (merge) if want that last two ones are simply merged
                        enter h (half) if want that last two ones are output with length = half of their sum
                        enter n if want to through it out
    --reAnnot_bed : removes and replaces 4th column of bed file with gene info
        (optional args: g,t,e,i,o : indicates to annotate with gene/transcript/exon/intron/intergenic infos; default: all)

  *CNV_detect param:
    --level2 : \"avg\"/\"med\" : use average/median as center of depths of a region (def: med)(if spread2 is set, level2 is unset, unless explicitedly)
    --spread2 : \"std\"/\"qtile\" : use standard deviation/deviation from quartile as dispersion of depths of a region (def: none)(std forces avg, qtile forces med)
    --level_del [float [0-1]] (def: 0.8)
    --level_dup [float >1] (def: 1.2)
    --spread_del [float <0] (def: none)
    --spread_dup [float >0]  (def: none)
    --range [float]: samples kept for avg-std calculation if within mediane+/-range*quartile (def: none, ie all samples used)
    --highQual [li:float/ls:float/si:float/ss:float/c:int]: flag as high qual if one of following criteria, comma separated :
        li=level inf, ls=level sup, si=spread inf, ss=spread sup, c=consecutive :
        ex : li:0.25,ls:1.75,si:-5,ss:5,c:2
    --ex_region [float [0-1]] : region excluded from analysis if CNVs/N_samples >value (def: 1)
    --ex_sample [float [0-1]] : sample excluded from analysis if CNVs/N_regions >value (def: 1)
    --ex_cov [float [0-1]] : region excluded from analysis if none of the samples have cov >=value (def: 0)
    --ex_DP [int] : region excluded from analysis if avg depth <=value (def: 0)
    --max_nonCNVcons [int]: max nber of non-CNV consecutive intervals tolerated within a CNV (def: 0)
    --max_nonCNVrate [int]: max rate of non-CNV intervals tolerated within a CNV (def: 0)
    --ratioByGender [a/g/no]:	enter \"a\" : foreach region from all chrom, depth ratio computed separately for F and M ; 
                enter \"g\" : foreach region from gonosomes only, depth ratio computed separately for F and M
                def: no (depth ratio for F and M together)
    --normAllChr : total depth used to norm sample depths = sum on all chr, whatever the sex (def: double the depth for chrX if male, and skip chrY in the sum)
    --normDepth [mean/tot] : total depth used to norm sample depths = sum of total depths of each region or sum of mean depths of each region (def)
    --graph_byGene : to enable graph for gene affected by a CNV (def: no)
    --graph_byChr : to enable graph by chromosome (def: no)
    --graph_byCNV : to enable graph around each CNV (def: yes)
    --CNV_fields [min/max/med/avg/std/Q1/Q3]: list of fields foreach region (comma separated) (default: none)

    *external tools path:
    --bedtools [file]: enter path to executable, if not installed as root or not in path
    --samtools [file]: enter  path to executable, if not installed as root
    --gatk3 [file]: path to gatk V3 .jar file
    --gatk4 [file]: path to gatk V4 .jar file

    *general:
    -x / --ram [int]: memory for gatk (in Go)
    --cpu [int]: multi-thread for gatk (def: 1)
    -v / --version : current version 
    -h / --help : help
	\n";
}

##inputs:
print "\n\n####\n\nchecking input files\n\n####\n";

#-d: directory
my @dir = ();
if (exists $opt{dir}) {
	@dir = split(/,/, join(',',@{$opt{dir}}));
	foreach (@dir) {
		unless(-d $_) { die "!!!\n\t$_ directory not found\n"; }
		unless ($_ =~ /\/$/) { $_ .= "/"; } 
	}
}
#-f: files
my $suff = "";
if (exists $opt{suffix}) { 
	$suff = $opt{suffix}; 
	$suff =~ s/.bam$//;
}
my @Files = ();
if (exists $opt{file}) {
	@Files = split(/,/, join(',',@{$opt{file}}));
}
if (exists $opt{fList}) {
	if (-f $opt{fList}) {
		open(my $fh, "<", $opt{fList}) || die "!!!\n\tcan't open file $opt{fList} ($!)\n";
		while (my $line=<$fh>) {
			unless ($line =~ /^\s*$/) {
				$line =~ s/\s*$//; $line =~ s/^\s*//;
				push (@Files, $line);
			}
		}
		close $fh;
	} else {
		die $opt{fList}." not found\n";
	}
}
foreach my $dir(@dir) {
	find(\&subDir, $dir);
}
sub subDir {
	if ($suff) {
		if (-f $_ && $_=~/$suff.bam$/) {
			push(@Files, $File::Find::name);
		}
	} else {
		if (-f $_ && $_=~/.bam$/) {
			push(@Files, $File::Find::name);
		}
	}
}
my(%fName,%path);	#fName: name of file, without path and extension
my $extenS = "$suff.bam";
if (@Files) {
	print "\n\tbam file(s) to analysed:\n";
	##uniquify
	my %Files = ();
	foreach (@Files) { $Files{$_} = 1; }
	@Files = sort(keys%Files);
	##parse path
	foreach (@Files) {
		($fName{$_},$path{$_}) = fileparse($_,$extenS);
		if (exists $opt{dir} && exists $opt{file}) {
			if (scalar@dir>1) {
				die "!!!\n\tnot possible to affect path to files if several paths specified\n";
			} else {
				$path{$_} = $dir[0];
			}
		}
		if (-f $path{$_}.$fName{$_}.$extenS) {
			print "\t\t".$path{$_}.$fName{$_}.$extenS."\n";
		} else {
			die "!!!\n\t".$path{$_}.$fName{$_}.$extenS." file not found\n";
		}
	}
}
print "\n";

my $refFile = "";
if (exists $opt{"ref"}) { 
	if (-f $opt{"ref"}) {
		$refFile = $opt{"ref"};
		print "\t$refFile OK\n";
	} else {
		die "!!!\n\t".$opt{"ref"}." not found\n";
	}
}
my $refFmt = "";
if ($refFile) {
	if (exists $opt{fmt}) {
		if ($opt{fmt} =~ /ucsc/i) { $refFmt = "ucsc"; }
		elsif ($opt{fmt} =~ /gtf/i) { $refFmt = "gtf"; }
		elsif ($opt{fmt} =~ /gff/i) { $refFmt = "gff3"; }
		else { die "!!!\n\t".$opt{fmt}." format not recognized (ucsc / gtf/ gff3)\n"; }
	} else {
		if ($refFile =~ /.txt(.gz)?$/) { $refFmt = "ucsc"; }
		elsif ($refFile =~ /.gtf(.gz)?$/) { $refFmt = "gtf"; }
		elsif ($refFile =~ /.gff3(.gz)?$/) { $refFmt = "gff3"; }
		else { die "!!!\n\t$refFile format not recognized\n"; }
	}
}

my($bedFile,$bedName);
if (exists $opt{bed}) { 
	if (-f $opt{bed}) {
		$bedFile = $opt{bed};
		$bedName = fileparse($bedFile,".bed");
		print "\t$bedFile OK\n";
	} else {
		die "!!!\n\t".$opt{bed}." not found\n";
	}
}

my($mutFile,$mutFileName);
if (exists $opt{mut}) { 
	if (-f $opt{mut}) {
		$mutFile = $opt{mut};
		$mutFileName = fileparse($mutFile);
		print "\t$mutFile OK\n";
	} else {
		die "!!!\n\t".$opt{mut}." not found\n";
	}
}

my $outfile = "cov_";
if ($opt{outfile}) {
	$outfile = $opt{outfile};
}

my @IDs = ();
if (exists $opt{id}) {
	@IDs = split(/,/, join(',',@{$opt{id}}));
}
if (exists $opt{idList}) {
	if (-f $opt{idList}) {
		open(my $fh, "<", $opt{idList}) || die "!!!\n\tcan't open file $opt{idList} ($!)\n";
		while (my $line = <$fh>) {
			unless($line =~ /^\s*$/ || $line =~ /^#/) {
				#$line =~ s/\s//g;
				$line =~ s/\s+$//; $line =~ s/^\s+//;
				push(@IDs, $line);
			}
		}
		close $fh;
	} else {
		die "!!!\n\t".$opt{idList}." not found\n";
	}
}
if (@IDs) {
	my %IDs = ();
	foreach my $id (@IDs) { 
		$IDs{$id} = 1;
	}
	@IDs = sort(keys%IDs);
	#print "Regions to analyse: \n";
	#foreach (@IDs) { print "\t$_\n"; }
}

my $raw_cov_file = "";
if (exists $opt{raw_cov}) {
	if (-f $opt{raw_cov}) {
		$raw_cov_file = $opt{raw_cov};
		if (-s $raw_cov_file) { print "\t$raw_cov_file OK\n"; }
		else { die "!!!\n\t$raw_cov_file empty\n"; }
	} else {
			die "!!!\n\t".$opt{raw_cov}." not found\n";
	}
}
if (@Files && $raw_cov_file) {
	die "!!!\n\tmust choose between providing bam files or cov files\n";
}

my $bed_cov_file = "";
if (exists $opt{bed_cov}) { 
	if (-f $opt{bed_cov}) {
		$bed_cov_file = $opt{bed_cov};
		print "\t$bed_cov_file OK\n";
	} else {
		die "!!!\n\t".$opt{bed_cov}." not found\n";
	}
}

my $genom = "";
if (exists $opt{genome}) {
	if (-f $opt{genome}) {
		$genom = $opt{genome}; 
		print "\t$genom OK\n";
	} else {
		die "!!!\n\t".$opt{genome}." not found\n";
	}
}

my $fichier_sexe = "";
if (exists $opt{sex_file}) { 
	if (-f $opt{sex_file}) {
		$fichier_sexe = $opt{sex_file};
		print "\t$fichier_sexe OK\n";
	} else {
		die "!!!\n\t".$opt{sex_file}." not found\n";
	}
}

##jobs
my %jobs = ();
$jobs{"bedReport"} = 0;
$jobs{"graphSum"} = "";
$jobs{"graphAllSampls"} = "";
$jobs{"graphBySample"} = "";
$jobs{"covMut"} = "";
$jobs{"covPlot"} = "";
$jobs{"interSplot"} = "";
$jobs{"genePlot"} = "";
$jobs{"covBed"} = "";
$jobs{"2Reseq"} = "";
$jobs{"CNV"} = "";
$jobs{"geneReport"} = "";
$jobs{"geneSummary"} = "";
$jobs{"keepCov"} = "";
$jobs{"keepBed"} = "";
$jobs{"keepTmpBed"} = "";

if (exists $opt{bedReport}) { $jobs{"bedReport"} = 1; }
if (exists $opt{graphSum}) { $jobs{"graphSum"} = 1; }
if (exists $opt{allSample}) { $jobs{"graphAllSampls"} = 1; }
if (exists $opt{bySample}) { $jobs{"graphBySample"} = 1; }
if ($mutFile) { $jobs{"covMut"} = 1; }
if (exists $opt{noDepthMut}) { $jobs{"covMut"} = ""; }
if (exists $opt{covPlot}) {
	$jobs{"covPlot"} = 1;
	use DeCovA::histCov;
}
if (exists $opt{interPlot}) {
	$jobs{"interSplot"} = 1;
	use DeCovA::histCov;
}
if (exists $opt{genePlot}) { $jobs{"genePlot"} = 1; }
if (exists $opt{covBed}) { $jobs{"covBed"} = 1; }
if (exists $opt{Reseq}) { $jobs{"2Reseq"}=$opt{Reseq}; }
if (exists $opt{CNV}) { $jobs{"CNV"} = 1; }
if (exists $opt{geneReport}) { $jobs{"geneReport"} = 1; }
if ($jobs{"graphSum"}
	|| $jobs{"graphAllSampls"}
	|| $jobs{"graphBySample"}) {
	$jobs{"geneSummary"} = 1;
}
if (exists $opt{summary}) {
	if ($opt{summary}) {
		if ($opt{summary} =~ /^y|^o/i) {
			$jobs{"geneSummary"} = 1;
		} elsif ($opt{summary} =~ /^n/i) {
			$jobs{"geneSummary"} = "";
		} else {
			die "!!!\n\topt summary no recognized (y/n)";
		}
	} else { $jobs{"geneSummary"} = 1; }
}
if (exists $opt{keepCov}) { $jobs{"keepCov"} = 1; }

## new bed names
=pod
my $keepBedName = "";
if ($bedName) {
	$keepBedName = $bedName;
} else {
	$keepBedName = "allID";
}
=cut
my $keepBedName = "intervals";
my $keepBedDir = ".";
if (exists $opt{keepBed}) {
	$jobs{"keepBed"} = 1;
	if ($opt{keepBed}) { 
		#$keepBedName = $opt{keepBed};
		#$keepBedName =~ s/\.bed$//;
		my($name,$dir) = fileparse($opt{keepBed},".bed");
		if ($name) { $keepBedName = $name; }
		if ($dir) {
			if (-d $dir) {
				$keepBedDir = $dir;
			} else {
				die "!!!\n\t$dir not found\n";
			}
		}
	}
	if (-f "$keepBedDir/$keepBedName.bed") { die "!!!\n\t$keepBedDir/$keepBedName.bed already exists\n"; }
}

my $keepTmpBedName = "";
if ($bedName) {
	$keepTmpBedName = "$bedName.forDepth";
} else {
	$keepTmpBedName = "intervals.forDepth";
}
my $keepTmpBedDir = ".";
if (exists $opt{keepTmpBed}) {
	$jobs{"keepTmpBed"} = 1;
	if ($opt{keepTmpBed}) { 
		my($name,$dir) = fileparse($opt{keepTmpBed},".bed");
		if ($name) { $keepTmpBedName = $name; }
		if ($dir) {
			if (-d $dir) {
				$keepTmpBedDir = $dir;
			} else {
				die "!!!\n\t$dir not found\n";
			}
		}
	}
	if (-f "$keepTmpBedDir/$keepTmpBedName.bed") {
		die "!!!\n\t$keepTmpBedDir/$keepTmpBedName.bed already exists\n";
	}
}

##refseq gene analysis param
my(@Thresholds,$pThreshold);
if (exists $opt{printThreshold}) {
	$pThreshold = $opt{printThreshold};
}
if (exists $opt{depthThreshold}) {
	@Thresholds = split(/,/, join(',',@{$opt{depthThreshold}}));
	foreach (@Thresholds) {
		if ($_ =~ /^\d+$/) {
			next;		#{ print "depth threshold: $_\n"; }
		} else {
			die "!!!\n\t$_ depth threshold value need to be an integer\n";
		}
	}
	@Thresholds = sort{$b<=>$a}@Thresholds;	#decroissant
	#check if $pThreshold one of those in @Thresholds
	if ($pThreshold) {
		my $ok=0;
		foreach (@Thresholds) {
			if ($pThreshold==$_) {
				$ok = 1;
				last;
			}
		}
		unless ($ok) {
			die "!!!\n\topt -T threshold value need to be 1 of those in opt -t\n";
		}
	} else {
		$pThreshold = $Thresholds[-1];
	}
	#print "threshold for summary: $pThreshold \n";
} else { 
	if ($pThreshold) {
		@Thresholds = ($pThreshold);
	}
}
##regions extent
my $wNonCod = "";
if (exists $opt{nonCoding})
	{ $wNonCod = 1; }

my $wUTR = 1;
if (exists $opt{noUTR})
	{ $wUTR = 0; }
my $UTRinTxt = 1;
if (exists $opt{noUTRinTxt})
	{ $UTRinTxt = 0; }
if ($wNonCod && (!$wUTR || !$UTRinTxt))
	{ die "!!!\n\tnonCoding inclusion not compatible with UTR exclusion\n"; }

my $maxGr = ""; #max depth for graphs
if (exists $opt{maxDepth}) { 
	if ($opt{maxDepth} =~ /^\d+$/) { $maxGr = $opt{maxDepth}; }
	else { die "!!!\n\t--maxCov opt value need to be an integer\n"; }
	}

my $len5 = 0; my $len3 = 0;
if (exists $opt{expand2val}) {
	if ($opt{expand2val} =~ /,/) {
		my @len = split(/,/,$opt{expand2val});
		$len5 = $len[0];
		$len3 = $len[1];
		}
	else {
		$len5 = $opt{expand2val};
		$len3 = $opt{expand2val};
		}
	}

my $splitBedFromId = 0;
if (exists $opt{splitBedFromId}) { $splitBedFromId = 1; }
my $mergeBedFromId = 0;
if (exists $opt{mergeBedFromId}) { $mergeBedFromId = 1; }

my $lenTxt5 = 0; my $lenTxt3 = 0;
if (exists $opt{Ltxt}) {
	if ($opt{Ltxt}) {
		if ($opt{Ltxt} =~ /,/) {
			my @len = split(/,/,$opt{Ltxt});
			$lenTxt5 = $len[0];
			$lenTxt3 = $len[1];
			}
		else {
			$lenTxt5 = $opt{Ltxt};
			$lenTxt3 = $opt{Ltxt};
			}
		}
	else { $lenTxt5 = $len5; $lenTxt3 = $len3; }
	}

my $upstream = 0; my $downstream = 0;
if (exists $opt{UDstream}) {
	if ($wUTR) {
		if ($opt{UDstream} =~ /,/) {
			my @len = split(/,/,$opt{UDstream});
			$upstream = $len[0];
			$downstream = $len[1];
			} else {
			$upstream = $opt{UDstream};
			$downstream = $opt{UDstream};
		}
		if ($upstream <= $len5) { $upstream = 0; }
		if ($downstream <= $len3) { $downstream = 0; }
		#if ($upstream < $len5 || $downstream < $len3)
		#	{ die "upstream/downstream expansion must be longer than padding $upstream <= $len5  $downstream <= $len3\n"; }
	} else {
		die "!!!\n\tupstream/downstream expansion not compatible without UTR\n";
	}
}

my $UpInTxt = 0 ; my $DownInTxt = 0;
if (exists $opt{UDtxt}) {
	if ($opt{UDtxt}) {
		if ($wUTR) {
			if ($opt{UDtxt} =~ /,/) {
				my @len = split(/,/,$opt{UDtxt});
				$UpInTxt = $len[0];
				$DownInTxt = $len[1];
			} else {
				$UpInTxt = $opt{UDtxt};
				$DownInTxt = $opt{UDtxt};
			}
			if ($UpInTxt <= $lenTxt5) { $UpInTxt = 0; }
			if ($DownInTxt <= $lenTxt3) { $DownInTxt = 0; }
			#if ($UpInTxt < $lenTxt5 || $DownInTxt < $lenTxt3)
			#	{ die "upstream/downstream expansion must be longer than padding $UpInTxt <= $lenTxt5 || $DownInTxt <= $lenTxt3\n"; }
		} else {
			die "!!!\n\tupstream/downstream expansion not compatible without UTR\n";
		}
	} else {
		$UpInTxt = $upstream; $DownInTxt = $downstream;
	}
}

my $Expand = "";
if (exists $opt{expand2bed}) {
	$Expand = 1;
}

my $spacer = 0;

my $Rev = 1;
if (exists $opt{noReverse}) {
	$Rev = 0;
}

my $AllTranscripts = 1;		##all transcripts on same graph; no longer disable possibility
if (exists $opt{noEachTranscript}) {
	$AllTranscripts = 0;
}

my $gThreshold = 1;
if (exists $opt{noGraphThreshold}) {
	$gThreshold="";
}

my $nGraf = "max";
if (exists $opt{nGraph} && $opt{nGraph}!=0) {
	$nGraf = $opt{nGraph};
}

## plots param
my $bin = 10; #nber of bin for bar plots
if (exists $opt{binPlot}) {
	$bin = $opt{binPlot};
}
my $maxPl = 100; #max depth for bar plots
if (exists $opt{maxPlot}) {
	$maxPl = $opt{maxPlot};
}
if (($maxPl % $bin) != 0) {
	die "!!!\n\tbinPlot needs to be a multiple of maxPlot\n";
}

##external tools paths and param
my $bedT = "";
if (exists $opt{bedtools}) {
	$bedT = $opt{bedtools};
}
my $samT = "";
if (exists $opt{samtools}) {
	$samT = $opt{samtools};
}
my %gatk = ();
if (exists $opt{gatk3}) {
	$gatk{"version"} = 3; 
	$gatk{"jar"} = $opt{gatk3}; 
}
my $gatk4 = "";
if (exists $opt{gatk4}) { 
	$gatk{"version"} = 4; 
	$gatk{"jar"} = $opt{gatk4}; 
}
my $ram = "";
if (exists $opt{ram}) { 
	$ram = $opt{ram};
}
my $threads = "";
if (exists $opt{cpu}) { 
	$threads = $opt{cpu};
}
my $dedup = "";
if (exists $opt{dedup}) { 
	if ($opt{dedup} eq "do") {
		$dedup = "do";
	} elsif ($opt{dedup} eq "") {
		$dedup = 1;
	} else {
		die "!!!\n\tnot recognized value for --dedup arg.\n";
	}
}
my $mbq = "";
if (exists $opt{mbq}) {
	$mbq = $opt{mbq};
}
my $mmq = "";
if (exists $opt{mmq}) {
	$mmq = $opt{mmq};
}



##bed param
my $lenForBed = 0;
if (exists $opt{Lbed}) {
	if ($opt{Lbed} =~ /^\d+$/) {
		$lenForBed = $opt{Lbed};
	} else {
		die "!!!\n\t--Lbed value need to be an integer\n";
	}
}

my $splitBed = "";
if (exists $opt{split_bed}) { $splitBed = 1; }

my $rmOverlapBed = "";
if (exists $opt{no_overlap_bed}) { $rmOverlapBed = 1; }

my $cutBed = "";
my %cutB_opt = ();
if (exists $opt{cut_bed}) { 
	$cutBed = 1;
	$cutB_opt{"cutL"}=150; $cutB_opt{"maxL"}=150; $cutB_opt{"minL"}=75; $cutB_opt{"keepLast"}="merge";
	if ($opt{cut_bed}) {	## cutL:x,minL:y,maxL:z,keepLast:s
		my @cutB_arg = split(/,/,$opt{cut_bed});
		my $minL=""; my $maxL="";
		foreach my $a (@cutB_arg) {
			my $ok=0;
			foreach my $o (keys%cutB_opt) {
				if ($a =~ /$o:(.+)/) {
					if ($o eq "minL") { $minL=1; }
					if ($o eq "maxL") { $maxL=1; }
					if ($o eq "keepLast") {
						if ($1 =~ /^m/i) { $cutB_opt{"$o"} = "merge";
						} elsif  ($1 =~ /^h/i) {
							$cutB_opt{"$o"} = "half";
						} elsif  ($1 =~ /^n/i) {
							$cutB_opt{"$o"} = "";
						} else {
							die "!!!\n\tcut_bed opt \"keepLast\" not recognized ($1?) (\"h\" , \"m\" or \"n\")\n";
						}
					} else {
						$cutB_opt{"$o"} = $1;
					}
					$ok=1;
				}
			}
			unless ($ok) { die "!!!\n\tcut_bed opt not recognized ($a?)\n"; }
		}
		unless ($minL) { $cutB_opt{"minL"} = int($cutB_opt{"cutL"}/2); }
		unless ($maxL) { $cutB_opt{"maxL"} = $cutB_opt{"cutL"}; }
	}
}
#if ($splitBed && $cutBed) { die "not able to split overlapping and cut long intervals, sorry...\n";}

my %reAnnotBed = ();
if (exists $opt{reAnnot_bed}) {
	if ($opt{reAnnot_bed}) {
		$opt{reAnnot_bed} =~ s/,//g;
		foreach ( split(//,$opt{reAnnot_bed}) ) {
			if ($_ =~ /g|t|e|i|o/i) {
					$reAnnotBed{"item"}{lc($_)} = 1;
			} else {
				die "\n!!!\topt --reAnnot_bed value not recognized (comma separated g/t/e/i/o)\n";
			}
		}
	} else {
		foreach ("g","t","e","i","o") {
			$reAnnotBed{"item"}{$_} = 1;
		}
	}
}

my @covFields =(); 
if ($pThreshold) { @covFields = ("min","mean","cov"); }
else { @covFields = ("min","mean","tot"); }
my %covFieldList = ("min"=>1,"max"=>1,"tot"=>1,"mean"=>1,"median"=>1,"cov"=>1);
if (exists $opt{cov_fields}) {
	@covFields = split(/,/, join(',',@{$opt{cov_fields}}));
	foreach (@covFields) {
		unless (exists $covFieldList{$_}) { die "\n!!!\tcov field not recognized (min,max,tot,mean,median,cov)\n"; }
	}
}

## CNV param
my %CNV_opt;
$CNV_opt{"center"} = "med";
if (exists $opt{spread2}) { $CNV_opt{"center_test"} = 0; }
else { $CNV_opt{"center_test"} = 1; }
if (exists $opt{level2}) {
	if ($opt{level2} =~ /^avg/i) { $CNV_opt{"center"} = "avg"; }
	elsif ($opt{level2} =~ /^med/i) { $CNV_opt{"center"} = "med"; }
	else { die "\n!!!\topt --level2 not recognized (avg/med)\n"; }
	$CNV_opt{"center_test"} = 1;
	}
if (exists $opt{spread2}) {
	if ($opt{spread2} =~ /^std/i) {
		$CNV_opt{"spread"} = "std";
		$CNV_opt{"center"} = "avg";
	} elsif ($opt{spread2} =~ /^q/i) {
		$CNV_opt{"spread"} = "Qtile";
		$CNV_opt{"center"} = "med";
	} else {
		die "\n!!!\topt --spread2 not recognized (std/qtile)\n";
	}
	$CNV_opt{"spread_test"} = 1;
}
$CNV_opt{"seuil_del"} = 0.8;
if (exists $opt{level_del}) { $CNV_opt{"seuil_del"} = $opt{level_del}; }
$CNV_opt{"seuil_dup"} = 1.2;
if (exists $opt{level_dup}) { $CNV_opt{"seuil_dup"} = $opt{level_dup}; }
if (exists $opt{spread_del}) { $CNV_opt{"spread_del"} = $opt{spread_del}; }
if (exists $opt{spread_dup}) { $CNV_opt{"spread_dup"} = $opt{spread_dup}; }
if (exists $opt{range}) { $CNV_opt{"range"} = $opt{range}; }
if (exists $opt{highQual}) {
	my @tab1 = split(/,/,$opt{highQual});
	foreach my $string (@tab1) {
		my @tab2 = split(/:/,$string);
		if ($tab2[0] =~ /^li/i) {
			$CNV_opt{"trueCNV"}{"level"}{"del"} = $tab2[1];
		} elsif ($tab2[0] =~ /^ls/i) {
			$CNV_opt{"trueCNV"}{"level"}{"dup"} = $tab2[1];
		} elsif ($tab2[0] =~ /^si/i) {
			$CNV_opt{"trueCNV"}{"spread"}{"del"} = $tab2[1];
		} elsif ($tab2[0] =~ /^ss/i) {
			$CNV_opt{"trueCNV"}{"spread"}{"dup"} = $tab2[1];
		} elsif ($tab2[0] =~ /^c/i) {
			$CNV_opt{"trueCNV"}{"conseC"} = $tab2[1];
		} else {
			die "\n!!!\topt --highQual not recognized (li/ls/si/ss/c)\n";
		}
	}
}
$CNV_opt{"seuil_region"} = 1;
if (exists $opt{ex_region}) { $CNV_opt{"seuil_region"} = $opt{ex_region}; }
$CNV_opt{"seuil_patient"} = 1;
if (exists $opt{ex_sample}) { $CNV_opt{"seuil_patient"} = $opt{ex_sample}; }
if (exists $opt{ex_cov}) { $CNV_opt{"seuil_cov"} = $opt{ex_cov}; }
$CNV_opt{"min_DP"} = 0;
if (exists $opt{ex_DP}) { $CNV_opt{"min_DP"} = $opt{ex_DP}; }
$CNV_opt{"min_following_CNV"} = "";
#if (exists $opt{min_CNV}) { $CNV_opt{"min_following_CNV"} = $opt{min_CNV}; }
$CNV_opt{"max_Non_CNV"} = "";
if (exists $opt{max_nonCNVcons}) { $CNV_opt{"max_Non_CNV"} = $opt{max_nonCNVcons}; }
$CNV_opt{"max_Non_CNV_rate"} = "";
if (exists $opt{max_nonCNVrate}) { $CNV_opt{"max_Non_CNV_rate"} = $opt{max_nonCNVrate}; }
$CNV_opt{"ratioByGender"} = "";
if (exists $opt{ratioByGender}) {
	if ($opt{ratioByGender}=~/^a/i) {
		$CNV_opt{"ratioByGender"} = "all";
	} elsif ($opt{ratioByGender}=~/^g/i) {
		$CNV_opt{"ratioByGender"} = "gono";
	} elsif ($opt{ratioByGender}=~/^n/i) {
		$CNV_opt{"ratioByGender"} = "";
	} else {
		die "\n!!!\topt --ratioByGender not recognized (a/g/n)\n";
	}
}
$CNV_opt{"RefDepth"} = "mean";
if (exists $opt{normDepth}) {
	if ($opt{normDepth}=~/^m/i) {
		$CNV_opt{"RefDepth"} = "mean";
	} elsif ($opt{normDepth}=~/^t/i) {
		$CNV_opt{"RefDepth"} = "tot";
	} else {
		die "\n!!!\topt --normDepth not recognized (mean/tot)\n";
	}
}
$CNV_opt{"RefNoChrY"} = 1;
if (exists $opt{normAllChr}) { $CNV_opt{"RefNoChrY"} = ""; }
$CNV_opt{"geneGraph"} = "";
if (exists $opt{graph_byGene} && ($opt{graph_byGene} eq "" || $opt{graph_byGene}=~/^y|o/i)) { $CNV_opt{"geneGraph"} = 1; }
if ($bed_cov_file && !$raw_cov_file) { $CNV_opt{"geneGraph"} = ""; }
$CNV_opt{"chromGraph"} = "";
if (exists $opt{graph_byChr} && ($opt{graph_byChr} eq "" || $opt{graph_byChr}=~/^y|o/i)) { $CNV_opt{"chromGraph"} = 1; }
$CNV_opt{"CNVgraph"} = 1;
if (exists $opt{graph_byCNV}) {
	if ($opt{graph_byCNV} eq "" || $opt{graph_byCNV}=~/^y|o/i) {
		$CNV_opt{"CNVgraph"} = 1;
	} elsif ($opt{graph_byCNV}=~/^n/i) {
		$CNV_opt{"CNVgraph"} = "";
	}
}
@{ $CNV_opt{"fields"} } = ();
if (exists $opt{CNV_fields}) {
	@{ $CNV_opt{"fields"} } = split(/,/, join(',',@{$opt{CNV_fields}}));
	my %CNVfieldList = ("min"=>1,"max"=>1,"med"=>1,"avg"=>1,"std"=>1,"Q1"=>1,"Q3"=>1);
	foreach (@{ $CNV_opt{"fields"} }) {
		unless (exists $CNVfieldList{$_}) {
			die "\n!!!\t$_ CNV field not recognized (min,max,norm)\n";
		}
	}
}
$CNV_opt{"switch2graphByCNV"} = 250;
$CNV_opt{"maxGeneLab"} = 200;
$CNV_opt{"maxGeneSep"} = 500;
$CNV_opt{"maxLabelLgth"} = 25;
$CNV_opt{"graphCNVpadding"} = 4;
$CNV_opt{"maxDepthGraph"} = 10;
$CNV_opt{"ploidy"} = 2;




##opt warnings according to actions 

#unless (exists $opt{file} || exists $opt{dir}) { die "requires a list of bam files to analysed (opt -f), or a directory where to find such files (opt -d)\n"; }
if ($bed_cov_file) {
	$jobs{"CNV"} = 1;
	if ( $jobs{"graphSum"}
		|| $jobs{"graphAllSampls"}
		|| $jobs{"graphBySample"}
		|| $jobs{"geneSummary"}
		|| $jobs{"geneReport"}
		|| $jobs{"covPlot"}
		|| $jobs{"genePlot"}
		|| $jobs{"interSplot"}
		|| $jobs{"covBed"}
		|| $jobs{"covMut"} ) {
		die "\n!!!\tactions other than CNV_detect not allowed if .cov.txt file provided\n";
	}
}
if ($jobs{"CNV"} && !$bed_cov_file) {
	$jobs{"covBed"} = 1;
}

if ($jobs{"bedReport"} || $jobs{"2Reseq"}) {
	$jobs{"covBed"} = 1;
}

if ($jobs{"graphSum"}
	|| $jobs{"graphAllSampls"}
	|| $jobs{"graphBySample"}
	|| $jobs{"geneSummary"}
	|| $jobs{"geneReport"}
	|| $jobs{"covPlot"}
	|| $jobs{"genePlot"}
	|| $jobs{"interSplot"}
	|| $jobs{"covBed"}
	|| $jobs{"covMut"}) {
	if (!@Files && !$raw_cov_file) { die "\n!!!\tno .bam files (or coverage file) provided\n"; }
}

if ($raw_cov_file) { $jobs{"keepCov"} = ""; }

#unless ($mutFile || ($jobs{"CNV"} && $bed_cov_file)) {
if ($jobs{"graphSum"}
	|| $jobs{"graphAllSampls"}
	|| $jobs{"graphBySample"}
	|| $jobs{"geneSummary"}
	|| $jobs{"geneReport"}
	|| $jobs{"covPlot"}
	|| $jobs{"genePlot"}
	|| $jobs{"interSplot"}
	|| $jobs{"covBed"}) {
	unless ($bedFile || @IDs) {
		die "\n!!!\t.bed file (opt -b) or list of genes or transcripts id required (opt -i/-I)\n";
	}
}

unless (@Thresholds) {
	if ($jobs{"graphSum"} || $jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"} || ($jobs{"CNV"} && $CNV_opt{"seuil_cov"})) { die "\n!!!\tat least 1 threshold value required (opt -t)\n"; }
	if ($jobs{"covBed"}) {
		foreach(@covFields) {
			if ($_ eq "cov") { die "\n!!!\tat least 1 threshold value required (opt -t)\n"; }
		}
		if ($jobs{"bedReport"})  { die "\n!!!\tat least 1 threshold value required (opt -t)\n"; }
	}
}

if ( $jobs{"graphSum"}
	|| $jobs{"graphAllSampls"}
	|| $jobs{"graphBySample"}
	|| $jobs{"genePlot"}
	|| ($jobs{"CNV"} && $CNV_opt{"geneGraph"})
	|| ($bedFile && %reAnnotBed)
	|| @IDs
	|| $jobs{"keepTmpBed"} ) {
	unless ($refFile) { die "\n!!!\tRefSeq file required (opt -r)\n"; } 
}

unless ( $jobs{"graphSum"}
		|| $jobs{"graphAllSampls"}
		|| $jobs{"graphBySample"}
		|| $jobs{"geneSummary"}
		|| $jobs{"geneReport"}
		|| $jobs{"covPlot"}
		|| $jobs{"genePlot"}
		|| $jobs{"interSplot"}
		|| $jobs{"covBed"}
		|| $jobs{"CNV"}
		|| $jobs{"covMut"}
		|| $jobs{"keepCov"}
		|| $jobs{"keepBed"}
		|| $jobs{"keepTmpBed"} ) {
	die "\n!!!\tno job selected!\n";
}

$jobs{"with_DephFile_Required"} = "";
if ( $jobs{"graphSum"} 
	|| $jobs{"graphAllSampls"} 
	|| $jobs{"graphBySample"} 
	|| $jobs{"geneSummary"} 
	|| $jobs{"geneReport"} 
	|| $jobs{"covPlot"} 
	|| $jobs{"genePlot"} 
	|| $jobs{"interSplot"} 
	|| $jobs{"covBed"} 
	|| $jobs{"covMut"} ) {
	$jobs{"with_DephFile_Required"} = 1;
}

$jobs{"output_dir_2_keep"} = "";
if ( $jobs{"with_DephFile_Required"} || $jobs{"CNV"} ) {
	$jobs{"output_dir_2_keep"} = 1;
}

$jobs{"with_gene_coordinates_required"} = "";
if ($jobs{"graphSum"} 
	|| $jobs{"graphAllSampls"} 
	|| $jobs{"graphBySample"} 
	|| $jobs{"genePlot"} 
	|| $jobs{"geneSummary"} 
	|| $jobs{"geneReport"} 
	|| $jobs{"keepTmpBed"} 
	|| ($jobs{"CNV"} && $CNV_opt{"geneGraph"}) ) {
	$jobs{"with_gene_coordinates_required"} = 1;
}


###################
#check progr installation and db existence
print "\n\n####\n\nchecking dependencies\n\n####\n";

#genome index
my(@chromOrder,%chromName,%chromLength,%withChr);		#%faIdx
if ($genom) {
	if (-e "$genom.fai") {
		#@chromLength = `cut -f1-2 $genom.fai`;
		#chomp @chromLength;
		open(my $fh, '<', "$genom.fai") or die "\n!!!\tcannot open $genom.fai\n";
		while (my $line = <$fh>) {
			my @tab = split(/\t/,$line);
			my $chr = $tab[0];
			$chr =~ s/^chr//i;
			$chromName{"fasta"}{$chr} = $tab[0];
			push(@chromOrder,$chr);
			$chromLength{$chr} = $tab[1];
		}
		close $fh;
	}
}

#progr
my(%pathCmd);
use File::Which;

#check R
if ($jobs{"graphSum"} 
 || $jobs{"graphAllSampls"} 
 || $jobs{"graphBySample"} 
 || $jobs{"covPlot"} 
 || $jobs{"genePlot"} 
 || $jobs{"interSplot"} 
 || $jobs{"CNV"} 
 || $jobs{"covMut"}) {
	$pathCmd{"R"} = which('R');
	if ($pathCmd{"R"}) {
		print "\tR tools OK\n";
	} else {
		die "\n!!!\tR tools not installed or not found\n";
	}
}

##sName: name of sample in bam file (unless samtools: name of file without extension)
##sName2: not redundant name of sample
my(%sName,%sName2,$smplIdx,%bamHeaders);
my $bedTversion = ""; 

if ( $jobs{"with_DephFile_Required"} && !$raw_cov_file ) {
	##check external softwares:
	##samtools
	if ($samT) {
		#system "$samT"; #write the name of calling script of picard #> /dev/null 2>&1
		$pathCmd{$samT} = which($samT);
		if ($pathCmd{$samT}) {
			print "\tsamtools OK\n";
		} else {
			die "\n!!!\t$samT samtools bin file not found\n";
		}
	} else {
		$samT = "samtools";
		$pathCmd{$samT} = which($samT);
		if ($pathCmd{$samT}) {
			print "\tsamtools OK\n";
		} else {
			$samT = "";
		}
	}	
	##gatk
	## gatk == 1 if want to use gatk; so that test for existing command won't be evaluated if don't want to use it
	#if ($mbq && !$gatk) { $gatk = 1; }
	if (%gatk) {
		if (-f $gatk{"jar"}) {
			if ($ram) {
				$gatk{"exec"} = "java -jar -Xmx$ram"."g ".$gatk{"jar"};	#-Djava.io.tmpdir=$tmpDir
			} else {
				$gatk{"exec"} = "java -jar ".$gatk{"jar"}; }
			print "\tGATK OK\n";
		} else {
			die "\n!!!\t".$gatk{"jar"}." GATK .jar file not found\n";
		}
		foreach (@Files) { $smplIdx->{$_} = ""; }	#to initialize
	} else {
	##bedtools
		if ($bedT) {
			#system "$bedT";
			$pathCmd{$bedT} = which($bedT);
			if ($pathCmd{$bedT}) {
				print "\tbedtools OK\n";
			} else {
				die "\n!!!\t$bedT bedtools bin file not found\n";
			}
		} else {
			$bedT = "bedtools";
			$pathCmd{$bedT} = which($bedT);
			if ($pathCmd{$bedT}) {
				print "\tbedtools OK\n";
			} else {
				die "\n!!!\tbedtools exec not found in \$PATH\n";
			}
		}
		if ($bedT) {
			$bedTversion = `$bedT --version`;
			$bedTversion =~ /^bedtools v(\d+)\.(\d+)/;
			if ( ($1 < 2) || ($1 == 2 && $2 < 24) ) {
				$bedTversion = 1;
			} else	{
				$bedTversion = 2;
			}
		}
	}
	##softwares requirements according to options and actions:
	if ($mbq && !%gatk) {
		die "\n!!!\tGATK required for min base quality filter\n";
	}
	if ($mmq && !%gatk) {
		die "\n!!!\tGATK required for min mapping quality filter\n";
	}
	#if ($jobs{"CNV"} && ($CNV_opt{"RefDepth"} eq "tot") && !$samT) { die "samtools not installed or not found\n"; }
	#if ($dedup eq "do" && !$picard) { die "\n!!!\tpicard tools not installed or not found (required for discarding duplicates)\n"; }
	if (!$bedT && !%gatk) { die "\n!!!\tbedtools or GATK required\n"; }

	##find sample names in bam
	##sName: name of sample in bam file ; sName2: not redundant name of sample (cat with ID if several exists)
	if ($samT) {
		my %allID;
		foreach my $f (@Files) {
			# @RG	ID:id	SM:sample	LB:lb	PL:Illumina	PU:pu
			@{ $bamHeaders{$f} } = `$samT view -H $f`;
			my @RGs = grep(/^\@RG/, @{ $bamHeaders{$f} });
			$RGs[0] =~ /\tID:(.+?)(\t|\n)/;
			my $ID = $1;
			$RGs[0] =~ /\tSM:(.+?)(\t|\n)/;
			my $SM = $1;
			if (exists $allID{$SM}) {
				$sName{$f} = $SM;
				$sName2{$f} = $SM."_".$ID;
				foreach (@{ $allID{$SM} })
					{ $sName2{$_} = $SM."_".$ID; }
			} else {
				$sName{$f} = $SM;
				$sName2{$f} = $SM;
			}
			push(@{ $allID{$SM} },$f);
		}
	} else {
		foreach (@Files) {
			$sName{$_} = $fName{$_};
			$sName2{$_} = $fName{$_};
		}
	}
	#sort @Files according to %sName2 lexical order
	@Files = (sort {$sName2{$a} cmp $sName2{$b}} (keys %sName2));
	if (@Files) {
		#bam index
		if ($samT) {
			foreach my $file (@Files) {
				unless (-e "$file.bai") {
					my $cmd = "$samT index $file";
					print "$cmd\n";
					system "$cmd";
				}
			}
		}
		#@chromOrder from 1st bam, if not already set
		unless (@chromOrder) {
			if (%bamHeaders) {
				foreach my $file (keys%bamHeaders) {
					## @SQ	SN:chr1	LN:249250621
					my @SQs = grep(/^\@SQ/, @{ $bamHeaders{$file} });
					foreach my $sq (@SQs) {
						$sq =~ /\tSN:(.+?)\tLN:(\d+)\n/;
						my $chrName = $1; my $len = $2;
						my $chr = $chrName; $chr =~ s/^chr//i;
						$chromName{"fasta"}{$chr} = $chrName;
						push(@chromOrder, $chr);
						$chromLength{$chr} = $len;
					}
					last;
				}
			}
		}
	}
	## check requirement for genome.fa and genome.fa.fai
	if (%gatk) {
		unless ($genom) { die "\n!!!\treference genome.fa required\n"; }
		unless (-e "$genom.fai") { die "\n!!!\tindex genome.fa.fai required (\"samtools faidx genome.fa\")\n"; }
	} else {
		if ($bedTversion == 2) {
			unless (%chromLength) { die "\n!!!\tindex genome.fa.fai required (to generate chomLength file for bedtools2)\n"; }
		}
	}
}
## check for "chr" in chrom names, for depth analysis
if (@chromOrder) {
	if ($chromName{"fasta"}{$chromOrder[0]} =~ /^chr/i) {
		$withChr{"all"} = "_wChr.bed";
		foreach (@Files) { $withChr{$_} = "_wChr.bed"; } 
	} else {
		$withChr{"all"} = "_0Chr.bed";
		foreach (@Files) { $withChr{$_} = "_0Chr.bed"; } 
	}
}


#create output dirs

use POSIX qw(strftime);
my $outdir = "";
my $tmpDir = "";
my $chromLength = "";
my @tmpFiles = (); ##tmp files to rm when ends
if ($jobs{"output_dir_2_keep"} || $jobs{"keepTmpBed"}) {	# an output dir is always created; if the one specified already exists, another is created within
	if (exists $opt{outdir}) { 
		$outdir = $opt{outdir}; 
		$outdir =~ s/\/$//;
		if (-d $outdir) {
			if ($jobs{"CNV"} && $bed_cov_file) {
				$outdir .= "/CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime);
			} else {
				$outdir .= "/covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime);
			}
		}
	} else {
		if ($jobs{"CNV"} && $bed_cov_file) {
			$outdir = "CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime);
		} else {
			$outdir = "covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime);
		}
	}
	mkdir($outdir);
	$tmpDir = "$outdir/tmp_files";
	mkdir($tmpDir);
} else {
	if (exists $opt{outdir}) { 
		$outdir = $opt{outdir}; 
		$outdir =~ s/\/$//;
		unless (-d $outdir) { mkdir($outdir); }
	} else {
		$outdir = ".";
	}
}

my $depthFilePerChr = {};
if ($raw_cov_file) {
	print "\n\n####\n\nreading $raw_cov_file\n\n####\n";
	my $fhIn;
	if ($raw_cov_file =~ /.gz$/) {
		use IO::Zlib;
		$fhIn = new IO::Zlib;
		$fhIn->open($raw_cov_file, "rb")
	} else {
		open($fhIn, "<", $raw_cov_file) or die "\n!!!\tcould not read $raw_cov_file ($!)\n";
	}
	## gets sample names
	print "\n\tgetting sample names\n";
	my $firstLine = <$fhIn>;
	chomp $firstLine;
	my @tab = split(/\t/,$firstLine);
	for my $i (0..$#tab) {
		if ($tab[$i] =~ /^Depth_for_(.+)/) {
			my $smpl = $1;
			push(@Files,$smpl);
			$fName{$smpl} = $smpl;
			$sName2{$smpl} = $smpl;
			$smplIdx->{$smpl} = $i;
		}
	}
	unless (@Files) { die "\n!!!\tnot able to find sample names in $raw_cov_file\nmissing header line?\n"; }
	## gets @chromOrder, writes to depthFilePerChrom
	print "\n\tgetting chrom Order and writting to depthFilePerChr\n";
	my $currentChr = "";
	my $fhChr;
	my $getChromOrder = "";
	unless (@chromOrder) { $getChromOrder = 1; }
	my %allChr = ();
	while (my $line = <$fhIn>) {
		$line =~ /^(\w+):\d+\t/;
		my $chrName = $1;
		my $chr = $chrName; $chr =~ s/^chr//i;
		if ($chr ne $currentChr) {
			if ($getChromOrder && !exists $allChr{$chr}) {
				$chromName{"fasta"}{$chr} = $chrName;
				push(@chromOrder,$chr);
				$allChr{$chr} = 1;
			}
			if ($currentChr ne "") { close $fhChr; }
			$currentChr = $chr;
			${$depthFilePerChr}{"raw"}{$chr} = "$tmpDir/$chr"."_cov.txt";
			open($fhChr, ">", ${$depthFilePerChr}{"raw"}{$chr}) || die "\n!!!\tcould not create ".${$depthFilePerChr}{"raw"}{$chr}." ($!)\n";
		}
		if (defined $fhChr) {
			$line =~ s/^\w+://;
			print $fhChr $line;
		}
	}
	close $fhChr; close $fhIn;
} else {
	if ( $jobs{"with_DephFile_Required"} && !%gatk && $bedTversion == 2) {
		if (%chromLength) {
			$chromLength = "$tmpDir/chromLength.txt";		#used by bedtools
			open (my $fhOut, ">", "$chromLength");
			foreach (@chromOrder) { print $fhOut $chromName{"fasta"}{$_}."\t$chromLength{$_}\n"; }
			close $fhOut;
		}
	}
}

#read sex file, just to check existing sample names
if ($fichier_sexe && scalar(keys%sName2)>0) {
	print "\n\tchecking that all sample names in $fichier_sexe are those found in bam files\n";
	open(my $fh, "<", $fichier_sexe) or die "\n!!!\tcannot read $fichier_sexe ($!)\n";
	while (my $line = <$fh>) {
		if ($line =~ /(\S+)(\s*:*\s+|\s+:*\s*|\s*:\s*)\S+/) {
			my$smpl = $1;
			my $ok = "";
			foreach my $file (@Files) {
				if ($smpl eq $sName2{$file}) {
					$ok = 1; last;
				}
			}
			unless ($ok) { die "\n!!!\tsample $smpl not found in bam files\n"; }
		}
	}
	close $fh;
}

if ($jobs{"graphBySample"} || $jobs{"geneReport"} || $jobs{"bedReport"}) { 
	foreach (@Files) { mkdir("$outdir/cov\_$sName2{$_}"); }
}

if ($jobs{"graphAllSampls"} || $jobs{"graphSum"}) { mkdir("$outdir/cov_All"); }

if ($jobs{"keepBed"}
	&& !$jobs{"graphSum"}
	&& !$jobs{"graphAllSampls"}
	&& !$jobs{"graphBySample"}
	&& !$jobs{"geneSummary"}
	&& !$jobs{"geneReport"}
	&& !$jobs{"covPlot"}
	&& !$jobs{"genePlot"}
	&& !$jobs{"interSplot"}
	&& !$jobs{"covBed"}
	&& !$jobs{"CNV"}
	&& !$jobs{"covMut"}) {
	unless (exists $opt{outdir}) { $outdir = $keepBedDir; }
	$bedName = $keepBedName;
}





###################
##Job 1:find coordinates (from genes, transcripts, bed_file, mut_file)



## if ID list provided : parse lines of RefSeq matching each $id of @ID in $IDinRef ref hash
my($IDinRef,$ALLinRef);
if (@IDs) {
	print "\n\n####\n\nselecting lines within $refFile matching provided gene/transcript IDs\n\n####\n";
	if ($refFmt eq "ucsc") {
		$IDinRef = DeCovA::refIDs::UCSC2Ids($refFile,\@IDs,\%chromName,$wNonCod);
	} elsif ($refFmt eq "gtf") {
		$IDinRef = DeCovA::refIDs::GTF2Ids($refFile,\@IDs,\%chromName,$wNonCod);
	} elsif ($refFmt eq "gff3") {
		$IDinRef = DeCovA::refIDs::GFF2Ids($refFile,\@IDs,\%chromName,$wNonCod);
	}
}



## if bedFile provided:
my($bed_Intervals,$mergedBed_Intervals);		##bed in %hash : $Bed{$chr}{$start} = $end , in 1-based
if ($bedFile) {
	print "\n\n####\n\nprocessing $bedFile\n\n####\n";
	my $currentBed = "$bedFile";
	DeCovA::bedProcessing::getChrNameInBed($bedFile,\@chromOrder,\%chromName);
	if ($lenForBed) {
		print "\n\tadding $lenForBed bp to $currentBed intervals ends\n";
		my $expandedBed = "$outdir/$bedName";
		$expandedBed =~ s/.bed$//;
		$expandedBed .= "_w$lenForBed.bed";
		DeCovA::bedProcessing::addLength2Bed($currentBed,$expandedBed,$lenForBed);
		$currentBed = $expandedBed;
	}
	if (%reAnnotBed) {
		print "\n\tre-annotating intervals of $currentBed with $refFile\n";
		$reAnnotBed{"file"} = "$outdir/$bedName";
		$reAnnotBed{"file"} =~ s/.bed$//;
		$reAnnotBed{"file"} .= "_ann.bed";
		if ($IDinRef) {
			my $ref_0based =  DeCovA::refIDs::refHash2Transcripts($IDinRef,$refFmt);
			DeCovA::bedProcessing::reAnnotBed3($currentBed,\%reAnnotBed,$ref_0based,\@chromOrder,\%chromName,$wNonCod);
		} else {
			$ALLinRef = DeCovA::refIDs::ref2Hash($refFile,$refFmt,\%chromName);
			my $ref_0based =  DeCovA::refIDs::refHash2Transcripts($ALLinRef,$refFmt);
			DeCovA::bedProcessing::reAnnotBed3($currentBed,\%reAnnotBed,$ref_0based,\@chromOrder,\%chromName,$wNonCod);
		}
		unless ($currentBed eq $bedFile) { unlink $currentBed; }
		$currentBed = $reAnnotBed{"file"};
	}
	if ( $jobs{"graphSum"} 
		|| $jobs{"graphAllSampls"} 
		|| $jobs{"graphBySample"} 
		|| $jobs{"geneSummary"} 
		|| $jobs{"geneReport"} 
		|| $jobs{"covPlot"} 
		|| $jobs{"genePlot"} 
		|| $jobs{"interSplot"} 
		|| $jobs{"covBed"} 
		|| $jobs{"covMut"} 
		|| $jobs{"keepTmpBed"} ) {
		#transform in 1-based coord; keep longest intervals
		$bed_Intervals = DeCovA::bedProcessing::readBed($currentBed);
		#merge overlapping intervals
		$mergedBed_Intervals = mergeIntervals($bed_Intervals);
		#print merged bed, for depth analysis
		DeCovA::bedProcessing::printBed("$tmpDir/original",$mergedBed_Intervals,\@chromOrder);
	}
	#eventually slice bed intervals : split_Bed, rm_Overlap_Bed, cut_Bed
	my $currentBed2 = DeCovA::bedProcessing::sliceBedIntervals($currentBed,"$outdir/$bedName",$splitBed,$rmOverlapBed,$cutBed,\%cutB_opt,\@chromOrder,\%chromName);
	if ($currentBed2 ne $bedFile) {
		if ($currentBed ne $currentBed) { unlink $currentBed; }
		if ( $opt{keepBed} 
			&& !$jobs{"graphSum"} 
			&& !$jobs{"graphAllSampls"} 
			&& !$jobs{"graphBySample"} 
			&& !$jobs{"geneSummary"} 
			&& !$jobs{"geneReport"} 
			&& !$jobs{"covPlot"} 
			&& !$jobs{"genePlot"} 
			&& !$jobs{"interSplot"} 
			&& !$jobs{"covBed"} 
			&& !$jobs{"CNV"} 
			&& !$jobs{"covMut"} ) {
			my $outBed = "$outdir/$bedName"; $outBed =~ s/.bed$//; $outBed .= ".bed";
			use File::Copy qw(move);
			move($currentBed2, "$outBed") or die "\n!!!\tmove failed: $!";
			$currentBed2 = "$outBed";
		}
	}
	$bedFile = $currentBed2;
}


## if file of known mutations provided (in 1-based coordinates)
my($Mut);
if ($mutFile) {
	print "\n## reading $mutFile\n\n"; 
	$Mut = DeCovA::bedProcessing::readMut($mutFile,\%chromName);		## ${$Mut}{$chr}{$startMut} = $infoMut	; (1-based coord)
}


## find and design transcripts:
my(@hashSub,$geneNM_r,$NMgene_r,$NMchr_r,$NMsens_r,%NMstartCod,%NMendCod,%Regions,$txtRegions_r,%NM_Ex,$txt_NM_Ex_r,$Genes_r,%RegBed,%NMlength,%intron,%UTR,%Cod,%RegMut,$ref_Intervals,$id2Bed);	#	$NMstartCod{"raw"}->{} %{ ${$NMstartCod_r}{"raw"} }

if ( $jobs{"with_gene_coordinates_required"} || (@IDs && !$bedFile) ) {

	print "\n\n####\n\nprocessing intervals to analyse\n\n####\n";

	use DeCovA::geneRegion;

	## if no list of genes/transcripts provided, finds transcripts overlapping at least partially with bed intervals
	unless ($IDinRef) {
		$IDinRef = DeCovA::refIDs::bed2IDs($ALLinRef,$refFile,$refFmt,$mergedBed_Intervals,\%chromName,$wNonCod);
		#undef $ALLinRef;
	}

	## for list of genes/transcripts, extract foreach NM_id starts and ends of each coding exons
	##and transform in 1-based coordinates
	print "\n\tgetting positions from gene IDs\n";
	print "\t\tfor graph regions\n";
	@hashSub = DeCovA::refIDs::Id2Coord($IDinRef,$len5,$len3,$upstream,$downstream,$splitBedFromId,$mergeBedFromId,$wUTR,$id2Bed,\@chromOrder,\%chromName);
	#($geneNM_r, $NMgene_r, $NMchr_r, $NMsens_r, $NMstartCod{"raw"}, $NMendCod{"raw"}, $Regions{"raw"}, $NM_Ex{"raw"}, $Genes_r) = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$splitBedFromId,$mergeBedFromId,$wNonCod,$wUTR,$id2Bed,\@chromOrder);
	#return (\%geneNM,\%NMgene,\%NMchr,\%NMsens,\%NMstartCod,\%NMendCod,\%Regions,\%NM_Ex,\%Genes,\%Bed);
	$geneNM_r = $hashSub[0];		# @{ $geneNM{$gene} } = [$NM1,...]
	$NMgene_r = $hashSub[1];		# $NMgene{$NM} = $gene;
	$NMchr_r = $hashSub[2];			# %NMchr : key = NM, value = chr
	$NMsens_r = $hashSub[3];		# %NMsens : key = NM, value = "+" or "-"
	$NMstartCod{"raw"} = $hashSub[4];		# ${$NMstartCod_r}{"raw"} = $hashSub[4];		# %NMstartCod : key = NM, value = start of coding sequence
	$NMendCod{"raw"} = $hashSub[5];		# ${$NMendCod_r}{"raw"} = %{$hashSub[5]};		# %NMendCod : key = NM, value = end of coding sequence
	$Regions{"raw"} = $hashSub[6];		# $Regions{chr}{NM}{start of region} = end of region
	$NM_Ex{"raw"} = $hashSub[7];		# %NM_Ex{NM}{start of region}{start of exon} = end of exon
	$Genes_r = $hashSub[8]; 
	unless ($bedFile) { 			#-> bed from id's locations
		$bed_Intervals = $hashSub[9];		# $Bed{$chr}{$start} = $end; 
		mergeIntervalsInRef($bed_Intervals);
		}
=pod
		foreach my $chr(sort(keys%{$Regions{"raw"}})) {
			foreach my $NM (sort(keys%{ $Regions{"raw"}{$chr} })) {
				foreach my $startR (sort{$a<=>$b}keys%{  $Regions{"raw"}{$chr}{$NM} })
					{ print $chr."\t".$NM."\t".$startR."\t". $Regions{"raw"}{$chr}{$NM}{$startR}."\n"; }
				}
			}
=cut
	## for summary txt file:
	print "\t\tfor txt regions\n";
	if (($jobs{"keepBed"} || $jobs{"covBed"} || $jobs{"CNV"}) && (!$bedFile)) {
		$bedName = $keepBedName;
		$id2Bed = "$outdir/$bedName.bed";
	}
	@hashSub = DeCovA::refIDs::Id2Coord($IDinRef,$lenTxt5,$lenTxt3,$UpInTxt,$DownInTxt,$splitBedFromId,$mergeBedFromId,$UTRinTxt,$id2Bed,\@chromOrder,\%chromName);
	$txtRegions_r = $hashSub[6];		# as %Regions, but for summary txt file
	$txt_NM_Ex_r = $hashSub[7];		# as %NM_Ex, but for summary txt file
	$ref_Intervals = $hashSub[9];		# as %Bed, but for coordPlot and cov_Bed if no bedfile
	mergeIntervalsInRef($ref_Intervals);
	if ($id2Bed) {
		$id2Bed = DeCovA::bedProcessing::sliceBedIntervals($id2Bed,"$outdir/$bedName",$splitBed,$rmOverlapBed,$cutBed,\%cutB_opt,\@chromOrder,\%chromName);
	}

	## changes Regions{gene} according to each NM (without -A N)
	if ($AllTranscripts) {
		print "\n\tchange region intervals according to each transcript\n";
		print "\t\tfor graph regions\n";
		DeCovA::geneRegion::NM2GeneRegion($Genes_r,$geneNM_r,$NMchr_r,$Regions{"raw"},$NM_Ex{"raw"});
		print "\t\tfor txt regions\n";
		DeCovA::geneRegion::NM2GeneRegion($Genes_r,$geneNM_r,$NMchr_r,$txtRegions_r,$txt_NM_Ex_r);
	}

	## links bed intervals to Regions, eventually changes Regions according to bed (with -L Y)
	if ($Expand) {
		print "\n\tchange region intervals according to bed\n";
		if($AllTranscripts) {
			$RegBed{"raw"} = DeCovA::geneRegion::changeRegionG2($geneNM_r,$Regions{"raw"},$NM_Ex{"raw"},$bed_Intervals);
		} else {
			$RegBed{"raw"} = DeCovA::geneRegion::changeRegionN2($Regions{"raw"},$NM_Ex{"raw"},$bed_Intervals);
		}
	} else {
		print "\n\tchange bed intervals according to genes\n";
		$RegBed{"raw"} = DeCovA::geneRegion::linkBed($Regions{"raw"},$bed_Intervals);
	}

	## eliminates $NM with no corresponding cov bed
	## this because 1st overlap  between gene coord and bed only took into account the whole transcript, not the exon;
	## so removes genes if bed interval fall into introns
	print "\n\teliminates transcripts with no corresponding bed intervals\n";
	if ($AllTranscripts) {
		DeCovA::geneRegion::notAnalysedG($geneNM_r,$Genes_r,$Regions{"raw"},$NM_Ex{"raw"},$RegBed{"raw"});
	} else  {
		DeCovA::geneRegion::notAnalysedN($Genes_r,$NMgene_r,$Regions{"raw"},$NM_Ex{"raw"},$RegBed{"raw"});
	}

	## transposition and splicing, for exons of transcripts: 
	## 1st position of 1st exon = 0, 
	## for end of exon = x, start of next exon = x
	print "\n\ttransposition and splicing of transcript exon coordinates\n";
	@hashSub = DeCovA::geneRegion::transposeReg($spacer,$Regions{"raw"});
	$spacer = $hashSub[0];
	%NMlength = %{$hashSub[1]};			#$NMlength{$NM} = $end of region (for start of region = 0)
	$Regions{"coord0"} = $hashSub[2];	#$Regions{"coord0"}{$NM}{start of region} = $end of region (for start of region = 0)
		
	#$NM_Ex{"coord0"}{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	#$NMstartCod{"coord0"}{$NM} = $start of coding sequence (for start of region = 0)
	#$NMendCod{"coord0"}{$NM} = $end of coding sequence (for start of region = 0)
	if ($AllTranscripts) {
		foreach my $gene(keys%{ $Regions{"coord0"} }) {
			foreach my $NM (@{ ${$geneNM_r}{$gene} }) {
				@hashSub = DeCovA::geneRegion::transposeNM($wUTR,$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $Regions{"raw"}->{${$NMchr_r}{$NM}}{$gene} },\%{ $Regions{"coord0"}->{$gene} },\%{ $NM_Ex{"raw"}->{$NM} }); 
				$NMstartCod{"coord0"}->{$NM} = $hashSub[0];		#${$NMstartCod_r}{"coord0"}{$NM} = $hashSub[0];
				$NMendCod{"coord0"}->{$NM} = $hashSub[1];			#${$NMendCod_r}{"coord0"}->{$NM} = $hashSub[1];
				$NM_Ex{"coord0"}->{$NM} = $hashSub[2];
			}
		}
	} else {
		foreach my $NM (keys%{ $Regions{"coord0"} }) { 
			@hashSub = DeCovA::geneRegion::transposeNM($wUTR,$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $Regions{"raw"}->{${$NMchr_r}{$NM}}{$NM} },\%{ $Regions{"coord0"}->{$NM} },\%{ $NM_Ex{"raw"}{$NM} });
			$NMstartCod{"coord0"}->{$NM} = $hashSub[0];
			$NMendCod{"coord0"}->{$NM} = $hashSub[1]; 
			$NM_Ex{"coord0"}->{$NM} = $hashSub[2];
		}
	}

	## make arrays for starts of non coding exons, before and after coding exons
	## and arrays for starts of extragenic regions, before and after exons
	print "\n\tUTR-CDS-introns region coordinates in arrays\n";
	if ($AllTranscripts) {
		@hashSub = DeCovA::geneRegion::designExons1($wUTR,$Genes_r,$geneNM_r,$Regions{"coord0"},$NM_Ex{"coord0"},$NMstartCod{"coord0"},$NMendCod{"coord0"});
	} else {
		@hashSub = DeCovA::geneRegion::designExons2($wUTR,$Regions{"coord0"},$NM_Ex{"coord0"},$NMstartCod{"coord0"},$NMendCod{"coord0"});
	}
	#return(\%introns,\%UTR,\%Cod);
	$intron{"coord0"} = $hashSub[0];	# $intron{"coord0"}{$NM}{$startIntron} = $endIntron (for start of region = 0)
	$UTR{"coord0"} = $hashSub[1];		# $UTR{"coord0"}{$NM}{$startUTR} = $endUTR (for start of region = 0)
	$Cod{"coord0"} = $hashSub[2];		# $Cod{"coord0"}{$NM}{$startCod} = $endCod (for start of region = 0)

	if ($mutFile) {
		# $RegMut{$NM}{$startReg}{$startMut} = $infoMut
		$RegMut{"raw"} = DeCovA::geneRegion::linkMut($Regions{"raw"}, $Mut);
	}

	#$RegBed{"coord0"}{$NM}{$startBed00} = $endBed00 (start of Region=0 )
	#$RegMut{"coord0"}{$NM}{$mut00} = $infoMut (start of Region=0 )
	@hashSub = DeCovA::geneRegion::transposeBed($Regions{"raw"},$Regions{"coord0"},$RegBed{"raw"},$RegMut{"raw"});
	$RegBed{"coord0"} = $hashSub[0];
	$RegMut{"coord0"} = $hashSub[1];

	print "\n\treversing minus transcript coordinates\n";
	foreach my $gene (keys%{$Genes_r}) {
		my @NMs =  @{ ${$geneNM_r}{$gene} };
		my $chr = ${$NMchr_r}{$NMs[0]};
		my $sens = ${$NMsens_r}{$NMs[0]};
		if ($Rev && $sens eq "-") {
			if ($AllTranscripts) {
				@hashSub = DeCovA::geneRegion::ReverseGene1($gene,$NMlength{$gene},\%{ $Regions{"coord0"}->{$gene} },\%{ $RegBed{"coord0"}->{$gene} },\%{ $RegMut{"coord0"}->{$gene} });
				$Regions{"rev"}->{$gene} = $hashSub[0];
				$RegBed{"rev"}->{$gene} = $hashSub[1];
				$RegMut{"rev"}->{$gene} = $hashSub[2];
				foreach my $NM (@NMs) {
					@hashSub = DeCovA::geneRegion::ReverseGene2($NM,$NMlength{$gene},\%{ $Regions{"coord0"}->{$gene} },\%{ $NM_Ex{"coord0"}->{$NM} },\%{ $intron{"coord0"}->{$NM} },\%{ $UTR{"coord0"}->{$NM} },\%{ $Cod{"coord0"}->{$NM} });
					$NM_Ex{"rev"}->{$NM} = $hashSub[0];
					$intron{"rev"}->{$NM} = $hashSub[1];
					$UTR{"rev"}->{$NM} = $hashSub[2];
					$Cod{"rev"}->{$NM} = $hashSub[3];
				}
			} else {
				foreach my $NM (@NMs) {
					@hashSub = DeCovA::geneRegion::ReverseNMs($NM,$NMlength{$NM},\%{ $Regions{"coord0"}->{$NM} },\%{ $NM_Ex{"coord0"}->{$NM} },\%{ $intron{"coord0"}->{$NM} },\%{ $UTR{"coord0"}->{$NM} },\%{ $Cod{"coord0"}->{$NM} },\%{ $RegBed{"coord0"}->{$NM} },\%{ $RegMut{"coord0"}{$NM} });
					$Regions{"rev"}->{$NM} = $hashSub[0];
					$NM_Ex{"rev"}->{$NM} = $hashSub[1];
					$intron{"rev"}->{$NM} = $hashSub[2];
					$UTR{"rev"}->{$NM} = $hashSub[3];
					$Cod{"rev"}->{$NM} = $hashSub[4];
					$RegBed{"rev"}->{$NM} = $hashSub[5];
					$RegMut{"rev"}->{$NM} = $hashSub[6];
				}
			}
		} else {
			if ($AllTranscripts) {
				$Regions{"rev"}->{$gene} = $Regions{"coord0"}->{$gene};
				if (exists $RegBed{"coord0"}->{$gene}) { $RegBed{"rev"}->{$gene} = $RegBed{"coord0"}->{$gene}; }
				if (exists $RegMut{"coord0"}->{$gene}) { $RegMut{"rev"}->{$gene} = $RegMut{"coord0"}->{$gene}; }
			} else {
				foreach my $NM (@NMs) {
					$Regions{"rev"}->{$NM} = $Regions{"coord0"}->{$NM};
					if (exists $RegBed{"coord0"}->{$NM}) { $RegBed{"rev"}->{$NM} = $RegBed{"coord0"}->{$NM}; }
					if (exists $RegMut{"coord0"}->{$NM}) { $RegMut{"rev"}->{$NM} = $RegMut{"coord0"}->{$NM}; }
				}
			}
			foreach my $NM (@NMs) {
				if (exists $NM_Ex{"coord0"}->{$NM}) { $NM_Ex{"rev"}->{$NM} = $NM_Ex{"coord0"}->{$NM}; }
				if (exists $intron{"coord0"}->{$NM}) { $intron{"rev"}->{$NM} = $intron{"coord0"}->{$NM}; }
				if (exists $UTR{"coord0"}->{$NM}) { $UTR{"rev"}->{$NM} = $UTR{"coord0"}->{$NM}; }
				if (exists $Cod{"coord0"}->{$NM}) { $Cod{"rev"}->{$NM} = $Cod{"coord0"}->{$NM}; }
			}
		}
	}

}




###################
#Job 2: bams analysis:
#my %headers;
my(%bam2Use);
my $depthFile = "$outdir/allsamples_depth.txt";
use DeCovA::depthProgr;
if ($jobs{"with_DephFile_Required"} || $jobs{"keepTmpBed"}) {

	print "\n\n####\n\nper base depth analysis\n\n####\n";

	##defines merge bed to analyse, from bedfile +/- genes +/- mut
	print "\n\tcreating merged bed to be used by depth tools\n";
	my $intervalName;	##name of interval file which will feed depth tools
	if (scalar(keys%{ $Regions{"raw"} }) > 0) {
		#merge intervals from %Regions (for example, if several transcripts for the same gene)
		#% $Regions{"raw"}{chr}{NM}{exonstart} = exonend
		#% $allInterval{chr}{start of region} = end of region
		#print bed corresponding to regions
		#and +/- merge with bedfile and mutFile if any 
		my $allIntervals_r = mergeRegions($Regions{"raw"});
		$intervalName = "regions";
		DeCovA::bedProcessing::printBed("$tmpDir/$intervalName",$allIntervals_r,\@chromOrder);
		if ($bedFile || $mutFile || ($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
			$intervalName = "merge";
			open (my $fhO, ">", "$tmpDir/$intervalName.bed") || die "\n!!!\tcan't create file $tmpDir/$intervalName.bed ($!)\n";
			open (my $fhI, "<", "$tmpDir/regions_0Chr.bed") || die "\n!!!\tcan't open file $tmpDir/regions_0Chr.bed ($!)\n";
			while (my $line = <$fhI>) { print $fhO $line; }
			close $fhI;
			if ($bedFile) {
				open ($fhI, "<", "$tmpDir/original_0Chr.bed") || die "\n!!!\tcan't open file $tmpDir/original_0Chr.bed ($!)\n";
				while (my $line = <$fhI>) { print $fhO $line; }
				close $fhI;
			}
			if (($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
				DeCovA::bedProcessing::printBed("$tmpDir/txtRegions",$ref_Intervals,\@chromOrder);
				open ($fhI, "<", "$tmpDir/txtRegions_0Chr.bed") || die "\n!!!\tcan't open file $tmpDir/txtRegions_0Chr.bed ($!)\n";
				while (my $line = <$fhI>) { print $fhO $line; }
				close $fhI;
			}
			if ($mutFile) {
				open ($fhI, "<", "$mutFile") || die "\n!!!\tcan't open file $mutFile ($!)\n";
				while (my $line = <$fhI>) {
					chomp $line;
					my @tab = split(/\t/,$line);
					$tab[0] =~ s/^chr//;
					print $fhO $tab[0]."\t".($tab[1]-1)."\t".$tab[1]."\n";
				}
				close $fhI;
			}
			close $fhO; 
			my $merge_r = DeCovA::bedProcessing::readBed("$tmpDir/$intervalName.bed");
			mergeIntervalsInRef($merge_r);
			DeCovA::bedProcessing::printBed("$tmpDir/$intervalName",$merge_r,\@chromOrder);
			unlink "$tmpDir/$intervalName.bed";
		}
	} else {
		if ($mutFile) {
			if ($bedFile) { $intervalName = "merge"; }
			else  { $intervalName = "muts"; }
			open (my $fhO, ">", "$tmpDir/$intervalName.bed") || die "\n!!!\tcan't create file $tmpDir/$intervalName.bed ($!)\n";
			open (my $fhI, "<", "$mutFile") || die "\n!!!\tcan't open file $mutFile ($!)\n";
			while (my $line = <$fhI>) {
				chomp $line;
				my @tab = split(/\t/,$line);
				$tab[0] =~ s/^chr//;
				print $fhO $tab[0]."\t".($tab[1]-1)."\t".$tab[1]."\n";
			}
			close $fhI;
			if ($bedFile) {
				open ($fhI, "<", "$tmpDir/original_0Chr.bed") || die "\n!!!\tcan't open file $tmpDir/original_0Chr.bed ($!)\n";
				while (my $line = <$fhI>) { print $fhO $line; }
				close $fhI;
			}
			close $fhO;
			my $merge_r = DeCovA::bedProcessing::readBed("$tmpDir/$intervalName.bed");
			mergeIntervalsInRef($merge_r);
			DeCovA::bedProcessing::printBed("$tmpDir/$intervalName",$merge_r,\@chromOrder);
			unlink "$tmpDir/$intervalName.bed";
		} else {
			if ($bedFile) { $intervalName = "original"; }
		}
	}

	if (! defined $intervalName) {
		print "no intervals to get depth for\n";
	
	} else {

		$intervalName = "$tmpDir/$intervalName";

		if ($raw_cov_file) {

			print "\n\tchecking that all intervals to be analysed are present in depth file $raw_cov_file\n";
			## checking that all intervals to be analysed are present in depth file
			my $intervals_r = DeCovA::bedProcessing::readBed("$intervalName\_0Chr.bed");	#$covbed{$chr}{$start} = $end;	transform in 1-based coord
			foreach my $chr (keys%{$intervals_r}) {
				if (exists ${$depthFilePerChr}{"raw"}{$chr}) {
					print "\t\t$chr found\n";
					my @Starts = sort{$a<=>$b}(keys%{ ${$intervals_r}{$chr} });
					my $s = 0;								#idx of @Starts
					my $posInIntervals = $Starts[$s];		#current position
					open(my $fhIn, "<", ${$depthFilePerChr}{"raw"}{$chr}) || die "\n!!!\tcan't read ".${$depthFilePerChr}{"raw"}{$chr}." ($!)\n";
					while (my $line = <$fhIn>) {
						$line =~ /^(\d+)\t/;
						my $posInDepthFile = $1;
						my $stayInThisLine = 1;
						while ($stayInThisLine) {
							if ($posInDepthFile < $Starts[$s]) {
								$stayInThisLine = 0;
							} else {
								if ($posInDepthFile <= ${$intervals_r}{$chr}{$Starts[$s]}) {
									if ($posInDepthFile == $posInIntervals) {
										$posInIntervals++;
										$stayInThisLine = 0;
									} else {
										die "\n!!!\tat least 1 position to be analysed ($chr:$posInIntervals) not found in cov file (last line: $chr: $posInDepthFile)\n";
									}
								} else {
									if ($s < $#Starts) {
										$s++;
										$posInIntervals = $Starts[$s];
									} else {
										$stayInThisLine = 0;
									}
								}
							}
						}
						if ($posInDepthFile > ${$intervals_r}{$chr}{$Starts[-1]}) {
							last;
						}
					}
					close $fhIn;
					unless (($posInIntervals-1) == ${$intervals_r}{$chr}{$Starts[$s]}) {
						die "\n!!!\tat least 1 position to be analysed not found in cov file
	(last position evaluated: $chr : ".($posInIntervals-1)."
	last interval end: $chr : ".${$intervals_r}{$chr}{$Starts[$s]}." )\n";
					}
				} else {
					die "\n!!!\tsome chrom to be analysed not found in cov file ( $chr )\n";
				}
			}

		}  else {
			## check chr prefix 
			foreach my $f (@Files) {
				$bam2Use{$f} = $f;
				if (!$withChr{$f} && $samT) {
					my $isChr = "_0Chr.bed";
					my $cmd = "$samT view -c -L $intervalName$isChr $f";
					my $count = `$cmd`;
					print "reads from ".$fName{$f}." falling within target regions: $count\n";
					if ($count == 0) {
						print "trying other reference genome:\n";
						$isChr = "_wChr.bed";
						$cmd = "$samT view -c -L $intervalName$isChr $f";
						$count = `$cmd`;
						print "reads from ".$fName{$f}." falling within target regions: $count\n";
					}
					$withChr{$f} = $isChr;
				}
			}

			if ($jobs{"keepTmpBed"}) {
				use File::Copy qw(copy);
				my $bed2copy;
				if (exists $withChr{"all"}) {
					$bed2copy = $intervalName.$withChr{"all"};
				} else {
					$bed2copy = $intervalName."_0Chr.bed";
				}
				copy($bed2copy, "$keepTmpBedDir/$keepTmpBedName.bed") or die "\n!!!\tcopy failed: $!";
			}

			if ($jobs{"with_DephFile_Required"}) {
				##depth analysis
				if (%gatk) {
					print "\n\tdepth analysis using ".$gatk{"jar"}."\n";
					($smplIdx, $depthFilePerChr) = DeCovA::depthProgr::gatkCov($intervalName,\@Files,\%sName,\%bam2Use,$depthFile,$tmpDir,$withChr{"all"},$mmq,$mbq,$dedup,$threads,\%gatk,$genom,$jobs{"keepCov"});
				} else {
					print "\n\tdepth analysis using $bedT\n";
					($smplIdx, $depthFilePerChr) = DeCovA::depthProgr::bedToolsCov($intervalName,\@Files,\%sName,\%fName,\%bam2Use,$depthFile,$tmpDir,\%withChr,$chromLength,$bedT,$bedTversion,$jobs{"keepCov"});
				}
			}

		}

	}

}



###################
#depth Mut
my %depthMut;
if ($mutFile && $jobs{"covMut"}) {

	print "\n\n####\n\nprinting depth for positions in $mutFile\n\n####\n\n";

	## ${$Mut}{$chr}{$startMut} = $infoMut	; (1-based coord)

	foreach my $chrom (@chromOrder) {
		if (exists ${$Mut}{$chrom}) {
			my @Starts = sort{$a<=>$b}keys%{ ${$Mut}{$chrom} };
			my $c = 0;
			open(my $fh, "<", ${$depthFilePerChr}{"raw"}{$chrom}) || die "\n!!!\tcan't open file ".${$depthFilePerChr}{"raw"}{$chrom}." ($!)\n";
			while (my $line = <$fh>) {
				my @tab = split(/\t/,$line);
				my $pos = $tab[0];
				while ( ($pos > $Starts[$c]) && ($c < $#Starts) ) { $c++; }
				if ($pos == $Starts[$c]) {
					foreach (@Files) {
						$depthMut{$_}{$chrom}{$pos} = $tab[${$smplIdx}{$_}];
						}
					}
				elsif ($pos > $Starts[-1]) { last; }
				}
			close $fh;
			}
		}

	#print mut_depth.txt
	my $MutDepthFile = "$outdir/$mutFileName"."_depth.txt";
	open(my $fh, ">", "$MutDepthFile") or die "\n!!!\tcannot create $MutDepthFile ($!)\n";
	print $fh "#locus\tmutation";
	foreach (@Files) { print $fh "\t".$sName2{$_}; }
	print $fh "\n";
	foreach my $chrom (@chromOrder) {
		foreach my $pos (sort{$a<=>$b}keys%{ ${$Mut}{$chrom} }) {
			print $fh $chromName{"mut"}{$chrom}.":$pos\t".${$Mut}{$chrom}{$pos};
			foreach (@Files) { print $fh "\t".$depthMut{$_}{$chrom}{$pos}; }
			print $fh "\n";
			}
		}
	close($fh);

}



###################
#Job 3: Graphs:

if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"graphSum"} || ( ($jobs{"geneReport"} || $jobs{"geneSummary"}) && (($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream)) ) ) {

	print "\n\n####\n\ndrawing graphs per gene/transcript\n\n####\n";

	use DeCovA::covByRegion;
	if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"graphSum"}) {
		use DeCovA::geneGraph;
		}

	my %NMnotCov;	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my %NM_UC;	##NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	if($jobs{"geneReport"}) {
		foreach (@Files) {
			open(OUT, ">", "$outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt") || die "\n!!!\tcan't create file $outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt\n";
			print OUT "## SAMPLE : $sName2{$_}\n\n";
			if ($pThreshold) {
				print OUT "## depth threshold : $pThreshold x\n\n";
				}
			close OUT;
			}
		}

	##foreach gene:
	foreach my $gene (sort(keys%{$Genes_r})) {

#		print "analysing cov in $gene\n";
		my @NMs =  @{ ${$geneNM_r}{$gene} };
		my $chr = ${$NMchr_r}{$NMs[0]};
		my $sens = ${$NMsens_r}{$NMs[0]};

		unless ($AllTranscripts) {
			my %NMinterval;
			foreach my $NM (@NMs) {
				%{ $NMinterval{$chr}{$NM} } = %{ $Regions{"raw"}->{$chr}{$NM} };
				}
			my $tmpRef = mergeRegions(\%NMinterval);
			%{ $Regions{"raw"}->{$chr}{$gene} } = %{ ${$tmpRef}{$chr} };
			}

		##initialyzes %NMCov: @{ $NMCov{$threshold}{$NM}{$nReg} } = [0 foreach pos of Regions{$NM}{$startReg}]
		my %NMCov;
		if ($jobs{"graphSum"}) {
			foreach my $threshold (@Thresholds) {
				if ($AllTranscripts) {
					my $r=0; ##idx of reg of $NM
					foreach my $startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}->{$chr}{$gene} }) {
						my $pos=$startReg;
						while ($pos <= $Regions{"raw"}->{$chr}{$gene}{$startReg} ) { 
							push (@{ $NMCov{$gene}{$threshold}{$r} }, 0);
							$pos++;
							}
						$r++;
						}
					}
				else {
					foreach my $NM (@NMs) {
						my $r=0; ##idx of reg of $NM
						foreach my $startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}->{$chr}{$NM} }) {
							my $pos=$startReg;
							while ($pos <= $Regions{"raw"}->{$chr}{$NM}{$startReg} ) { 
								push (@{ $NMCov{$NM}{$threshold}{$r} }, 0);
								$pos++;
								}
							$r++;
							}
						}
					}
				}
			}
		##foreach depth files from bedtools coveragedepth -d:
		##intersection hash-intervals and gene-coordinates
		##scan bedtools files : create a hash : cov foreach position in intervals from %allInterval: #$allCov{$chr}{$loc} = $cov
		##create a hash : foreach NM, foreach file, foreach exon, array of values for ordered positions
		my %NMdepth;
		my %covStart01;
		my %covEnd01;
		@hashSub = DeCovA::covByRegion::intersectCovFile(\@Files,$smplIdx,${$depthFilePerChr}{"raw"}{$chr},$maxGr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },1);
		my $allDepth_r = $hashSub[0];
		my $notCov_r = $hashSub[1];
		my $notCovStarts_r = $hashSub[2];

		foreach my $file (@Files) {
#			print "\tfor bam $fName{$file}\n";

			if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"} || $jobs{"geneSummary"} || $jobs{"geneReport"}) {
				##for depth-line :
				##create a hash : foreach file, foreach NM, foreach exon, return an array of values for ordered positions
				## @{ $NMdepth{$NM}{$file}{$startReg} } = [ depth foreach ordered bp of exon ]
				if ($AllTranscripts) {
					$NMdepth{$gene}->{$file} = DeCovA::covByRegion::depthLine(\%{ $Regions{"raw"}->{$chr}{$gene} }, \%{ $allDepth_r->{$file} });
					}
				else {
					foreach my $NM (@NMs) {
						$NMdepth{$NM}->{$file} = DeCovA::covByRegion::depthLine(\%{ $Regions{"raw"}->{$chr}{$NM} }, \%{ $allDepth_r->{$file} });
						}
					}

				##for cov-domains:
				##intersections not covered regions and exons
				## printReports  , if $wUTR = $UTRinTxt and if $lenForTxt = $len
				##starts and ends of not covered regions within exons
				## $NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
				## @{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]
				my(%NMcovStart,%NMcovEnd);
				my $printR = "";
				if ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) ) { $printR = $jobs{"geneReport"}; }
				if ($AllTranscripts) {
					@hashSub = DeCovA::covByRegion::notCovDomains2(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $notCov_r->{$file} },\%{ $notCovStarts_r->{$file} });
					$NMcovStart{$gene} = $hashSub[0];
					$NMcovEnd{$gene} = $hashSub[1];
					foreach my $NM (@NMs) {
						@hashSub = DeCovA::covByRegion::notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $NM_Ex{"raw"}->{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $notCov_r->{$file} },\%{ $notCovStarts_r->{$file} },\%NMnotCov,$printR);
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				else {
					foreach my $NM (@NMs) {
						@hashSub = DeCovA::covByRegion::DeCovA::covByRegion::notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}->{$chr}{$NM} },\%{ $NM_Ex{"raw"}->{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $notCov_r->{$file} },\%{ $notCovStarts_r->{$file} },\%NMnotCov,$printR);
						$NMcovStart{$NM} = $hashSub[0];
						$NMcovEnd{$NM} = $hashSub[1];
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}

				##transposition and splicing: 1st position of 1st exon = 1, 
				##and	if end of exon = x, start of next exon = x+1
				## $covEnd01{$NM}{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
				## @{ $covStart01{$NM}{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
				if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"}) {
					if ($AllTranscripts) {
						@hashSub = DeCovA::covByRegion::transposeCov(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $Regions{"coord0"}->{$gene} },$NMcovStart{$gene},$NMcovEnd{$gene});
						$covStart01{$gene}->{$file} = $hashSub[0];
						$covEnd01{$gene}->{$file} = $hashSub[1];
						}
					else {
						foreach my $NM (@NMs) {
							@hashSub = DeCovA::covByRegion::transposeCov(\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$NM} },\%{ $Regions{"coord0"}->{$NM} },$NMcovStart{$NM},$NMcovEnd{$NM});
							$covStart01{$NM}->{$file} = $hashSub[0];
							$covEnd01{$NM}->{$file} = $hashSub[1];
							}
						}
					}
				}

			## @{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
			if ($jobs{"graphSum"}) {
				if ($AllTranscripts) {
					foreach my $threshold (@Thresholds) {
						DeCovA::covByRegion::covByThreshold($threshold,\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $allDepth_r->{$file} },\%{ $NMCov{$gene}{$threshold} });
						}
					}
				else {
					foreach my $NM (@NMs) {
						foreach my $threshold (@Thresholds) {
							DeCovA::covByRegion::covByThreshold($threshold,\%{ $Regions{"raw"}->{$chr}{$NM} },\%{ $allDepth_r->{$file} },\%{ $NMCov{$NM}{$threshold} });
							}
						}
					}
				}
			}

		##foreach NM, find max cov, among all samples (A) or foreach sample (S)
		my(%maxCovA,%maxCovS);	##$maxCov{$NM} = $maxDepth;
		if ($jobs{"graphAllSampls"} || $jobs{"graphBySample"}) {
			if ($maxGr) {
				if ($AllTranscripts) {
					$maxCovA{$gene} = $maxGr;
					foreach (@Files) { $maxCovS{$gene}{$_} = $maxGr; }
					}
				else {
					foreach my $NM (@NMs) {
						$maxCovA{$NM} = $maxGr;
						foreach (@Files) { $maxCovS{$NM}->{$_} = $maxGr; }
						}
					}
				}
			else {
				if ($AllTranscripts) { 
					@hashSub = DeCovA::covByRegion::maxCov(\@Files,$NMdepth{$gene},\%{ $Regions{"coord0"}->{$gene} }); 
					$maxCovA{$gene} = $hashSub[0];
					$maxCovS{$gene} = $hashSub[1];
					}
				else {
					foreach my $NM (@NMs) { 
						@hashSub = DeCovA::covByRegion::maxCov(\@Files,$NMdepth{$NM},\%{ $Regions{"coord0"}->{$NM} });
						$maxCovA{$NM} = $hashSub[0];
						$maxCovS{$NM} = $hashSub[1];
						}
					}
				}
			}

		##reverse if sens "-"
		if ($Rev) {
			if ($sens eq "-") {
				if ($AllTranscripts) {
					DeCovA::covByRegion::ReverseCov_Gene($jobs{"graphSum"},$jobs{"graphAllSampls"},$jobs{"graphBySample"},$gene,$NMlength{$gene},\@Thresholds,$NMdepth{$gene},\%{ $covEnd01{$gene} },$covStart01{$gene},$NMCov{$gene});
					}
				else {
					foreach my $NM (@NMs) {
						DeCovA::covByRegion::ReverseCov_NMs($jobs{"graphSum"},$jobs{"graphAllSampls"},$jobs{"graphBySample"},$NM,$NMlength{$NM},\@Thresholds,$NMdepth{$NM},\%{ $covEnd01{$NM} },$covStart01{$NM},$NMCov{$NM});
						}
					}
				}
			}

		##@{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
		##$NMCovEnd{$NM}{$threshold}{$ex}{$start}=$end
		##$NMCovVal{$NM}{$threshold}{$ex}{$start}=$value
		my(%NMCovEnd,%NMCovVal);
		if ($jobs{"graphSum"}) {
			if ($AllTranscripts) {
				@hashSub= DeCovA::covByRegion::covDomains(\@Thresholds,\%{ $Regions{"rev"}->{$gene} },\%{ $NMCov{$gene} });
				$NMCovEnd{$gene} = $hashSub[0];		
				$NMCovVal{$gene} = $hashSub[1];
				}
			else {
				foreach my $NM (@NMs) {
					@hashSub= DeCovA::covByRegion::covDomains(\@Thresholds,\%{ $Regions{"rev"}->{$NM} },\%{ $NMCov{$NM} });
					$NMCovEnd{$NM} = $hashSub[0];		
					$NMCovVal{$NM} = $hashSub[1];
					}
				}
			}

		##graphiques R
		my @colors=("gold","orange","orangered","red1","magenta4");

		##graph covByGene
		if ($jobs{"graphSum"}) { 
			if ($AllTranscripts) {
				DeCovA::geneGraph::graphSumG($nGraf,$gene,$suff,$outdir,$sens,$Rev,$chr,$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},$NMCovEnd{$gene},$NMCovVal{$gene});
				}
			else {
				DeCovA::geneGraph::graphSumN($nGraf,$gene,$suff,$outdir,$sens,$Rev,$chr,\%NMlength,\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$RegMut{"rev"},\%NMCovEnd,\%NMCovVal);
				}
			}

		##graph covBySample
		if ($jobs{"graphAllSampls"}) {
			if ($AllTranscripts) {
				my $ok=0;
				if ($gThreshold) {
					foreach my $NM (@NMs) {
						foreach my $file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok) {
					DeCovA::geneGraph::graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2);
					}
				}
			else {
				foreach my $NM (@NMs) {
					my $ok=0;
					if ($gThreshold) {
						foreach my $file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok)
						{ graphAllSampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$NM},$NMlength{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2); }
					}
				}
			}

		if ($jobs{"graphBySample"}) {
			if ($AllTranscripts) { 
				my $ok=0;
				if ($gThreshold) {
					foreach my $NM (@NMs) {
						foreach my $file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok) {
					DeCovA::geneGraph::graphBySampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$gene},$maxCovS{$gene},\@NMs,\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$gene},$covStart01{$gene},$covEnd01{$gene},$RegMut{"rev"},\%sName2);
					}
				}
			else {
				foreach my $NM (@NMs) {
					my $ok=0;
					if ($gThreshold) {
						foreach my $file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok) {
						DeCovA::geneGraph::graphBySampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$NM},$maxCovS{$NM},\@Files,\@colors,\@Thresholds,$Regions{"raw"},$Regions{"rev"},$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$NMdepth{$NM},$covStart01{$NM},$covEnd01{$NM},$RegMut{"rev"},\%sName2);
						}
					}
				}
			}
		}
	##summary , if $wUTR = $UTRinTxt and if $lenForTxt = $len
	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($jobs{"geneSummary"} && ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) )) {
		open (OUT, ">$outdir/notCovSummary.txt"); 
		print OUT "depth threshold: $pThreshold\n";
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my $gene (sort(keys%{$Genes_r})) {
			print OUT "\n$gene\n"; 
			foreach my $NM (@{ ${$geneNM_r}{$gene} }) {
				my $txt="";
				foreach my $file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}->{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}
	}

##re-analyse for $printReports || $printSummary, if $wUTR != $UTRinTxt, or if $lenForTxt != $len
if ( ($jobs{"geneReport"} || $jobs{"geneSummary"}) && (($UTRinTxt != $wUTR) || ($lenTxt5 != $len5) || ($lenTxt3 != $len3) || ($UpInTxt != $upstream) || ($DownInTxt != $downstream)) ) {

	use DeCovA::covByRegion;

	my %NMnotCov;	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my %NM_UC;	## NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	foreach my $gene (sort(keys%{$Genes_r})) {
#		print "analysing cov in $gene\n";
		my @NMs =  @{ ${$geneNM_r}{$gene} };
		my $chr = ${$NMchr_r}{$NMs[0]};
		my $sens = ${$NMsens_r}{$NMs[0]};
		unless ($AllTranscripts) {
			my %NMinterval;
			foreach my $NM (@NMs)
				{ %{ $NMinterval{$chr}{$NM} } = %{ ${$txtRegions_r}{$chr}{$NM} }; }
			my $tmpRef = mergeRegions(\%NMinterval);
			%{ ${$txtRegions_r}{$chr}{$gene} } = %{ ${$tmpRef}{$chr} };
			}
		## %notCov: start and end of each not covered domain within %allInterval : $notCov{$start} = $end
		@hashSub = DeCovA::covByRegion::intersectCovFile(\@Files,$smplIdx,${$depthFilePerChr}{"raw"}{$chr},$maxGr,\@Thresholds,\%{ ${$txtRegions_r}{$chr}{$gene} },1);
		my $notCov_r = $hashSub[1];
		my $notCovStarts_r = $hashSub[2];

		foreach my $file (@Files) {
#			print "\tfor bam $fName{$file}\n";
			if ($jobs{"geneSummary"} || $jobs{"geneReport"}) {
				if ($AllTranscripts) {
					foreach my $NM (@NMs) {
						@hashSub = DeCovA::covByRegion::notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ ${$txtRegions_r}{$chr}{$gene} },\%{ ${$txt_NM_Ex_r}{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $notCov_r->{$file} },\%{ $notCovStarts_r->{$file} },\%NMnotCov,$jobs{"geneReport"});
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				else {
					foreach my $NM (@NMs) {
						@hashSub = DeCovA::covByRegion::notCovDomains1($AllTranscripts,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,${$NMsens_r}{$NM},\@Thresholds,$pThreshold,\%{ ${$txtRegions_r}{$chr}{$NM} },\%{ ${$txt_NM_Ex_r}{$NM} },$NMstartCod{"raw"}->{$NM},$NMendCod{"raw"}->{$NM},\%{ $notCov_r->{$file} },\%{ $notCovStarts_r->{$file} },\%NMnotCov,$jobs{"geneReport"});
						$NM_UC{$NM}{$fName{$file}} = $hashSub[2];
						}
					}
				}
			}
		}
	##summary
	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($jobs{"geneSummary"}) {
		open (OUT, ">$outdir/notCovSummary.txt");
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my $gene (sort(keys%{$Genes_r})) {
			print OUT "\n$gene\n"; 
			foreach my $NM (@{ ${$geneNM_r}{$gene} }) {
				my $txt="";
				foreach my $file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}->{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}
	}



###################
#Job 4: cov of each bed interval

my($bedLines_r,$totLength,$depthCount,$covBases,$totBases);

if ($jobs{"covBed"}) {
	use DeCovA::bedCov;
	if ($bedFile) {
		($bedLines_r,$totLength,$depthCount,$covBases,$totBases) = DeCovA::bedCov::Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$bedFile,$bedName,$mergedBed_Intervals,$pThreshold,$jobs{"2Reseq"},$jobs{"bedReport"},\@covFields,\%{ ${$depthFilePerChr}{"raw"} },$smplIdx,\%CNV_opt);
		}
	else {
		($bedLines_r,$totLength,$depthCount,$covBases,$totBases) = DeCovA::bedCov::Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$id2Bed,$bedName,$ref_Intervals,$pThreshold,$jobs{"2Reseq"},$jobs{"bedReport"},\@covFields,\%{ ${$depthFilePerChr}{"raw"} },$smplIdx,\%CNV_opt);
		}
	}




###################
#Job 5: Plots:

if ($jobs{"covPlot"} || $jobs{"interSplot"}) {

	use  DeCovA::histCov;

	my $outPlotDir = "$outdir/covPlot";
	mkdir $outPlotDir;

	#classiq
	if ($jobs{"covPlot"}) {
		if (!$bedFile || $jobs{"genePlot"}) {
			DeCovA::histCov::covPlot($bin,$maxPl,$outPlotDir,"all_Genes_Regions",\@Files,\%sName2,$smplIdx,\%{ ${$depthFilePerChr}{"raw"} },$ref_Intervals,$pThreshold,$totLength,$depthCount,$covBases,$totBases);
		}
		if ($bedFile) {
			DeCovA::histCov::covPlot($bin,$maxPl,$outPlotDir,$bedName,\@Files,\%fName,$smplIdx,\%{ ${$depthFilePerChr}{"raw"} },$mergedBed_Intervals,$pThreshold,$totLength,$depthCount,$covBases,$totBases);
		}
	}

	#plots for samples intersection
	if ($jobs{"interSplot"}) {
		use DeCovA::covByRegion;
		if (!$bedFile || $jobs{"genePlot"}) { 
			DeCovA::histCov::InterS($bin,$maxPl,$maxGr,$outPlotDir,"all_Genes_Regions",\@Files,$smplIdx,\%{ ${$depthFilePerChr}{"raw"} },$ref_Intervals); 
		}
		if ($bedFile) {
			DeCovA::histCov::InterS($bin,$maxPl,$maxGr,$outPlotDir,$bedName,\@Files,$smplIdx,\%{ ${$depthFilePerChr}{"raw"} },$mergedBed_Intervals);
		}
	}

}




###################
#Job 6: CNVs

my($cnv_Patients_r,$cnv_Results_r);
if ($jobs{"CNV"}) {

	use DeCovA::CNV_tool;

	print "\n\n####\n\nCNV analysis\n\n####\n\n";

	if ($bed_cov_file) {
		DeCovA::CNV_tool::CNV_reAnalyse($bed_cov_file,$outdir,$fichier_sexe,\%CNV_opt);
		}
	
	else {
	
		mkdir "$outdir/CNV_analysis";

		($cnv_Patients_r,$cnv_Results_r) = DeCovA::CNV_tool::CNV_detect(\@Files,\%sName2,"$outdir/CNV_analysis",$fichier_sexe,\%CNV_opt,$bedLines_r,\@chromOrder,\%{$chromName{"bed"}});

		if ($CNV_opt{"geneGraph"} && keys%{$cnv_Results_r}) {

			print "\n\n####\n\ncnv geneGraph\n\n####\n";
			use DeCovA::covByRegion;
			use DeCovA::geneGraph;

			## get transcripts and genes overlapping bed CNV results
			print "\n\tgetting genes/transcripts overlapping bed CNV results\n";
			unless ($ALLinRef) {
				$ALLinRef = DeCovA::refIDs::ref2Hash($refFile,$refFmt,\%chromName);
				}
			my(%CNV_IDs,%CNV_bed,%CNV_Genes);
			open (my $fh, ">", "$outdir/allCNVs.bed") || die "\n!!!\tcan't create file $outdir/allCNVs.bed ($!)\n";
			##cnv_Results{$Chrom}{Start}{End} = "DEL/DUP	foldRatio"
			foreach my $file (keys%{$cnv_Results_r}) {
				foreach my $chrom (keys%{ ${$cnv_Results_r}{$file} }) {
					foreach my $start (keys%{ ${$cnv_Results_r}{$file}{$chrom} }) {
						foreach my $end (keys%{ ${$cnv_Results_r}{$file}{$chrom}{$start} }) {
							my $chr = $chrom; $chr =~ s/^chr//i;
							print $fh "$chr\t$start\t$end\n";
							if (exists $CNV_bed{$file}{$chr}{($start+1)}) {
								if ($end > $CNV_bed{$file}{$chr}{($start+1)}) {
									$CNV_bed{$file}{$chr}{($start+1)} = $end;
									}
								}
							else {
								$CNV_bed{$file}{$chr}{($start+1)} = $end;
								}
							}
						}
					}
				my $href = mergeIntervals(\%{ $CNV_bed{$file} });
				%{ $CNV_bed{$file} } = %{$href};
				$CNV_IDs{$file} = DeCovA::refIDs::bed2IDs($ALLinRef,$refFile,$refFmt,\%{ $CNV_bed{$file} },\%chromName,$wNonCod);
				foreach (keys%{ ${CNV_IDs}{$file} }) {
					my $gene = ${CNV_IDs}{$file}{$_}{"gene"};
					my $chr = ${CNV_IDs}{$file}{$_}{"chr"};
					if (exists $Regions{"raw"}->{$chr}{$gene}) {
						$CNV_Genes{$file}{$gene} = 1;
						}
					}
				}
			close $fh;
			$CNV_bed{"allFiles"} = DeCovA::bedProcessing::readBed("$outdir/allCNVs.bed");
			unlink "$outdir/allCNVs.bed";
			mergeIntervalsInRef($CNV_bed{"allFiles"});
			$CNV_IDs{"allFiles"} = DeCovA::refIDs::bed2IDs($ALLinRef,$refFile,$refFmt,$CNV_bed{"allFiles"},\%chromName,$wNonCod);
			foreach (keys%{ ${CNV_IDs}{"allFiles"} }) {
				my $gene = ${CNV_IDs}{"allFiles"}{$_}{"gene"};
				my $chr = ${CNV_IDs}{"allFiles"}{$_}{"chr"};
				if (exists $Regions{"raw"}->{$chr}{$gene}) {
					$CNV_Genes{"allFiles"}{$gene} = 1;
					}
				}

			## change cov file with $Patients{$file}{"Ref_Profondeur_Patient"}
			my %covIdx2File;	#$covIdx{$file} = $i;
			foreach (keys%{$smplIdx}) { $covIdx2File{${$smplIdx}{$_}} = $_; }	#$covIdx2File{$i} = $file;
			foreach my $chr (@chromOrder) {
				${$depthFilePerChr}{"norm"}{$chr} = "$tmpDir/$chr"."_cov_norm.txt";
				open(my $fhIn, "<", ${$depthFilePerChr}{"raw"}{$chr}) || die "\n!!!\tcan't read file ".${$depthFilePerChr}{"raw"}{$chr}." ($!)\n";
				open(my $fhOut, ">", ${$depthFilePerChr}{"norm"}{$chr}) || die "\n!!!\tcan't create file ".${$depthFilePerChr}{"norm"}{$chr}." ($!)\n";
				my $l=0; #line iteration
				while (my $line = <$fhIn>) {
					chomp $line;
					my @tab = split(/\t/,$line);
					my $line2="";
					for my $i (0..2) { $line2 .= $tab[$i]."\t"; }
					for my $i (3..$#tab) { $line2 .= ($tab[$i] / ${$cnv_Patients_r}{$covIdx2File{$i}}{"Ref_depth"})."\t"; }
					chop $line2;
					print $fhOut $line2."\n";
					$l++;
					}
				close $fhIn; close $fhOut;
				}

			## compute as in graphs by genes
			my(%CNV_NMdepth,%CNV_maxCov);
			foreach my $gene (keys%{ $CNV_Genes{"allFiles"} }) {

				print "\tanalysing cov in $gene\n";
				my @NMs =  @{ ${$geneNM_r}{$gene} };
				my $chr = ${$NMchr_r}{$NMs[0]};
				my $sens = ${$NMsens_r}{$NMs[0]};

				## %allDepth: depth foreach position in intervals from %allInterval : ${$allDepth}{$file}{$loc} = depth
				my $allDepth_r = DeCovA::covByRegion::intersectCovFile(\@Files,$smplIdx,${$depthFilePerChr}{"norm"}{$chr},$maxGr,\@Thresholds,\%{ $Regions{"raw"}->{$chr}{$gene} },"");

				foreach my $file (@Files) {
					print "\t\tfor $file\n";
					## %NMdepth: key = $file, value = %(key = $NM, value = %( key = $ex, value = @(cov foreach ordered bp of exon) ) )
					## @{ $CNV_NMdepth{$gene}->{$file}{$eachReg} } = [ depth foreach ordered bp of Reg ]
					$CNV_NMdepth{$gene}->{$file} = DeCovA::covByRegion::depthLine(\%{ $Regions{"raw"}->{$chr}{$gene} },\%{ $allDepth_r->{$file} });
					}

				if ($maxGr) { $CNV_maxCov{$gene} = $maxGr; }
				else {
					@hashSub = DeCovA::covByRegion::maxCov(\@Files,$CNV_NMdepth{$gene},\%{ $Regions{"rev"}->{$gene} }); 
					$CNV_maxCov{$gene} = $hashSub[0];
					}

				##reverse depth coord if sens "-"
				if ($Rev && ($sens eq "-")) {
					my $nEx = scalar(keys%{ $CNV_NMdepth{$gene}->{$Files[0]} }) -1;
					foreach my $file (@Files) {
						#$nEx = scalar(keys%{ $CNV_NMdepth{$gene}->{$file} }) -1;
						my %tmp;
						foreach my $ex (sort{$a<=>$b}(keys%{ $CNV_NMdepth{$gene}->{$file} })) {
							@{ $tmp{($nEx-$ex)} } = reverse@{ $CNV_NMdepth{$gene}->{$file}{$ex} };
							}
						%{ $CNV_NMdepth{$gene}->{$file} } = %tmp;
						}
					}
				}

			## print graphs
			foreach my $file (@Files) {
				foreach my $gene (sort(keys%{ $CNV_Genes{$file} })) {
					#print "printing CNV graph for $sName2{$file}, in $gene\n";
					my @NMs =  @{ ${$geneNM_r}{$gene} };
					my $chr = ${$NMchr_r}{$NMs[0]};
					my $sens = ${$NMsens_r}{$NMs[0]};
					DeCovA::geneGraph::CNVgraphByGene($file,$suff,"$outdir/CNV_analysis/$sName2{$file}",$gene,$sens,$maxGr,$Rev,$chr,$CNV_maxCov{$gene},$pThreshold,$NMlength{$gene},\@Files,\%sName2,$Regions{"raw"},$Regions{"rev"},\@NMs,$NM_Ex{"rev"},$RegBed{"rev"},$intron{"rev"},$UTR{"rev"},$Cod{"rev"},$CNV_NMdepth{$gene});
					}
				}

			}

		}
	
	}


###################
#rm tmp files

if (! $jobs{"keepBed"}) {
#	if ($jobs{"covBed"} && !$bedFile) {
#		unlink "$outdir/$bedName.bed";
#		}
	if ($id2Bed) { unlink $id2Bed; }
	if ($bedFile && ($lenForBed || %reAnnotBed || $splitBed || $rmOverlapBed || $cutBed) ) { unlink $bedFile; }
}

#if ($gatk) {
#	unlink glob "$outdir/all.cov*";
#	if ($jobs{"CNV"}) { unlink glob "$outdir/all.norm.cov*"; }
#	}

if (-d $tmpDir ) {
	use File::Path qw(remove_tree);
	remove_tree( $tmpDir );
}

if ($jobs{"keepTmpBed"} && !$jobs{"output_dir_2_keep"}) {
	use File::Path qw(remove_tree);
	remove_tree( $outdir );
}




my $datestring = localtime(); 
print "\n\n####\n\nend: $datestring\n\n";

exit;




######################

##FUNCTIONS

######################



#################################
#merge overlapping intervals 
#%interval2 = mergeIntervals(\%interval);
sub mergeIntervals {
my ($intervals) = @_;
my %interval2;
foreach my $chr (keys%{$intervals}) {
	my @Starts = sort{$a<=>$b}(keys%{ ${$intervals}{$chr} });
	my $start = $Starts[0];
	my $end = ${$intervals}{$chr}{$start};
	for (my $i=1;$i<scalar(@Starts);$i++) {
		if ($Starts[$i] <= $end) {
			if (${$intervals}{$chr}{$Starts[$i]} > $end) {
				$end = ${$intervals}{$chr}{$Starts[$i]};
				}
			else { next; }
			}
		else {
			$interval2{$chr}{$start} = $end;
			$start = $Starts[$i];
			$end = ${$intervals}{$chr}{$start};
			}
		}
	$interval2{$chr}{$start} = $end;
	}
return(\%interval2);
}

sub mergeIntervalsInRef {
my ($intervals) = @_;
foreach my $chr (keys%{$intervals}) {
	my @Starts = sort{$a<=>$b}(keys%{ ${$intervals}{$chr} });
	my $start = $Starts[0];
	my $end = ${$intervals}{$chr}{$start};
	my %interval2;
	for (my $i=1;$i<scalar(@Starts);$i++) {
		if ($Starts[$i] <= $end) {
			if (${$intervals}{$chr}{$Starts[$i]} > $end) {
				$end = ${$intervals}{$chr}{$Starts[$i]};
				}
			else { next; }
			}
		else {
			$interval2{$start} = $end;
			$start = $Starts[$i];
			$end = ${$intervals}{$chr}{$start};
			}
		}
	$interval2{$start} = $end;
	%{ ${$intervals}{$chr} } = %interval2;
	}
}


########################

#merge intervals from %Regions: 
#$Regions{chr}{NM}{start of region} = end of region
#@hashSub = mergeRegions(\%{ $Regions{"raw"} });
#%allInterval = %{$hashSub[0]};

sub mergeRegions {

my($interval1) = @_;

print "\t\tmerge overlapping intervals from RefSeq selected transcripts\n";
#$interval1{$chr}{$NM}{$start} = $end;
#$interval2{$chr}{$start} = $end;

#for each same starts, keep longer intervals
my(%interval2,%chrom);
foreach my $chr (keys%{$interval1}) {
	foreach my $NM (keys%{ ${$interval1}{$chr} }) {
		$chrom{$chr} = 1;
		foreach my $start ( sort{$a<=>$b}(keys%{ ${$interval1}{$chr}{$NM} }) ) {
			if ( exists $interval2{$chr}{$start} ) {
				if ( ${$interval1}{$chr}{$NM}{$start} > $interval2{$chr}{$start} )
					{  $interval2{$chr}{$start} = ${$interval1}{$chr}{$NM}{$start}; }	
				else { next; }
				}
			else
				{ $interval2{$chr}{$start} = ${$interval1}{$chr}{$NM}{$start}; }
			}
		}
	}
my @chrom = sort(keys%chrom);

#merge overlapping intervals
my(%interval3);
foreach my $chr (@chrom) { 
	my @Starts = sort{$a<=>$b}(keys%{ $interval2{$chr} }); 	#hash{chr}=@sortedStart
	my $start = $Starts[0];
	my $end = $interval2{$chr}{$start};
	$interval3{$chr}{$start} = $end;
	for (my $i=1;$i<scalar(@Starts);$i++) {
		if ($Starts[$i] <= $end) {
			if ($interval2{$chr}{$Starts[$i]} > $end)
				{ $end = $interval2{$chr}{$Starts[$i]}; }
			else { next; }
			}
		else {
			$interval3{$chr}{$start} = $end;
			$start = $Starts[$i];
			$end = $interval2{$chr}{$start};
			}
		}
	$interval3{$chr}{$start} = $end;
	}

return (\%interval3)	#$interval3{$chr}{$start} = $end;

}

########################


#print tests:

#	print "Regions:\n";	# $Regions{chr}{NM}{start of region} = end of region
#	foreach my $chr(sort(keys%Regions)) {
#		foreach my $NM (sort(keys%{ $Regions{$chr} })) {
#			foreach my $startR (sort{$a<=>$b}keys%{ $Regions{$chr}{$NM} })
#				{ print $chr."\t".$NM."\t".$startR."\t".$Regions{$chr}{$NM}{$startR}."\n"; }
#			}
#		}

#	print "NM_Ex:\n";	# %NM_Ex{NM}{start of region}{start of exon} = end of exon
#	foreach (sort(keys%NM_Ex)) {
#		foreach my $startR (sort{$a<=>$b}keys%{ $NM_Ex{$_} }) {
#			foreach my $startN (sort{$a<=>$b}keys%{ $NM_Ex{$_}{$startR} })
#				{ print $_."\t".$startR."\t".$Regions{$NMchr{$_}}{$NMgene{$_}}{$startR}."\n\t\t".$startN."\t".$NM_Ex{$_}{$startR}{$startN}."\n"; }
#			}
#		}

#	print "introns:\n";	# $intron{$NM}{$startIntron} = $endIntron
#	foreach my $NM (sort(keys%intron)) {
#		foreach my $start (sort{$a<=>$b}(keys%{ $intron{$NM} }))
#			{ print $NM."\t".$start."\t".$intron{$NM}{$start}."\n"; }
#		}
#	print "UTRs:\n";	# $UTR{$NM}{$startUTR} = $endUTR
#	foreach my $NM (sort(keys%UTR)) {
#		foreach my $start (sort{$a<=>$b}(keys%{ $UTR{$NM} }))
#			{ print $NM."\t".$start."\t".$UTR{$NM}{$start}."\n"; }
#		}
#	print "Cods:\n";	# $Cod{$NM}{$startCod} = $endCod
#	foreach my $NM (sort(keys%Cod)) {
#		foreach my $start (sort{$a<=>$b}(keys%{ $Cod{$NM} }))
#			{ print $NM."\t".$start."\t".$Cod{$NM}{$start}."\n"; }
#		}


##############
#gatk:
#-omitIntervals	
#outName.sample_interval_statistics	not used (eq to sum)
#outName.sample_interval_summary		for bed (remove 4,5,6e col)

#-omitLocusTable				not used
#outName.sample_cumulative_coverage_counts
#outName.sample_cumulative_coverage_proportions

#-omitSampleSummary		
#outName.sample_statistics		for hist
#outName.sample_summary

#-omitBaseOutput				if only plot

#options:
#--nBins	499 	Number of bins to use for granular binning

#--start	1 	Starting (left endpoint) for granular binning

#--stop		500 	Ending (right endpoint) for granular binning

#$intervalName-all.cov
#Locus	Total_Depth	Average_Depth_sample	Depth_for_01	Depth_for_02	Depth_for_03
#chr1:43390947	244	81.33	43	124	77
#chr1:43390948	248	82.67	44	125	79

