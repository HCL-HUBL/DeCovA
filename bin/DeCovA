#!/usr/bin/perl


##depth analysis of bam files
##at regions defined by a bed file or a list of genes
##makes R graphs, with depth line and not covered domains, at different thresholds

##thomas Simonet, CHU de Lyon, 2014 (thomas.simonet@chu-lyon.fr)
##Pierre-Antoine Rollat-Farnier, CHU de Lyon, 2015
##Vincent Danjean, 2016

##This program is a free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>

our $VERSION="1.4.5d";

use warnings;
use strict;
use Getopt::Long;
use File::Basename;
use File::Find;
use Cwd 'abs_path';
use lib dirname(abs_path($0))."/../lib";
use Bio::NGS::HCL::DeCovA::CNV_tool;


############
#parameters:

Getopt::Long::Configure ("bundling");
my%opt = ();
GetOptions (\%opt, 
	"file|f=s@",
	"dir|d=s@",
	"suffix|s=s",
	"refseq|r=s",
	"bed|b=s",
	"mut|m=s",
	"outdir|O=s",
	"outfile|o=s",
	"id|i=s@",
	"nonCoding|N",
	"depthThreshold|t=s@",
	"printThreshold|T=i",
	"noGraphThreshold",
	"noUTR|U",
	"noUTRinTxt|u",
	"maxDepth=i",
	"expand2val|l=s",
	"UDstream=s",
	"noOverlap",
	"expand2bed|L",
	"Ltxt:s",
	"UDtxt:s",
	"Lbed=i",
	"noReverse|R",
	"graphSum|S",
	"allSample|A",
	"bySample|X",
	"noAllTranscripts",
	"noDepthMut|M",
	"covPlot|P",
	"covBed|B",
	"bedReport",
	"Reseq=f",
	"cov_fields|F=s@",
	"geneReport",
	"summary:s",
	"keepCov|k",
	"keepBed",
	"raw_cov=s@",
	"binPlot=i",
	"maxPlot=i",
	"genePlot",
	"interPlot",
	"gatk:s",
	"ram|x=i",
	"cpu=i",
	"bedtools=s",
	"samtools=s",
	"picard=s",
	"genome|g=s",
	"dedup:s",
	"mbq=i",
	"mmq=i",
	"CNV|C",
	"sex_file=s",
	"bed_cov=s",
	"split_bed",
	"cut_bed:s",
	"seuil_region=f",
	"seuil_patient=f",
	"seuil_cov=f",
	"seuil_del=f",
	"seuil_dup=f",
	"min_CNV=i",
	"max_nonCNV=i",
	"normStat=s",
	"min_DP=i",
	"normByGender=s",
	"totalBases",
	"totalAllChr",
	"noCNV_byGene",
	"noCNV_byChr",
	"CNV_fields=s@",
	"compress|z",
	"nGraph:i",
	"version|v",
	"help|h") or die "Invalid parameters: $! \n";

unless(%opt) { usage(); }

if (exists $opt{help}) { usage(); }

if (exists $opt{version}) { die "$VERSION\n"; }

if(@ARGV) {
	print"Invalid parameters:\n";
	foreach(@ARGV) { print"\t$_\n"; }
	die "(forgotten \"-\"?)\n";
	}

sub usage
{
die "usage:
	as a script:		perl /path/to/DeCovA [option]
	or after installation:	DeCovA [option]
options:
inputs:
	-f / --file : list of bam files (comma separated, or set several times), or file with such a list (ended with \".list\"; one bam per line)
	-d / --dir : directory(ies) where to find bam files (comma separated, or set several times)
	-s / --suffix : suffix to add before opening bam files
	-r / --refseq : RefSeq file (required)
	-b / --bed : bed file, used to analyse depth coverage
	-m / --mut : mut file, used to plot known mutations ; format: \"chr	pos(1-based)	info\" (vcf files are ok)
	-i / --id : list of of refseq genes/transcripts id (comma separated, or set several times), or file with such a list (\".list\")
	-g / --genome : path to genome.fa file, if available (required if using GATK)
	--sex_file : format: patient\tsex
	--raw_cov : use this coverage tool output .cov file (to skip bam analysis) (gatk output only supported)
	--bed_cov : use this DeCovA's output .cov.txt file (to skip cov bed analysis in CNV detect)
outputs:
	-o / --outfile : text outfile name (default: cov_samplename.txt)
	-O / --outdir : out directory (default: folder named with date)
	-S / --graphSum : will perform graphSums (sum of covered samples by position)
	-A / --allSample : will perform graphAllSample (depthline by gene and by sample, all samples graph on same .png file)
	-X / --bySample : will perform graphBySample (depthline by gene and by sample, one sample by .png file)
	-M / --noDepthMut : does not print, foreach file, depth at known mutations provided by opt -m (default: yes if -opt m)
	-P / --covPlot : will perform covPlots
	-B / --covBed : will output cov of bed intervals
	-C / --CNV : will output CNV foreach bed intervals
	--Reseq : float [0-1] : print bed interval if cov < value (def: do not print)
	--geneReport : will print all uncovered genomic intervals (within gene region) in 1 txt file per sample (default: no)
	--bedReport : will print all uncovered intervals (within bed intervals) in 1 txt file per sample (default: no)
	--summary : (Y/N) : to print summary txt file (default: yes if -S -A -X)
	-k / --keepCov : do not erase coverage file at the end of the process
	--keepBed : do not erase bed file inferred from gene list, at the end of the process
parameters:
  *refseq gene analysis:
	-N / --nonCoding : analyse also Non coding transcripts (default: no)
	-U / --noUTR : does not take into account UTR regions for graphs (default: yes)
	-u / --noUTRinTxt : does not take into account UTR regions for summary txt file and plots (default: yes)
	-t / --depthThreshold : depth thresholds, comma separated
	-T / --printThreshold : depth threshold used for txt outputs (must be one of those in opt -t; default : the smallest one)
	--noGraphThreshold : all graphs will be printed, whatever the coverage 
		(default: only the genes not fully covered at threshold in -opt -T will be drawn)
	--noAllTranscripts : does not print All transcripts on same file, in graphBySample (default: yes)
	--maxDepth : max depth value when printing graph (optional)
	-l / --expand2val : int: length to add at each ends of exons (default: 0) ; or int1,int2 : lengths to add in 5' and 3'
	--UDstream : int: length to add at each ends of genes ; or int1,int2 : lengths to add upstram and downstream
	--noOverlap : if padding creates overlapping exons, take the mid between them (for report)
	-L / --expand2bed : expand length of gene analysed regions to bed coord, if -l < bed (default: no)
	--Ltxt : does take into account expanded length (from -l and -L) for txt outputs (default: no), or add a different length
	--UDtxt : does take into account up/downStream length for txt outputs (default: no), or add a different length
	-R / --noReverse : does not reverse regions if sens of transcript = (-) (default: yes)
	--nGraph : max nber of graphs per sheet (default : all samples or all transcripts)
  *plot param:
	--binPlot : bin width for covPlot (default=10)
	--maxPlot : max depth for covPlot (default=100)
	--genePlot : will perform plots for regions extracted from genes coord, not only for bed intervals (default: no)
	--interPlot : will produce intersection covPlot (default: no)
  *filters
 	--dedup : do not take in account dup reads (default keep all reads; enter \"do\" to perform Picard deduplication) 
	--mbq : minimum base quality (default 0; requires gatk)
	--mmq : minimum mapping quality (default 0)
  *cov_bed param:
	-F / --cov_fields : fields foreach intervals in covBed (comma separated), among: min, max, tot, mean, median, cov 
		(default: min,mean,cov)
	--Lbed : length added out of bed interval ends (default: 0)
	--split_bed : split overlapping bed intervals for Cov and CNV analyses
	--cut_bed : cut bed intervals in shorter fragments: cutL:x,minL:y,maxL:z,keepLast:s
				cutL : length of segmentation (def: 150)
				minL : min length required to keep the last interval, after segmentation (def: --cutL/2)
				maxL : length above which bed intervals will be segmented, in N segments of \"cutL\" length (def: as --cutL)
				keepLast : if last interval shorter than minL :
						enter m (merge) if want that last two ones are simply merged
						enter h (half) if want that last two ones are output with length = half of their sum
						enter n if want to through it out
  *CNV_detect param:
	--seuil_del : float ( [0-1] for normStat=mean/mediane (def: 0.8) ; <0 for normStat=std (def: -2) )
	--seuil_dup : float ( >1 for normStat=mean/mediane (def: 1.2) ; >0 for normStat=std (def: 2) )
	--seuil_region : float [0-1] : region discarded if CNVs/N_samples >value (def: 1)
	--seuil_patient : float [0-1] : patient discarded if CNVs/N_regions >value (def: 1)
	--seuil_cov : float [0-1] : region discarded if none of the samples have cov >value (def: 0)
	--min_DP : min average depth for a region to be kept
	--min_CNV : min nber consecutive CNV
	--max_nonCNV : max nber non-CNV intervals tolerated within a CNV 
	--normStat : MOY/STD/MED , ie average, standard deviation, median (def: MED)
	--normByGender :	enter \"a\" : foreach region of all chrom, normalize separately for F and M ; 
				enter \"g\" : foreach region on gonosomes only, normalize separately for F and M
				def: no (normalize F and M together)
	--totalBases : sample depths normalized by sum of sequenced bp (def: by mean of all region average depths)
	--totalAllChr : norm by sum on all chr, whatever the sex (def: double the totalDepth for chrX if male, and skip chrY in the sum)
	--noCNV_byGene : to disable graph for gene affected by a CNV
	--noCNV_byChr : to disable graph by chr
	--CNV_fields : fields foreach intervals (comma separated), among: min, max, norm (default: none)
  *external tools path:
	--bedtools : enter path to executable, if not installed as root or not in path
	--samtools : enter  path to executable, if not installed as root
	--picard : enter path to executable .jar, if not installed as root
	--gatk : cov analysis will be performed by gatk (default:bedtools; enter path to executable, if not installed as root)
  *general:
	-x / --ram : memory for gatk (in Go)
	--cpu : multi-thread for gatk (def: 1)
	-z / --compress : archive output folder
	-v / --version : current version 
	-h / --help : help
	\n";
}

##inputs:

#-d: directory
my@dir = ();
if (exists $opt{dir}) {
	foreach (@{ $opt{dir} }) {
		if ($_ =~ /.list$/) {
			open(LIST, $_) || die "can't open file $_\n";
			while (my$line=<LIST>) {
				unless ($line =~ /^\s*$/) {
					chomp $line;
					push (@dir, $line);
					}
				}
			close LIST;
			}
		else
			{ push(@dir, split(/,/, $_)); }
		}
	foreach (@dir) {
		unless( -d $_ ) 
			{ die "$_ directory not found\n"; }
		unless ($_ =~ /\/$/) { $_ .= "/"; } 
		}
	}
#-f: files
my$suff = "";
if (exists $opt{suffix}) { 
	$suff = $opt{suffix}; 
	$suff =~ s/.bam$//;
	}
my@Files = ();
if (exists $opt{file}) {
	foreach (@{ $opt{file} }) {
		if ($_ =~ /.list$/) {
			open(LIST, $_) || die "can't open file $_\n";
			while (my$line=<LIST>) {
				unless ($line =~ /^\s*$/) {
					chomp $line;
					push (@Files, $line);
					}
				}
			close LIST;
			}
		else
			{ push(@Files, split(/,/, $_)); }
		}
	}
else { 
	foreach my$dir(@dir) {
		find(\&subDir, $dir);
		}
	}
sub subDir
{
if ($suff) {
	if (-f $_ && $_=~/$suff.bam$/) 
		{ push(@Files, $File::Find::name); }
	}
else {
	if (-f $_ && $_=~/.bam$/) 
		{ push(@Files, $File::Find::name); }
	}
}
my(%fName,%path);	#fName: name of file, without path and extension
my$extenS = "$suff.bam";
if (@Files) {
	print "file(s) to analysed:\n";
	foreach (@Files) {
		($fName{$_},$path{$_}) = fileparse($_,$extenS);
		if (exists $opt{dir} && exists $opt{file}) {
			if (scalar@dir>1) { die "not possible to affect path to files if several paths specified\n"; }
			else { $path{$_} = $dir[0]; }
			}
		if ( -f $path{$_}.$fName{$_}.$extenS ) 
			{ print "will process $path{$_}$fName{$_}$extenS\n"; }
		else { die "$path{$_}$fName{$_}$extenS file not found\n"; }
		}
	}

my$ref="";
if (exists $opt{refseq}) { $ref = $opt{refseq}; }

my$bedFile="";
if (exists $opt{bed}) { $bedFile = $opt{bed}; }
my$bedName="";
if($bedFile) 
	{ ($bedName,my$pathBed) = fileparse($bedFile,".bed"); }

my$mutFile="";
if (exists $opt{mut}) { $mutFile = $opt{mut}; }

my$outfile="cov_";
if ($opt{outfile})
	{ $outfile=$opt{outfile}; }

my(@IDs,%IDs);
if (exists $opt{id}) {
	if ($opt{id}[0] =~ /.list$/) {
		open(LIST, $opt{id}[0]) || die "can't open file ".$opt{id}[0]."\n";
		while (my$line=<LIST>) {
			unless($line =~ /^\s*$/) {
				chomp $line;
				$line =~ s/\s//g;
				push(@IDs, $line);
				}
			}
		close LIST;
		}
	else { @IDs = split(/,/, join(',',@{$opt{id}})); }
	foreach my$id(@IDs) { 
		if ($id =~ /^NM_/)
			{ $id =~ s/\.(\d+)$//; }
		$IDs{$id} = 1;
		}
	@IDs=sort(keys%IDs);
	print "Regions to analyse: \n";
	foreach my$id(@IDs)
		{ print "\t".$id."\n"; }
	}

##refseq gene analysis param
my$nonCod = "";
if (exists $opt{nonCoding})
	{ $nonCod = 1; }

my$wUTR = 1;
if (exists $opt{noUTR})
	{ $wUTR = 0; }
my$UTRinTxt = 1;
if (exists $opt{noUTRinTxt})
	{ $UTRinTxt = 0; }
if ($nonCod && (!$wUTR || !$UTRinTxt))
	{ die "nonCoding inclusion not compatible with UTR exclusion\n"; }

my$maxGr = ""; #max depth for graphs
if (exists $opt{maxDepth}) { 
	if ($opt{maxDepth} =~ /^\d+$/) { $maxGr = $opt{maxDepth}; }
	else { die "--maxCov opt value need to be an integer\n"; }
	}

my$len5 = 0; my$len3 = 0;
if (exists $opt{expand2val}) {
	if ($opt{expand2val} =~ /,/) {
		my@len = split(/,/,$opt{expand2val});
		$len5 = $len[0];
		$len3 = $len[1];
		}
	else {
		$len5 = $opt{expand2val};
		$len3 = $opt{expand2val};
		}
	}

my$noOverlap = 0;
if (exists $opt{noOverlap}) { $noOverlap = 1; }

my$lenTxt5 = 0; my$lenTxt3 = 0;
if (exists $opt{Ltxt}) {
	if ($opt{Ltxt}) {
		if ($opt{Ltxt} =~ /,/) {
			my@len = split(/,/,$opt{Ltxt});
			$lenTxt5 = $len[0];
			$lenTxt3 = $len[1];
			}
		else {
			$lenTxt5 = $opt{Ltxt};
			$lenTxt3 = $opt{Ltxt};
			}
		}
	else { $lenTxt5 = $len5; $lenTxt3 = $len3; }
	}

my$upstream = 0; my$downstream = 0;
if (exists $opt{UDstream}) {
	if ($wUTR) {
		if ($opt{UDstream} =~ /,/) {
			my@len = split(/,/,$opt{UDstream});
			$upstream = $len[0];
			$downstream = $len[1];
			}
		else {
			$upstream = $opt{UDstream};
			$downstream = $opt{UDstream};
			}
		if ($upstream <= $len5 || $downstream <= $len3)
			{ die "upstream/downstream expansion must be longer than padding\n"; }
		}
	else { die "upstream/downstream expansion not compatible without UTR\n"; }
	}

my$UpInTxt = 0 ; my$DownInTxt = 0;
if (exists $opt{UDtxt}) {
	if ($opt{UDtxt}) {
		if ($wUTR) {
			if ($opt{UDtxt} =~ /,/) {
				my@len = split(/,/,$opt{UDtxt});
				$UpInTxt = $len[0];
				$DownInTxt = $len[1];
				}
			else {
				$UpInTxt = $opt{UDtxt};
				$DownInTxt = $opt{UDtxt};
				}
			if ($UpInTxt <= $lenTxt5 || $DownInTxt <= $lenTxt3)
				{ die "upstream/downstream expansion must be longer than padding\n"; }
			}
		else { die "upstream/downstream expansion not compatible without UTR\n"; }
		}
	else { $UpInTxt = $upstream; $DownInTxt = $downstream; }
	}

my$Expand = "";
if (exists $opt{expand2bed})
	{ $Expand = 1; }

my$lenForBed = 0;
if (exists $opt{Lbed}) {
	if ($opt{Lbed} =~ /^\d+$/) { $lenForBed = $opt{Lbed}; }
	else { die "--Lbed value need to be an integer\n"; }
	}

my$spacer = 0;

##jobs
my$bedReport = 0;
if (exists $opt{bedReport})
	{ $bedReport = 1; }
my$Rev = 1;
if (exists $opt{noReverse})
	{ $Rev=0; }
my$All = 1;
if (exists $opt{noEachTranscript}) 
	{ $All=0; }
my$Sum = "";
if (exists $opt{graphSum})
	{ $Sum=1; }
my$allS = "";
if (exists $opt{allSample})
	{ $allS=1; }
my$byS = "";
if (exists $opt{bySample})
	{ $byS=1; }

my$covMut = "";
if ($mutFile) { $covMut=1; }
if (exists $opt{noDepthMut})
	{ $covMut=""; }

my$covPlot = "";
if (exists $opt{covPlot})
	{ $covPlot=1; }

my$cov_Bed = "";
if (exists $opt{covBed})
	{ $cov_Bed=1; }

my$toReseq = "";
if (exists $opt{Reseq})
	{ $toReseq=$opt{Reseq}; }

my$CNV_tool = "";
if (exists $opt{CNV}) {
	$CNV_tool=1; 
	}

my$bin = 10; #nber of bin for bar plots
if (exists $opt{binPlot})
	{ $bin = $opt{binPlot}; }
my$maxPl = 100; #max depth for bar plots
if (exists $opt{maxPlot})
	{ $maxPl = $opt{maxPlot}; }
if (($maxPl % $bin) != 0) { die "binPlot needs to be a multiple of maxPlot\n"; }

my$interS = "";
if (exists $opt{interPlot})
	{ $interS = 1; }

my$coordPlot = "";
if (exists $opt{genePlot})
	{ $coordPlot = 1; }

my$printReports = "";
if (exists $opt{geneReport})
	{ $printReports = 1; }

my$printSummary = "";
if ($Sum || $allS || $byS)		# || @IDs)
	{ $printSummary = 1; }
if (exists $opt{summary}) {
	if ($opt{summary}) {
		if ($opt{summary} =~ /^y|^o/i) { $printSummary = 1; }
		elsif ($opt{summary} =~ /^n/i) { $printSummary = ""; }
		else { die "opt summary no recognized (y/n)"; }
		}
	else { $printSummary = 1; }
	}

my$keepCov = "";
if (exists $opt{keepCov}) { $keepCov = 1; }

my$keepBed = "";
if (exists $opt{keepBed}) { $keepBed = 1; }

my@raw_cov_file = ();
if (exists $opt{raw_cov}) {
	@raw_cov_file = split(/,/, join(',',@{$opt{cov_fields}}));
	foreach (@raw_cov_file) {
		unless ( -s "$_" ) { die "$_ cov file not found or empty\n"; }
		}
	}
if (@Files && @raw_cov_file) { die "must choose between providing bam files or cov files\n"; }
if ($covMut && @raw_cov_file) { die "cannot compute depth on mutation file from cov files\n"; }


my(@Thresholds,$pThreshold);
if (exists $opt{printThreshold})
	{ $pThreshold = $opt{printThreshold}; }
if (exists $opt{depthThreshold}) {
	@Thresholds = split(/,/, join(',',@{$opt{depthThreshold}}));
	foreach (@Thresholds) {
		if ($_ =~ /^\d+$/) { print "depth threshold: $_\n"; }
		else { die "$_ depth threshold value need to be an integer\n"; }
		}
	@Thresholds = sort{$b<=>$a}@Thresholds;	#decroissant
	#check if $pThreshold one of those in @Thresholds
	if ($pThreshold) {
		my$ok=0;
		foreach (@Thresholds) {
			if ($pThreshold==$_) 
				{ $ok=1; last; }
			}
		unless ($ok) 
			{ die "opt -T threshold value need to be 1 of those in opt -t\n"; }
		}
	else { $pThreshold = $Thresholds[-1]; }
	print "threshold for summary: $pThreshold \n";
	}
else { 
	if ($pThreshold) { @Thresholds = ($pThreshold); }
	}

my@covFields =(); 
if ($pThreshold) { @covFields = ("min","mean","cov"); }
else { @covFields = ("min","mean","tot"); }
my%covFieldList = ("min"=>1,"max"=>1,"tot"=>1,"mean"=>1,"median"=>1,"cov"=>1);
if (exists $opt{cov_fields}) {
	@covFields = split(/,/, join(',',@{$opt{cov_fields}}));
	foreach (@covFields) {
		unless (exists $covFieldList{$_}) { die "cov field not recognized (min,max,tot,mean,median,cov)\n"; }
		}
	}

my$gThreshold = 1;
if (exists $opt{noGraphThreshold})
	{  $gThreshold=""; }

my$bedT = "";
if (exists $opt{bedtools})
	{ $bedT = $opt{bedtools}; }
my$samT = "";
if (exists $opt{samtools})
	{ $samT = $opt{samtools}; }
my$picard = "";
if (exists $opt{picard})
	{ $picard = $opt{picard}; }
my$gatk = "";
if (exists $opt{gatk}) { 
	$gatk = $opt{gatk}; 
	if (!$gatk) { $gatk = 1; }	#if exists, but no value: means, just use it, but will test the default command
	}
my$genom = "";
if (exists $opt{genome}) { 
	$genom = $opt{genome}; 
	}
my$ram = "";
if (exists $opt{ram}) { 
	$ram = $opt{ram};
	}
my$threads = "";
if (exists $opt{cpu}) { 
	$threads = $opt{cpu};
	}
my$dedup = "";
if (exists $opt{dedup}) { 
	if ($opt{dedup} eq "do") { $dedup = "do"; }
	elsif ($opt{dedup} eq "") { $dedup = 1; }
	else { die "not recognized value for --dedup arg.\n"; }
	}
my$mbq = "";
if (exists $opt{mbq}) {
	if ($opt{mbq} =~ /^\d+$/) { $mbq = $opt{mbq}; }
	else { die "mbq value need to be an integer\n"; }
	}
my$mmq = "";
if (exists $opt{mmq}) {
	if ($opt{mmq} =~ /^\d+$/) { $mmq = $opt{mmq}; }
	else { die "mmq value need to be an integer\n"; }
	}
my$gz = "";
if (exists $opt{compress})
	{ $gz = 1; }
my$nGraf = "max";
if (exists $opt{nGraph} && $opt{nGraph}!=0)
	{ $nGraf = $opt{nGraph}; }

my$fichier_sexe = "";
if (exists $opt{sex_file}) { 
	if (-e $opt{sex_file}) { $fichier_sexe = $opt{sex_file}; }
	else { die "$fichier_sexe file not found\n"; }
	}

my$bed_cov_file = "";
if (exists $opt{bed_cov}) { 
	if (-e $opt{bed_cov}) { $bed_cov_file = $opt{bed_cov}; }
	else { die "$bed_cov_file file not found\n"; }
	}

my$splitBed = "";
if (exists $opt{split_bed}) { $splitBed = 1; }

my$cutBed = "";
my%cutB_opt = ();
if (exists $opt{cut_bed}) { 
	$cutBed = 1;
	$cutB_opt{"cutL"}=150; $cutB_opt{"maxL"}=150; $cutB_opt{"minL"}=75; $cutB_opt{"keepLast"}="merge";
	if ($opt{cut_bed}) {	## cutL:x,minL:y,maxL:z,keepLast:s
		my@cutB_arg = split(/,/,$opt{cut_bed});
		my$minL=""; my$maxL="";
		foreach my$a (@cutB_arg) {
			my$ok=0;
			foreach my$o (keys%cutB_opt) {
				if ($a =~ /$o:(.+)/) {
					if ($o eq "minL") { $minL=1; }
					if ($o eq "maxL") { $maxL=1; }
					if ($o eq "keepLast") {
						if ($1 =~ /^m/i) { $cutB_opt{"$o"} = "merge"; }
						elsif  ($1 =~ /^h/i) { $cutB_opt{"$o"} = "half"; }
						elsif  ($1 =~ /^n/i) { $cutB_opt{"$o"} = ""; }
						else { die "cut_bed opt \"keepLast\" not recognized ($1?) (\"h\" , \"m\" or \"n\")\n"; }
						}
					else { $cutB_opt{"$o"} = $1; }
					$ok=1;
					}

				

				}
			unless ($ok) { die "cut_bed opt not recognized ($a?)\n"; }
			}
		unless ($minL) { $cutB_opt{"minL"} = int($cutB_opt{"cutL"}/2); }
		unless ($maxL) { $cutB_opt{"maxL"} = $cutB_opt{"cutL"}; }
		}
	}
if ($splitBed && $cutBed) { die "not able to split overlapping and cut long intervals, sorry\n";}

my%CNV_opt;
$CNV_opt{"norm"} = "med";
if (exists $opt{normStat}) {
	if ($opt{normStat} =~ /^moy/i) { $CNV_opt{"norm"} = "moy"; }
	elsif ($opt{normStat} =~ /^std/i) { $CNV_opt{"norm"} = "std"; }
	elsif ($opt{normStat} =~ /^med/i) { $CNV_opt{"norm"} = "med"; }
	else { die "opt --normStat not recognized (MOY/STD/MED)\n"; }
	}
$CNV_opt{"normByGender"} = "";
if (exists $opt{normByGender}) {
	if ($opt{normByGender}=~/a/i) { $CNV_opt{"normByGender"} = "all"; }
	elsif ($opt{normByGender}=~/g/i) { $CNV_opt{"normByGender"} = "gono"; }
	elsif ($opt{normByGender}=~/n/i) { $CNV_opt{"normByGender"} = ""; }
	else { die "opt --normByGender not recognized (a/g)\n"; }
	}
$CNV_opt{"RefDepth"} = "mean";
if (exists $opt{totalBases}) { $CNV_opt{"RefDepth"} = "tot"; }
$CNV_opt{"RefByGender"} = 1;
if (exists $opt{totalAllChr}) { $CNV_opt{"RefByGender"} = ""; }
$CNV_opt{"seuil_region"} = 1;
if (exists $opt{seuil_region}) { $CNV_opt{"seuil_region"} = $opt{seuil_region}; }
$CNV_opt{"seuil_patient"} = 1;
if (exists $opt{seuil_patient}) { $CNV_opt{"seuil_patient"} = $opt{seuil_patient}; }
$CNV_opt{"seuil_cov"} = "";
if (exists $opt{seuil_cov}) { $CNV_opt{"seuil_cov"} = $opt{seuil_cov}; }
$CNV_opt{"seuil_deletion"} = 0.8;
if ($CNV_opt{"norm"} eq "std") { $CNV_opt{"seuil_deletion"} = -2; }
if (exists $opt{seuil_del}) { $CNV_opt{"seuil_deletion"} = $opt{seuil_del}; }
$CNV_opt{"seuil_duplication"} = 1.2;
if ($CNV_opt{"norm"} eq "std") { $CNV_opt{"seuil_duplication"} = 2; }
if (exists $opt{seuil_dup}) { $CNV_opt{"seuil_duplication"} = $opt{seuil_dup}; }
$CNV_opt{"min_following_CNV"} = "";
if (exists $opt{min_CNV}) { $CNV_opt{"min_following_CNV"} = $opt{min_CNV}; }
$CNV_opt{"max_Non_CNV"} = "";
if (exists $opt{max_nonCNV}) { $CNV_opt{"max_Non_CNV"} = $opt{max_nonCNV}; }
$CNV_opt{"min_DP"} = 0;
if (exists $opt{min_DP}) { $CNV_opt{"min_DP"} = $opt{min_DP}; }
$CNV_opt{"geneGraph"} = 1;
if (exists $opt{noCNV_byGene} || $bed_cov_file) { $CNV_opt{"geneGraph"} = ""; }
$CNV_opt{"chromGraph"} = 1;
if (exists $opt{noCNV_byChr}) { $CNV_opt{"chromGraph"} = ""; }
@{ $CNV_opt{"fields"} } = ();
if (exists $opt{CNV_fields}) {
	@{ $CNV_opt{"fields"} } = split(/,/, join(',',@{$opt{CNV_fields}}));
	my%CNVfieldList = ("min"=>1,"max"=>1,"norm"=>1);
	for (my$i=0;$i<scalar@{ $CNV_opt{"fields"} };$i++) {
		unless (exists $CNVfieldList{$CNV_opt{"fields"}[$i]}) { die $CNV_opt{"fields"}[$i]."CNV field not recognized (min,max,norm)\n"; }
		if ($CNV_opt{"fields"}[$i] eq "norm") { $CNV_opt{"fields"}[$i] = $CNV_opt{"norm"} ; }
		#$CNV_opt{"fields"}{$_} = 1;
		}
	}

##opt warnings according to actions 

#unless (exists $opt{file} || exists $opt{dir}) { die "requires a list of bam files to analysed (opt -f), or a directory where to find such files (opt -d)\n"; }
if ($bed_cov_file) {
	$CNV_tool=1;
	if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $covMut)
		{ die "actions other than CNV_detect not allowed if .cov.txt file provided\n"; }
	}
if ($CNV_tool && !$bed_cov_file) {
	$cov_Bed=1;
	}

if ($bedReport || $toReseq) {
	$cov_Bed=1;
	}

if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $covMut) {
	if (!@Files && !@raw_cov_file) { die "no .bam files (or coverage file) provided\n"; }
	}

#unless ($mutFile || ($CNV_tool && $bed_cov_file)) {
if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed) {
	unless ($bedFile || exists $opt{id} ) 
		{ die ".bed file (opt -b) or list of genes or transcripts id required (opt -i)\n"; }
	}

unless (@Thresholds) {
	if ($Sum || $allS || $byS || $printSummary || $printReports || ($CNV_tool && $CNV_opt{"seuil_cov"}))
		 { die "at least 1 threshold value required (opt -t)\n"; }
	if ($cov_Bed) {
		foreach(@covFields) {
			if ($_ eq "cov") { die "at least 1 threshold value required (opt -t)\n"; }
			}
		if ($bedReport)  { die "at least 1 threshold value required (opt -t)\n"; }
		}
	}

if ($Sum || $allS || $byS || exists $opt{genePlot} || ($CNV_tool && $CNV_opt{"geneGraph"})) { 
	unless ($ref) { die "RefSeq file required (opt -r)\n"; } 
	}

unless ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $CNV_tool || $covMut || $keepBed)
	{ die "no job selected!\n"; }


###################
#check progr installation
my(%pathCmd);
#R
$pathCmd{"R"} = `which "R"`;
if ($? eq "0") { print "R tools OK\n"; }
else { die "R tools not installed or not found\n"; }

my(%sName,%sName2,%gatkIdx); 
my(@ChromOrder,@chromLength,%chromLength,%withChr,%faIdx);
my$bedTversion = "";

if ( ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $covMut) && (!$bed_cov_file) ) {

	if ($raw_cov_file[0]) {
		open(COV, "$raw_cov_file[0]") or die "cannot open $raw_cov_file[0]\n";;
		my$firstLine = <COV>;
		my%allChr = ();
		while (my$line=<COV>) {
			my@tab = split(/\t/,$line);
			my@tab2 = split(/:/,$tab[0]);
			unless (exists $allChr{$tab2[0]}) {
				push(@ChromOrder,$tab2[0]);
				$allChr{$tab2[0]} = 1;
				}
			}
		close COV;
		#print $firstLine;
		chomp $firstLine;
		my@tab = split(/\t/,$firstLine);
		foreach my$i (0..$#tab) {
			if ($tab[$i] =~ /^Depth_for_(.+)/) {
				push(@Files,$1);
				$fName{$1} = $1;
				$sName2{$1} = $1;
				$gatkIdx{$1} = $i;
				$gatk = 1;
				}
			}
		$keepCov = "";
		}

	else {

		##check external softwares:
		##samtools
		if ($samT) {
			#system "$samT"; #write the name of calling script of picard #> /dev/null 2>&1
			$pathCmd{$samT} = `which "$samT"`;
			if ($? eq "0") { print "samtools OK\n"; }
			else {
				$samT =~ s/samtools$//;
				$samT =~ s/\/$//;
				if ($samT eq "") { $samT = "."; }
				$samT .= "/samtools";
				$pathCmd{$samT} = `which "$samT"`;
				if ($? eq "0") { print "samtools OK\n"; }
				else { $samT = ""; }
				}
			}
		else {
			$pathCmd{$samT} = `which "samtools"`;
			if ($? eq "0") { $samT = "samtools"; print "samtools OK\n"; }
			else { $samT = ""; }
			}	
		##picard tools
		if ($picard) {
			my$picardName = $picard;
			$picardName =~ s/\.jar$//;
			$picardName =~ s/picard$//;
			$picardName =~ s/\/$//;
			$picardName .= "/picard\.jar";
			if (-e $picardName) { 
				$picard = "java -jar $picardName";
				print "picard-tools OK\n"; 
				}
			else {
				print "$picardName .jar file not found; test for command\n";
				$pathCmd{$picard} = `which "$picard"`; 
				if ($? eq "0") { print "picard-tools OK\n"; }
				else { $picard = ""; }
				}
			}
		else {
			$pathCmd{"picard-tools"} = `which "picard-tools"`; 
			if ($? eq "0") { $picard = "picard-tools"; print "picard-tools OK\n"; }
			else { $picard = ""; }
			}
		##gatk
		## gatk == 1 if want to use gatk; so that it won't test for existing command if don't want to use it
		if ($mbq && !$gatk) { $gatk = 1; }
		if ($gatk) {
			if ($gatk ne "1") {
				my$gatkName = $gatk;
				$gatkName =~ s/\.jar$//;
				$gatkName =~ s/GenomeAnalysisTK$//;
				$gatkName =~ s/\/$//;
				$gatkName .= "/GenomeAnalysisTK\.jar";
				if (-e $gatkName) {
					if ($ram) { $gatk = "java -jar -Xmx$ram"."g $gatkName"; }
					else { $gatk = "java -jar $gatkName"; }
					print "GATK OK\n"; 
					}
				else {
					print "$gatkName .jar file not found; test for command\n";
					$pathCmd{$gatk} = `which "$gatk"`; 
					if ($? eq "0") {
						if ($ram) { $gatk .= " -Xmx$ram"."g"; }
						print "GATK OK\n"; 
						}
					else { die "GATK .jar file not found\n"; } #$gatk = ""; }
					}
				}
			else {
				$pathCmd{"GenomeAnalysisTK"} = `which "GenomeAnalysisTK"`; 
				if ($? eq "0") {
					if ($ram) { $gatk = "GenomeAnalysisTK -Xmx$ram"."g"; }
					else { $gatk = "GenomeAnalysisTK"; }
					print "GATK OK\n"; 
					}
				else { die "GATK cmd not found\n"; } #$gatk = ""; }
				}
			foreach (@Files) { $gatkIdx{$_} = ""; }	#to initialize
			}
		if ($mbq && !$gatk) { die "need GATK in order to filter for mbq\n"; }

		##bedtools
		if ($bedT) {
			#system "$bedT";
			$pathCmd{$bedT} = `which "$bedT"`; 
			if ($? eq "0") { print "bedtools OK\n"; }
			else {
				$bedT =~ s/bedtools$//;
				$bedT =~ s/\/$//;
				if ($bedT eq "") { $bedT = "."; }
				$bedT.="/bedtools";
				$pathCmd{$bedT} = `which "$bedT"`; 
				if ($? eq "0")  { print "bedtools OK\n"; }
				else { $bedT = ""; }
				}
			}
		else {
			$pathCmd{"bedtools"} = `which "bedtools"`; 
			if ($? eq "0") { $bedT="bedtools"; print "bedtools OK\n"; }
			else { $bedT = ""; }
			}
		if ($bedT) {
			my@bedTversion = split(/\./, `$bedT --version`);
			$bedTversion[0] =~ s/bedtools v//;
			if ( ($bedTversion[0]<2) || ($bedTversion[0]==2 && $bedTversion[1]<24) ) { $bedTversion = 1; }
			else	{ $bedTversion = 2; }
			}

		if ($mmq && !$gatk) {
			unless ($samT) { die "samtools not installed or not found\n"; }
			}
		if ($CNV_tool && ($CNV_opt{"RefDepth"} eq "tot") && !$samT) { die "samtools not installed or not found\n"; }
		if ($dedup eq "do" && !$picard) { die "picard tools not installed or not found\n"; }
		if (!$bedT && !$gatk) { die "bedtools or GATK required\n"; }

		##find sample names in bam
		##sName: name of sample in bam file ; sName2: not redundant name of sample (cat with ID if several exists)
		if ($samT) {
			my%allID;
			foreach my$f (@Files) {
				#my$sample = `$samT view -H $path{$f}$fName{$f}$extenS | awk '(\$0 ~ /^\@RG/) {print \$0}'| awk 'BEGIN{FS=OFS=\"\t\"} { for(i=1;i<=NF;i++) {if(\$i ~ /^SM/) {print \$i} } }' | awk 'BEGIN{FS=OFS=\":\"} {print \$2}'`;
				my$sample = `$samT view -H $path{$f}$fName{$f}$extenS | awk '(\$0 ~ /^\@RG/) {print \$0}'`;
				chomp $sample;
				my@info = split(/\t/,$sample);
				my($ID,$SM);
				foreach my$i (@info) {
					if($i =~ /^ID/) {
						my@tab = split(/:/,$i);
						$ID = $tab[1]; 
						}
					elsif($i =~ /^SM/) {
						my@tab = split(/:/,$i);
						$SM = $tab[1]; 
						}
					}
				if (exists $allID{$SM}) {
					$sName{$f} = $SM;
					$sName2{$f} = $SM."_".$ID;
					foreach (@{ $allID{$SM} })
						{ $sName2{$_} = $SM."_".$ID; }
					}
				else {
					$sName{$f} = $SM;
					$sName2{$f} = $SM;
					}
				push(@{ $allID{$SM} },$f);
				}
			}
		else {
			foreach (@Files) {
				$sName{$_} = $fName{$_};
				$sName2{$_} = $fName{$_};
				}
			}
		#sort @Files according to %sName2 lexical order
		@Files = (sort {$sName2{$a} cmp $sName2{$b}} (keys %sName2));

		#genome index
		if ($genom) {
			if (-e $genom) { print "$genom OK\n"; }
			else { die "$genom not found\n"; }
			if (-e "$genom.fai") {
				@chromLength = `cut -f1-2 $genom.fai`;
				chomp @chromLength;
				if ($chromLength[0] =~ /^chr/) {
					$withChr{"all"}="_wChr.bed";
					foreach (@Files) { $withChr{$_}="_wChr.bed"; } 
					}
				else {
					$withChr{"all"}="_0Chr.bed";
					foreach (@Files) { $withChr{$_}="_0Chr.bed"; } 
					}
				foreach (@chromLength) {
					my@tab = split(/\t/,$_);
					push(@ChromOrder,$tab[0]);
					$chromLength{$tab[0]} = $tab[1];
					}
				}
			else { 
				if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $covMut) { die "index genome.fa.fai required (\"samtools faidx genome.fa\")\n"; }
				}
			}
		else { die "reference genome.fa required\n"; }
		#bam index
		if (@Files) {
			if ($samT) {
				foreach my$file (@Files) {
					unless (-e "$path{$file}$fName{$file}$extenS.bai") {
						my$cmd = "$samT index $path{$file}$fName{$file}$extenS";
						print "$cmd\n";
						system "$cmd";
						}
					my@tmp = `$samT idxstats $path{$file}$fName{$file}$extenS | cut -f1`;
					chomp @tmp;
					foreach (@tmp) {
						if ($_ =~ /^\w/) { push(@{ $faIdx{$file} }, $_); }
						}
					}

				}
			else {
				if (@ChromOrder) {
					foreach my$file (@Files) {
						foreach (@ChromOrder)
							{ push(@{ $faIdx{$file} }, $_); }
						}
					}
				else {
					if ($CNV_tool && $CNV_opt{"RefDepth"} eq "tot")
						{ die "cannot determine chr idx of bam files\n"; }
					}
				}
			}

		}

	#read gender file
	if ($fichier_sexe) {
		open(PATIENTS, "$fichier_sexe") or die "cannot read $fichier_sexe\n";
		foreach my $ligne (<PATIENTS>) {
			$ligne =~ m/(\S+)\s+(\S+)/;
			my$ok="";
			foreach my$file (@Files) {
				if ($1 eq $sName2{$file}) {
					$ok=1; last;
					}
				}
			unless ($ok) { die "sample $1 not found in bam files\n"; }
			}
		close PATIENTS;
		}
	}



#create output dirs
use POSIX qw/strftime/;
my$outdir = "";
my$chromLength = "";
if (exists $opt{outdir}) { 
	$outdir = $opt{outdir}; 
	$outdir =~ s/\/$//;
	if (-d $outdir) {
		if ($CNV_tool && $bed_cov_file) { $outdir .= "/CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
		else { $outdir .= "/covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
		}
	}
else {
	if ($CNV_tool && $bed_cov_file) { $outdir = "CNV_analysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
	else { $outdir = "covAnalysis-".strftime('%y-%m-%d-%Hh%M',localtime); }
	}
mkdir($outdir);
if ($byS || $printReports || $bedReport) { 
	foreach (@Files)
		{ mkdir("$outdir/cov\_$sName2{$_}"); }
	}
if ($allS || $Sum)
	{ mkdir("$outdir/cov_All"); }
if ($raw_cov_file[0]) {
	my$cmd = "tail -n +2 $raw_cov_file[0] > $outdir/all.cov";
	print "$cmd\n";
	system "$cmd";
	}
else {
	if (@chromLength && !$gatk) {	
		$chromLength = "$outdir/chromLength.txt";		#used by bedtools
		open (my$fhOut, ">", "$chromLength");
		foreach(@chromLength) { print $fhOut "$_\n"; }
		close $fhOut;
		}
	}



###################
##Job 1:find coordinates (genes, transcripts, bed, mut)

##if bedFile provided:
my(%Bed);	#$Bed{$chr}{$start} = $end , in 1-based
if ($bedFile) {
	print "read $bedFile\n";
	if ($lenForBed) {
		print "add $lenForBed bp to $bedFile intervals ends\n";
		my$expandedBed = "$outdir/$bedName";
		$expandedBed =~ s/.bed$//;
		$expandedBed .= "_w$lenForBed.bed";
		addLength2Bed($bedFile,$expandedBed,$lenForBed);
		$bedFile = $expandedBed;
		}
	#transform in 1-based coord; keep longest intervals
	%Bed = readBed($bedFile);
	#merge overlapping inyervals
	foreach my$chr (keys%Bed)
		{ %{ $Bed{$chr} } = merge(\%{ $Bed{$chr} }); }
	#print merged bed
	printBed("original",\%Bed);
	if ($splitBed) {
		print "split overlapping intervals from $bedFile\n";
		$splitBed = "$outdir/$bedName";
		$splitBed =~ s/.bed$//;
		$splitBed .= "_split.bed";
		split_Bed($bedFile,$splitBed,\@ChromOrder); 
		$bedFile = $splitBed;
		}
	elsif ($cutBed) {
		print "cut intervals from $bedFile 
	(above $cutB_opt{maxL} bp ; in $cutB_opt{cutL} bp pieces , if longer than  $cutB_opt{minL} bp , else ";
	if ($cutB_opt{"keepLast"} eq "merge") { print "merge 2 last)\n"; }
	elsif ($cutB_opt{"keepLast"} eq "half") { print "keep 2 last with half of their sum)\n"; }
	else { print "through it)\n"; }
		$cutBed = "$outdir/$bedName";
		$cutBed =~ s/.bed$//;
		$cutBed .= "_cut".$cutB_opt{"cutL"}.".bed";
		cut_Bed($bedFile,$cutBed,\@ChromOrder,\%cutB_opt); 
		$bedFile = $cutBed;
		}
	}

my$keepTmp = "";
my%tmpFile;
foreach (@Files) { $tmpFile{$_} = ""; }

##if file of known mutations provided (in 1-based coordinates)
my(%Mut);
if ($mutFile) { 
	print "read $mutFile\n"; 
	%Mut = readMut($mutFile);		#$Mut{$chr}{$startMut} = $infoMut (1-based coord)
	if($covMut) { 
		if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed || $CNV_tool) 
			{ $keepTmp = 1; }
		%tmpFile = depthMut($mutFile,\%path,$extenS,\@Files,\%fName,\%sName,\%sName2,\%Mut,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$mbq,$dedup,$threads,$chromLength,$bedT,$bedTversion,$samT,$picard,$gatk,$genom);
		}
	}

##find and design transcripts:
my(@hashSub,%geneNM,%NMgene,%NMchr,%NMsens,%NMstartCod,%NMendCod,%Regions,%txtRegions,%NM_Ex,%txt_NM_Ex,%Genes,%RegBed,%NMlength,%intron,%UTR,%Cod,%RegMut,%coordBed,$id2Bed);

if ($Sum || $allS || $byS || (@IDs && !$bedFile) || $coordPlot || $printSummary || $printReports || ($CNV_tool && $CNV_opt{"geneGraph"})) {

##print in $idFile lines of RefSeq matching each $id of @IDs
my$idFile="$outdir/id_List.txt";
if ($opt{id})
	{ gene2Ref($idFile,$ref,\@IDs)}
else
	##if no list of genes/transcripts provided, finds transcripts overlapping at least partially with bed intervals
	{ @IDs = geneFromBed2($idFile,$ref,\%Bed) ; }

##for list of genes/transcripts, extract foreach NM_id starts and ends of each coding exons
##and transform in 1-based coordinates
@hashSub = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$noOverlap,$nonCod,$wUTR,$id2Bed);
#return (\%geneNM,\%NMgene,\%NMchr,\%NMsens,\%NMstartCod,\%NMendCod,\%Regions,\%NM_Ex,\%Genes,\%Bed);
%geneNM = %{$hashSub[0]};		# @{ $geneNM{$gene} } = [$NM1,...]
%NMgene = %{$hashSub[1]};		# $NMgene{$NM} = $gene;
%NMchr = %{$hashSub[2]};		# %NMchr : key = NM, value = chr
%NMsens = %{$hashSub[3]};		# %NMsens : key = NM, value = "+" or "-"
%{ $NMstartCod{"raw"} } = %{$hashSub[4]};		# %NMstartCod : key = NM, value = start of coding sequence
%{ $NMendCod{"raw"} } = %{$hashSub[5]};		# %NMendCod : key = NM, value = end of coding sequence
%{ $Regions{"raw"} } = %{$hashSub[6]};		# $Regions{chr}{NM}{start of region} = end of region
%{ $NM_Ex{"raw"} } = %{$hashSub[7]};		# %NM_Ex{NM}{start of region}{start of exon} = end of exon
%Genes = %{$hashSub[8]};
unless ($bedFile) { 
	%Bed = %{$hashSub[9]};		#$Bed{$chr}{$start} = $end; 
	foreach my$chr (keys%Bed)
		{ %{ $Bed{$chr} } = merge(\%{ $Bed{$chr} }); }
	}
#if ($allS || $byS || $Sum) {
#	my$nG=scalar(keys%geneNM);
#	if ($nG>200) {
#		print "$nG genes to analyse ; continue?(Y/n)\n";
#		my$doIt = <STDIN>; chomp $doIt;
#		if ($doIt =~ /^n$/i)
#			{ die "stop analysis\n"; }
#		}
#	}

##for summary txt file:
if (($keepBed || $cov_Bed || $CNV_tool) && (!$bedFile)) {
	$bedName="allID";
	$id2Bed = "$outdir/$bedName.bed";
	}
@hashSub = Id2Coord($idFile,$lenTxt5,$lenTxt3,$UpInTxt,$DownInTxt,$noOverlap,$nonCod,$UTRinTxt,$id2Bed);
%txtRegions = %{$hashSub[6]};		# as %Regions, but for summary txt file
%txt_NM_Ex = %{$hashSub[7]};		# as %NM_Ex, but for summary txt file
%coordBed = %{$hashSub[9]};		# as %Bed, but for coordPlot and cov_Bed if no bedfile
foreach my$chr (keys%coordBed)
	{ %{ $coordBed{$chr} } = merge(\%{ $coordBed{$chr} }); }

unlink "$idFile" or warn "Could not unlink: $!";

#changes Regions{gene} according to each NM (without -A N)
if ($All) {
	@hashSub = NM2GeneRegion(\%Genes,\%geneNM,\%NMchr,\%{ $Regions{"raw"} },\%{ $NM_Ex{"raw"} });
	%{ $Regions{"raw"} } = %{$hashSub[0]};
	%{ $NM_Ex{"raw"} } = %{$hashSub[1]};

	@hashSub = NM2GeneRegion(\%Genes,\%geneNM,\%NMchr,\%txtRegions,\%txt_NM_Ex);
	%txtRegions = %{$hashSub[0]};
	%txt_NM_Ex = %{$hashSub[1]};
	}

#links bed intervals to Regions, eventually changes Regions according to bed (with -L Y)
if ($Expand) {
	print "change regions intervals according to bed\n";
	if($All) {
		foreach my$gene(keys%Genes)
			{
			my@NMs =  @{ $geneNM{$gene} };
			my$chr = $NMchr{$NMs[0]};
			@hashSub = changeRegion2G(\@NMs,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $NM_Ex{"raw"} },\%{ $Bed{$chr} });
			%{ $Regions{"raw"}{$chr}{$gene} } = %{$hashSub[0]};
			%{ $NM_Ex{"raw"} } = %{$hashSub[1]};
			%{ $RegBed{"raw"}{$gene} } = %{$hashSub[2]};	#$RegBed{$gene}{$startReg}{$startBed} = $endBed;
			}
		}
	else {
		foreach my$NM (keys%NM_Ex) {
			@hashSub = changeRegion2N(\%{ $Regions{"raw"}{$NMchr{$NM}}{$NM} },\%{ $NM_Ex{"raw"}{$NM} },\%{ $Bed{$NMchr{$NM}} });
			%{ $Regions{"raw"}{$NMchr{$NM}}{$NM} } = %{$hashSub[0]};
			%{ $NM_Ex{"raw"}{$NM} } = %{$hashSub[1]};
			%{ $RegBed{"raw"}{$NM} } = %{$hashSub[2]};	#$RegBed{$NM}{$startReg}{$startBed} = $endBed;
			}
		}
	}
else {
	print "change bed intervals according to genes\n";
	%{ $RegBed{"raw"} } = linkBed(\%{ $Regions{"raw"} },\%Bed);
	}

#eliminates $NM with no corresponding cov bed
if ($All) { @hashSub = notAnalysedG(\%Genes,\%{ $Regions{"raw"} },\%{ $NM_Ex{"raw"} },\%{ $RegBed{"raw"} }); }
else  { @hashSub = notAnalysedN(\%Genes,\%NMgene,\%{ $Regions{"raw"} },\%{ $NM_Ex{"raw"} },\%{ $RegBed{"raw"} }); }
%Genes = %{$hashSub[0]};
%{ $Regions{"raw"} } = %{$hashSub[1]};
%{ $NM_Ex{"raw"} } = %{$hashSub[2]};
%{ $RegBed{"raw"} } = %{$hashSub[3]};


#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#for end of exon = x, start of next exon = x
@hashSub = transposeReg($spacer,\%{ $Regions{"raw"} });
$spacer = $hashSub[0];
%NMlength = %{$hashSub[1]};			#$NMlength{$NM} = $end of region (for start of region = 0)
%{ $Regions{"coord0"} } = %{$hashSub[2]};	#$Regions{"coord0"}{$NM}{start of region} = $end of region (for start of region = 0)
	
#$NM_Ex{"coord0"}{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
#$NMstartCod{"coord0"}{$NM} = $start of coding sequence (for start of region = 0)
#$NMendCod{"coord0"}{$NM} = $end of coding sequence (for start of region = 0)
if ($All) {
	foreach my$gene(keys%{ $Regions{"coord0"} }) {
		foreach my$NM (@{ $geneNM{$gene} }) {
			@hashSub = transposeNM($wUTR,$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%{ $Regions{"raw"}{$NMchr{$NM}}{$gene} },\%{ $Regions{"coord0"}{$gene} },\%{ $NM_Ex{"raw"}{$NM} }); 
			$NMstartCod{"coord0"}{$NM} = $hashSub[0];
			$NMendCod{"coord0"}{$NM} = $hashSub[1];
			%{ $NM_Ex{"coord0"}{$NM} } = %{$hashSub[2]};
			}
		}
	}
else {
	foreach my$NM (keys%{ $Regions{"coord0"} }) { 
		@hashSub = transposeNM($wUTR,$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%{ $Regions{"raw"}{$NMchr{$NM}}{$NM} },\%{ $Regions{"coord0"}{$NM} },\%{ $NM_Ex{"raw"}{$NM} });
		$NMstartCod{"coord0"}{$NM} = $hashSub[0];
		$NMendCod{"coord0"}{$NM} = $hashSub[1]; 
		%{ $NM_Ex{"coord0"}{$NM} } = %{$hashSub[2]};
		}
	}

#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons
if ($All)
	{ @hashSub = designExons1($wUTR,\%Genes,\%geneNM,\%{ $Regions{"coord0"} },\%{ $NM_Ex{"coord0"} },\%{ $NMstartCod{"coord0"} },\%{ $NMendCod{"coord0"} }); }
else
	{ @hashSub = designExons2($wUTR,\%{ $Regions{"coord0"} },\%{ $NM_Ex{"coord0"} },\%{ $NMstartCod{"coord0"} },\%{ $NMendCod{"coord0"} }); }
#return(\%introns,\%UTR,\%Cod);
%{ $intron{"coord0"} } = %{$hashSub[0]};	# $intron{"coord0"}{$NM}{$startIntron} = $endIntron (for start of region = 0)
%{ $UTR{"coord0"} } = %{$hashSub[1]};		# $UTR{"coord0"}{$NM}{$startUTR} = $endUTR (for start of region = 0)
%{ $Cod{"coord0"} } = %{$hashSub[2]};		# $Cod{"coord0"}{$NM}{$startCod} = $endCod (for start of region = 0)

if ($mutFile)
	{ %{ $RegMut{"raw"} } = linkMut(\%{ $Regions{"raw"} },\%Mut); }	#$RegMut{$NM}{$startReg}{$startMut} = $infoMut

#$RegBed{"coord0"}{$NM}{$startBed00} = $endBed00 (start of Region=0 )
#$RegMut{"coord0"}{$NM}{$mut00} = $infoMut (start of Region=0 )
@hashSub = transposeBed(\%{ $Regions{"raw"} },\%{ $Regions{"coord0"} },\%{ $RegBed{"raw"} },\%{ $RegMut{"raw"} });
%{ $RegBed{"coord0"} } = %{$hashSub[0]};
%{ $RegMut{"coord0"} } = %{$hashSub[1]};

foreach my$gene (keys%Genes) {
	my@NMs =  @{ $geneNM{$gene} };
	my$chr = $NMchr{$NMs[0]};
	my$sens = $NMsens{$NMs[0]};
	if ($Rev && $sens eq "-") {
		if ($All) {
			@hashSub = ReverseGene1($gene,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $RegBed{"coord0"}{$gene} },\%{ $RegMut{"coord0"}{$gene} });
			%{ $Regions{"rev"}{$gene} } = %{$hashSub[0]};
			%{ $RegBed{"rev"}{$gene} } = %{$hashSub[1]};
			%{ $RegMut{"rev"}{$gene} } = %{$hashSub[2]};
			foreach my$NM (@NMs) {
				@hashSub = ReverseGene2($NM,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} });
				%{ $NM_Ex{"rev"}{$NM} } = %{$hashSub[0]};
				%{ $intron{"rev"}{$NM} } = %{$hashSub[1]};
				%{ $UTR{"rev"}{$NM} } = %{$hashSub[2]};
				%{ $Cod{"rev"}{$NM} } = %{$hashSub[3]};
				}
			}
		else {
			foreach my$NM (@NMs) {
				@hashSub = ReverseNMs($NM,$NMlength{$NM},\%{ $Regions{"coord0"}{$NM} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} },\%{ $RegBed{"coord0"}{$NM} },\%{ $RegMut{"coord0"}{$NM} });
				%{ $Regions{"rev"}{$NM} } = %{$hashSub[0]};
				%{ $NM_Ex{"rev"}{$NM} } = %{$hashSub[1]};
				%{ $intron{"rev"}{$NM} } = %{$hashSub[2]};
				%{ $UTR{"rev"}{$NM} } = %{$hashSub[3]};
				%{ $Cod{"rev"}{$NM} }= %{$hashSub[4]};
				%{ $RegBed{"rev"}{$NM} } = %{$hashSub[5]};
				%{ $RegMut{"rev"}{$NM} } = %{$hashSub[6]};
				}
			}
		}
	else {
		if ($All) {
			%{ $Regions{"rev"}{$gene} } = %{ $Regions{"coord0"}{$gene} };
			if (exists $RegBed{"coord0"}{$gene}) { %{ $RegBed{"rev"}{$gene} } = %{ $RegBed{"coord0"}{$gene} }; }
			if (exists $RegMut{"coord0"}{$gene}) { %{ $RegMut{"rev"}{$gene} } = %{ $RegMut{"coord0"}{$gene} }; }
			}
		else {
			foreach my$NM (@NMs) {
				%{ $Regions{"rev"}{$NM} } = %{ $Regions{"coord0"}{$NM} };
				if (exists $RegBed{"coord0"}{$NM}) { %{ $RegBed{"rev"}{$NM} } = %{ $RegBed{"coord0"}{$NM} }; }
				if (exists $RegMut{"coord0"}{$NM}) { %{ $RegMut{"rev"}{$NM} } = %{ $RegMut{"coord0"}{$NM} }; }
				}
			}
		foreach my$NM (@NMs) {
			if (exists $NM_Ex{"coord0"}{$NM}) { %{ $NM_Ex{"rev"}{$NM} } = %{ $NM_Ex{"coord0"}{$NM} }; }
			if (exists $intron{"coord0"}{$NM}) { %{ $intron{"rev"}{$NM} } = %{ $intron{"coord0"}{$NM} }; }
			if (exists $UTR{"coord0"}{$NM}) { %{ $UTR{"rev"}{$NM} } = %{ $UTR{"coord0"}{$NM} }; }
			if (exists $Cod{"coord0"}{$NM}) { %{ $Cod{"rev"}{$NM} } = %{ $Cod{"coord0"}{$NM} }; }
			}
		}
	}

}


###################
#Job 2: bams analysis:
my(%allInterval,$intervalName,%headers);

if ($Sum || $allS || $byS || $printSummary || $printReports || $covPlot || $coordPlot || $interS || $cov_Bed) {

	if (scalar(keys%{ $Regions{"raw"} }) > 0) {
		#merge intervals from %Regions (for example, if several transcripts for the same gene)
		#% $Regions{"raw"}{chr}{NM}{exonstart} = exonend
		#% $allInterval{chr}{start of region} = end of region
		#print bed corresponding to regions
		%allInterval = mergeIntervals(%{ $Regions{"raw"} });
		$intervalName = "regions";
		printBed($intervalName,\%allInterval);
		if ($bedFile || ($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
			$intervalName = "merge";
			open (MERGE, ">$outdir/$intervalName.bed") || die "can't create file $outdir/$intervalName.bed\n";
			open (BED, "$outdir/regions_0Chr.bed") || die "can't open file $outdir/regions_0Chr.bed\n";
			while (my$line=<BED>) { print MERGE $line; }
			close BED;
			if ($bedFile) {
				open (BED, "$outdir/original_0Chr.bed") || die "can't open file $outdir/original_0Chr.bed\n";
				while (my$line=<BED>) { print MERGE $line; }
				close BED;
				}
			if (($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream)) {
				printBed("txtRegions",\%coordBed);
				open (BED, "$outdir/txtRegions_0Chr.bed") || die "can't open file $outdir/txtRegions_0Chr.bed\n";
				while (my$line=<BED>) { print MERGE $line; }
				close BED;
				}
			close MERGE; 
			my%Merge = readBed("$outdir/$intervalName.bed");
			foreach my$chr (keys%Merge)
				{ %{ $Merge{$chr} } = merge(\%{ $Merge{$chr} }); }
			printBed($intervalName,\%Merge);
			unlink "$outdir/$intervalName.bed";
			}
		}
	else {
		$intervalName = "original";
		}

	if ($raw_cov_file[0]) {	
		
		##check that all intervals are present in cov.file
		my%Intervals = readBed("$outdir/$intervalName\_0Chr.bed");	#$covbed{$chr}{$start} = $end;	transform in 1-based coord
		foreach my$chr (keys%Intervals) {
			my$withinChr = 0;
			my@Starts = sort{$a<=>$b}(keys%{ $Intervals{$chr} });
			my$s = 0;				#idx of @Starts
			my$pos = $Starts[$s];			#current position
			open(COV, "$raw_cov_file[0]") || die "can't open file $raw_cov_file[0]\n";
			while (my$line=<COV>) {
				chomp $line;
				my@tab = split(/\t/,$line);
				$tab[0] =~ s/chr//;
				my@tab2 = split(/:/,$tab[0]);
				if ($tab2[0] eq $chr) {
					$withinChr = 1;
					my$ok=1;
					while ($ok) {
						if ( $tab2[1] < $Starts[$s] ) { $ok=0; }
						else {
							if ( $tab2[1] <= $Intervals{$chr}{$Starts[$s]} ) {
								if ($tab2[1] == $pos) { $pos++; $ok=0; }
								else { die "intervals to be analysed not present in cov file ( $chr:$pos )\n"; }
								}
							else { 
								$s++;
								$pos = $Starts[$s];
								}
							}
						}
					}
				else {
					if ($withinChr) { last; }
					}
				}
			unless ($withinChr) { die "intervals to be analysed not present in cov file ( $chr )\n"; }
			}
		}

	 else {
		##perform depth analysis
		if ($gatk) {
			my($r1,$r2) = gatkCov($intervalName,\%path,$extenS,\@Files,\%fName,\%sName,$outdir,"all.cov",$withChr{"all"},$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom);
			%gatkIdx = %$r1;
			@{ $headers{"$outdir/all.cov"} } = @$r2;
			}
		else {
			$keepTmp = 0;
			bedToolsCov($intervalName,\%path,$extenS,\@Files,\%fName,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
			}
		}
	}



###################
#Job 3: Graphs:

if ($allS || $byS || $Sum || ( ($printReports || $printSummary) && (($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream)) ) ) {

	my%NMnotCov;	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my%NM_UC;	##NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	if($printReports) {
		foreach (@Files) {
			open(OUT, ">", "$outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2{$_}/$outfile$sName2{$_}\_geneReport.txt\n";
			print OUT "## SAMPLE : $sName2{$_}\n\n";
			if ($pThreshold) {
				print OUT "## depth threshold : $pThreshold x\n\n";
				}
			close OUT;
			}
		}


	##foreach gene:
	foreach my$gene (sort(keys%Genes)) {

		print "analysing cov in $gene\n";
		my@NMs =  @{ $geneNM{$gene} };
		my$chr = $NMchr{$NMs[0]};
		my$sens = $NMsens{$NMs[0]};

		unless ($All) {
			my%NMinterval;
			foreach my$NM (@NMs) {
				%{ $NMinterval{$chr}{$NM} } = %{ $Regions{"raw"}{$chr}{$NM} };
				}
			my%tmp = mergeIntervals(%NMinterval);
			%{ $Regions{"raw"}{$chr}{$gene} } = %{ $tmp{$chr} };
			}

		##initialyzes %NMCov: @{ $NMCov{$threshold}{$NM}{$nReg} } = [0 foreach pos of Regions{$NM}{$startReg}]
		my%NMCov;
		if ($Sum) {
			foreach my$threshold (@Thresholds) {
				if ($All) {
					my$r=0; ##idx of reg of $NM
					foreach my$startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}{$chr}{$gene} }) {
						my$pos=$startReg;
						while ($pos <= $Regions{"raw"}{$chr}{$gene}{$startReg} ) { 
							push (@{ $NMCov{$gene}{$threshold}{$r} }, 0);
							$pos++;
							}
						$r++;
						}
					}
				else {
					foreach my$NM (@NMs) {
						my$r=0; ##idx of reg of $NM
						foreach my$startReg (sort{$a<=>$b}keys%{ $Regions{"raw"}{$chr}{$NM} }) {
							my$pos=$startReg;
							while ($pos <= $Regions{"raw"}{$chr}{$NM}{$startReg} ) { 
								push (@{ $NMCov{$NM}{$threshold}{$r} }, 0);
								$pos++;
								}
							$r++;
							}
						}
					}
				}
			}
		##foreach depth files from bedtools coveragedepth -d:
		##intersection hash-intervals and gene-coordinates
		##scan bedtools files : create a hash : cov foreach position in intervals from %allInterval: #$allCov{$chr}{$loc} = $cov
		##create a hash : foreach NM, foreach file, foreach exon, array of values for ordered positions
		my%NMdepth;
		my%covStart01;
		my%covEnd01;
		foreach my$file (@Files) {
			print "\tfor bam $fName{$file}\n";
			##scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
			##create 2 hash : 
			## %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = depth
			## %notCov: start and end of each not covered domain within %allInterval : $notCov{$start} = $end
			if ($gatk)
				{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },$gatk,1); }
			else 
				{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },$gatk,1); }
			my%allDepth = %{ $hashSub[0] };
			my%notCov = %{ $hashSub[1] };
			my%notCovStarts = %{ $hashSub[2] };

			if ($allS || $byS || $printSummary || $printReports) {
				##for depth-line :
				##create a hash : foreach file, foreach NM, foreach exon, return an array of values for ordered positions
				## @{ $NMdepth{$NM}{$file}{$startReg} } = [ depth foreach ordered bp of exon ]
				if ($All)
					{ %{ $NMdepth{$gene}{$file} } = depthLine(\%{ $Regions{"raw"}{$chr}{$gene} },\%allDepth); }
				else {
					foreach my$NM (@NMs)
						{ %{ $NMdepth{$NM}{$file} } = depthLine(\%{ $Regions{"raw"}{$chr}{$NM} },\%allDepth); }
					}

				##for cov-domains:
				##intersections not covered regions and exons
				## printReports  , if $wUTR = $UTRinTxt and if $lenForTxt = $len
				##starts and ends of not covered regions within exons
				## $NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
				## @{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]
				my(%NMcovStart,%NMcovEnd);
				my$printR = "";
				if ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) ) { $printR = $printReports; }
				if ($All) {
					@hashSub = notCovDomains2(\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%notCov,\%notCovStarts);
					%{ $NMcovStart{$gene} } = %{ $hashSub[0] } ;
					%{ $NMcovEnd{$gene} } = %{ $hashSub[1] };
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($All,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $NM_Ex{"raw"}{$NM} },$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%notCov,\%notCovStarts,\%NMnotCov,$printR);
						%NMnotCov = %{ $hashSub[0] };
						%{ $NM_UC{$NM}{$fName{$file}} } = %{ $hashSub[3] };
						}
					}
				else {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($All,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $NM_Ex{"raw"}{$NM} },$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%notCov,\%notCovStarts,\%NMnotCov,$printR);
						%NMnotCov = %{ $hashSub[0] } ;
						%{ $NMcovStart{$NM} } = %{ $hashSub[1] };
						%{ $NMcovEnd{$NM} } = %{ $hashSub[2] };
						%{ $NM_UC{$NM}{$fName{$file}} } = %{ $hashSub[3] };
						}
					}

				##transposition and splicing: 1st position of 1st exon = 1, 
				##and	if end of exon = x, start of next exon = x+1
				## $covEnd01{$NM}{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
				## @{ $covStart01{$NM}{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
				if ($allS || $byS) {
					if ($All) {
						@hashSub = transposeCov(\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"coord0"}{$gene} },\%{ $NMcovStart{$gene} },\%{ $NMcovEnd{$gene} });
						%{ $covStart01{$gene}{$file} } = %{ $hashSub[0] };
						%{ $covEnd01{$gene}{$file} } = %{ $hashSub[1] };
						}
					else {
						foreach my$NM (@NMs) {
							@hashSub = transposeCov(\@Thresholds,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $Regions{"coord0"}{$NM} },\%{ $NMcovStart{$NM} },\%{ $NMcovEnd{$NM} });
							%{ $covStart01{$NM}{$file} } = %{ $hashSub[0] };
							%{ $covEnd01{$NM}{$file} } = %{ $hashSub[1] };
							}
						}
					}
				}

			## @{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
			if ($Sum) {
				if ($All) {
					foreach my$threshold (@Thresholds)
						{ %{ $NMCov{$gene}{$threshold} } = covByThreshold($threshold,\%{ $Regions{"raw"}{$chr}{$gene} },\%allDepth,\%{ $NMCov{$gene}{$threshold} }); }
					}
				else {
					foreach my$NM (@NMs) {
						foreach my$threshold (@Thresholds)
							{ %{ $NMCov{$NM}{$threshold} } = covByThreshold($threshold,\%{ $Regions{"raw"}{$chr}{$NM} },\%allDepth,\%{ $NMCov{$NM}{$threshold} }); }
						}
					}
				}
			}

		##foreach NM, find max cov, among all samples (A) or foreach sample (S)
		my(%maxCovA,%maxCovS);	##$maxCov{$NM} = $maxDepth;
		if ($allS || $byS) {
			if ($maxGr) {
				if ($All) {
					$maxCovA{$gene} = $maxGr;
					foreach (@Files) { $maxCovS{$gene}{$_} = $maxGr; }
					}
				else {
					foreach my$NM (@NMs) {
						$maxCovA{$NM} = $maxGr;
						foreach (@Files) { $maxCovS{$NM}{$_} = $maxGr; }
						}
					}
				}
			else {
				if ($All) { 
					@hashSub = maxCov(\@Files,\%{ $NMdepth{$gene} },\%{ $Regions{"coord0"}{$gene} }); 
					$maxCovA{$gene} = $hashSub[0];
					%{ $maxCovS{$gene} } = %{$hashSub[1]};
					}
				else {
					foreach my$NM (@NMs) { 
						@hashSub = maxCov(\@Files,\%{ $NMdepth{$NM} },\%{ $Regions{"coord0"}{$NM} });
						$maxCovA{$NM} = $hashSub[0];
						%{ $maxCovS{$NM} } = %{$hashSub[1]};
						}
					}
				}
			}

		##reverse if sens "-"
		if ($Rev) {
			if ($sens eq "-") {
				if ($All) {
					@hashSub = ReverseCov_Gene($Sum,$allS,$byS,$gene,$NMlength{$gene},\@Thresholds,\%{ $NMdepth{$gene} },\%{ $covEnd01{$gene} },\%{ $covStart01{$gene} },\%{ $NMCov{$gene} });
					%{ $NMdepth{$gene} } = %{$hashSub[0]};
					%{ $covEnd01{$gene} } = %{$hashSub[1]};
					%{ $covStart01{$gene} } = %{$hashSub[2]};
					%{ $NMCov{$gene} } = %{$hashSub[3]};
					}
				else {
					foreach my$NM (@NMs) {
						@hashSub = ReverseCov_NMs($Sum,$allS,$byS,$NM,$NMlength{$NM},\@Thresholds,\%{ $NMdepth{$NM} },\%{ $covEnd01{$NM} },\%{ $covStart01{$NM} },\%{ $NMCov{$NM} });
						%{ $NMdepth{$NM} } = %{$hashSub[0]};
						%{ $covEnd01{$NM} } = %{$hashSub[1]};
						%{ $covStart01{$NM} } = %{$hashSub[2]};
						%{ $NMCov{$NM} } = %{$hashSub[3]};
						}
					}
				}
			}

		##@{ $NMCov{$NM}{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
		##$NMCovEnd{$NM}{$threshold}{$ex}{$start}=$end
		##$NMCovVal{$NM}{$threshold}{$ex}{$start}=$value
		my(%NMCovEnd,%NMCovVal);
		if ($Sum) {
			if ($All) {
				@hashSub= covDomains(\@Thresholds,\%{ $Regions{"rev"}{$gene} },\%{ $NMCov{$gene} });
				%{ $NMCovEnd{$gene} } = %{$hashSub[0]};		
				%{ $NMCovVal{$gene} } = %{$hashSub[1]};
				}
			else {
				foreach my$NM (@NMs) {
					@hashSub= covDomains(\@Thresholds,\%{ $Regions{"rev"}{$NM} },\%{ $NMCov{$NM} });
					%{ $NMCovEnd{$NM} } = %{$hashSub[0]};		
					%{ $NMCovVal{$NM} } = %{$hashSub[1]};
					}
				}
			}

		##graphiques R
		my@colors=("gold","orange","orangered","red1","magenta4");

		##graph covByGene
		if ($Sum) { 
			if ($All)
				{ graphSumG($nGraf,$gene,$suff,$outdir,$sens,$chr,$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $RegMut{"rev"}{$gene} },\%{ $NMCovEnd{$gene} },\%{ $NMCovVal{$gene} }); }
			else
				{ graphSumN($nGraf,$gene,$suff,$outdir,$sens,$chr,\%NMlength,\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $RegMut{"rev"} },\%NMCovEnd,\%NMCovVal); }
			}

		##graph covBySample
		if ($allS) {
			if ($All) {
				my$ok=0;
				if ($gThreshold) {
					foreach my$NM (@NMs) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok)
					{ graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"rev"}{$gene} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $NMdepth{$gene} },\%{ $covStart01{$gene} },\%{ $covEnd01{$gene} },\%{ $RegMut{"rev"}{$gene} },\%fName,\%sName2); }
				}
			else {
				foreach my$NM (@NMs) {
					my$ok=0;
					if ($gThreshold) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok)
						{ graphAllSampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$NM},$NMlength{$NM},$NMstartCod{$NM},$NMendCod{$NM},\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $Regions{"rev"}{$NM} },\%{ $NM_Ex{"rev"}{$NM} },\%{ $RegBed{"rev"}{$NM} },\%{ $intron{"rev"}{$NM} },\%{ $UTR{"rev"}{$NM} },\%{ $Cod{"rev"}{$NM} },\%{ $NMdepth{$NM} },\%{ $covStart01{$NM} },\%{ $covEnd01{$NM} },\%{ $RegMut{"rev"}{$NM} },\%fName,\%sName2); }
					}
				}
			}

		if ($byS) {
			if ($All) { 
				my$ok=0;
				if ($gThreshold) {
					foreach my$NM (@NMs) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					}
				else { $ok=1; }
				if ($ok)
					{ graphBySampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$gene},\%{ $maxCovS{$gene} },\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"rev"}{$gene} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $NMdepth{$gene} },\%{ $covStart01{$gene} },\%{ $covEnd01{$gene} },\%{ $RegMut{"rev"}{$gene} },\%fName,\%sName2); }
				}
			else {
				foreach my$NM (@NMs) {
					my$ok=0;
					if ($gThreshold) {
						foreach my$file (@Files) {
							if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
								{ $ok=1; last; }
							}
						}
					else { $ok=1; }
					if ($ok)
						{ graphBySampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMstartCod{$NM},$NMendCod{$NM},$NMlength{$NM},\%{ $maxCovS{$NM} },\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $Regions{"rev"}{$NM} },\%{ $NM_Ex{"rev"}{$NM} },\%{ $RegBed{"rev"}{$NM} },\%{ $intron{"rev"}{$NM} },\%{ $UTR{"rev"}{$NM} },\%{ $Cod{"rev"}{$NM} },\%{ $NMdepth{$NM} },\%{ $covStart01{$NM} },\%{ $covEnd01{$NM} },\%{ $RegMut{"rev"}{$NM} },\%fName,\%sName2); }
					}
				}
			}
		}
	##summary , if $wUTR = $UTRinTxt and if $lenForTxt = $len
	##$NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($printSummary && ( ($UTRinTxt == $wUTR) && ($lenTxt5 == $len5) && ($lenTxt3 == $len3) && ($UpInTxt == $upstream) && ($DownInTxt == $downstream) )) {
		open (OUT, ">$outdir/notCovSummary.txt"); 
		print OUT "depth threshold: $pThreshold\n";
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my$gene (sort(keys%Genes)) {
			print OUT "\n$gene\n"; 
			foreach my$NM (@{ $geneNM{$gene} }) {
				my$txt="";
				foreach my$file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}
	}

##re-analyse for $printReports || $printSummary, if $wUTR != $UTRinTxt, or if $lenForTxt != $len
if ( ($printReports || $printSummary) && (($UTRinTxt != $wUTR) || ($lenTxt5 != $len5) || ($lenTxt3 != $len3) || ($UpInTxt != $upstream) || ($DownInTxt != $downstream)) ) {

	my%NMnotCov;	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	my%NM_UC;	## NM_UC{$NM}{$threshold} = 1 if 1 region not cov

	foreach my$gene (sort(keys%Genes)) {
		print "analysing cov in $gene\n";
		my@NMs =  @{ $geneNM{$gene} };
		my$chr = $NMchr{$NMs[0]};
		my$sens = $NMsens{$NMs[0]};
		unless ($All) {
			my%NMinterval;
			foreach my$NM (@NMs)
				{ %{ $NMinterval{$chr}{$NM} } = %{ $txtRegions{$chr}{$NM} }; }
			my%tmp = mergeIntervals(%NMinterval);
			%{ $txtRegions{$chr}{$gene} } = %{ $tmp{$chr} };
			}

		foreach my$file (@Files) {
			print "\tfor bam $fName{$file}\n";
			## %notCov: start and end of each not covered domain within %allInterval : $notCov{$start} = $end
			if ($gatk)
				{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxGr,$chr,\@Thresholds,\%{ $txtRegions{$chr}{$gene} },$gatk,1); }
			else 
				{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.cov",$maxGr,$chr,\@Thresholds,\%{ $txtRegions{$chr}{$gene} },$gatk,1); }
			my%notCov = %{ $hashSub[1] };
			my%notCovStarts = %{ $hashSub[2] };

			if ($printSummary || $printReports) {
				if ($All) {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($All,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $txtRegions{$chr}{$gene} },\%{ $txt_NM_Ex{$NM} },$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%notCov,\%notCovStarts,\%NMnotCov,$printReports);
						%NMnotCov = %{ $hashSub[0] } ;
						%{ $NM_UC{$NM}{$fName{$file}} } = %{ $hashSub[3] } ;
						}
					}
				else {
					foreach my$NM (@NMs) {
						@hashSub = notCovDomains1($All,$fName{$file},$sName2{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $txtRegions{$chr}{$NM} },\%{ $txt_NM_Ex{$NM} },$NMstartCod{"raw"}{$NM},$NMendCod{"raw"}{$NM},\%notCov,\%notCovStarts,\%NMnotCov,$printReports);
						%NMnotCov = %{ $hashSub[0] } ;
						%{ $NM_UC{$NM}{$fName{$file}} } = %{ $hashSub[3] } ;
						}
					}
				}
			}
		}
	##summary
	## $NMnotCov{$NM}{$file}{$threshold} = 1 if 1 region not cov
	if ($printSummary) {
		open (OUT, ">$outdir/notCovSummary.txt");
		print OUT "coverage analysis
\ndepth threshold: $pThreshold
target regions: exons\n";
		if ($UTRinTxt) { print OUT "\twith UTR\n"; }
		else { print OUT "\twithout UTR\n"; }
		if ($lenTxt5 && $lenTxt3) { print OUT "\tpadding out of exons ends: 5': $lenTxt5 bp ; 3':$lenTxt3 bp\n"; }
		foreach my$gene (sort(keys%Genes)) {
			print OUT "\n$gene\n"; 
			foreach my$NM (@{ $geneNM{$gene} }) {
				my$txt="";
				foreach my$file (@Files) { 
					if (exists $NMnotCov{$NM}{$fName{$file}}{$pThreshold}) 
						{ $txt .= "\t$fName{$file} (".sprintf("%.1f",(100-$NM_UC{$NM}{$fName{$file}}{$pThreshold}))."\%)"; }
					}
				if ($txt)
					{ print OUT "\t$NM : not covered in bam files :$txt\n"; }
				else
					{ print OUT "\t$NM : OK\n"; }
				}
			}
		close OUT;
		}							
	}


###################
#Job 4: Plots:

#classiq
if ($covPlot) { 
	mkdir ("$outdir/covPlot");
	if (!$bedFile || $coordPlot) 
		{ %withChr = covPlot($bin,$maxPl,"all_Genes_Regions",\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,\%coordBed); }
	if ($bedFile) 
		{ %withChr = covPlot($bin,$maxPl,$bedName,\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,\%Bed); }
	}

#plots for samples intersection
if ($interS) {
	unless (-e "$outdir/covPlot")
		{ mkdir ("$outdir/covPlot"); }
	if (!$bedFile || $coordPlot) { 
		InterS($bin,$maxPl,$maxGr,\%coordBed,"all_Genes_Regions",\@Files,\%fName,$outdir,$gatk,\%gatkIdx); 
		}
	if ($bedFile) {		
		InterS($bin,$maxPl,$maxGr,\%Bed,$bedName,\@Files,\%fName,$outdir,$gatk,\%gatkIdx);
		}
	}

###################
#Job 5: cov of each bed interval

my($refBedLines);
if ($cov_Bed) {
	if ($bedFile) {
		$refBedLines = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$bedFile,$bedName,\%Bed,$pThreshold,$toReseq,$bedReport,\@covFields,$gatk,\%gatkIdx);
		#%bedLines = %{$hashSub[0]};		
		}
	else {
		$refBedLines = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$id2Bed,$bedName,\%coordBed,$pThreshold,$toReseq,$bedReport,\@covFields,$gatk,\%gatkIdx);
		#%bedLines = %{$hashSub[0]};		

		}
	}

my(%cnv_Patients,%cnv_Results);
if ($CNV_tool) {


	if ($bed_cov_file) {
		Bio::NGS::HCL::DeCovA::CNV_tool::CNV_reAnalyse($bed_cov_file,$outdir,$nGraf,$fichier_sexe,\%CNV_opt);
		}
	
	else {
	
		mkdir "$outdir/CNV_analysis";

		@hashSub = Bio::NGS::HCL::DeCovA::CNV_tool::CNV_detect(\@Files,\%sName2,"$outdir/CNV_analysis",$nGraf,$fichier_sexe,\%CNV_opt,$mbq,$mmq,$refBedLines,\@ChromOrder,\%faIdx);
		%cnv_Patients = %{$hashSub[0]};
		%cnv_Results = %{$hashSub[1]};

		if ($CNV_opt{"geneGraph"} && keys%cnv_Results) {
			print "cnv geneGraph \n";
			#get transcripts and genes overlapping bed CNV results
			my(%IDs,%CNVbed,%CNV_Genes);
			open (MERGE, ">$outdir/allCNVs.bed") || die "can't create file $outdir/allCNVs.bed\n";
			##cnv_Results{$Chrom}{Start}{End} = "DEL/DUP	foldRatio"
			foreach my$file (keys%cnv_Results) {
				#open (BED, "$outdir/CNV_analysis/$sName2{$file}/CNV_$sName2{$file}.txt") || die "can't open $outdir/CNV_analysis/CNV_$sName2{$file}.txt\n";
				#while (my$line=<BED>) { print MERGE $line; }
				#close BED;
				#%{ $CNVbed{$file} } = readBed("$outdir/CNV_analysis/$sName2{$file}/CNV_$sName2{$file}.txt");
				foreach my$chr (keys%{ $cnv_Results{$file} }) {
					foreach my$start (keys%{ $cnv_Results{$file}{$chr} }) {
						foreach my$end (keys%{ $cnv_Results{$file}{$chr}{$start} }) {
							print MERGE "$chr\t$start\t$end\n";
							if (exists $CNVbed{$file}{$chr}{($start+1)}) {
								if ($end > $CNVbed{$file}{$chr}{($start+1)}) 
									{ $CNVbed{$file}{$chr}{($start+1)} = $end; }	
								}
							else
								{ $CNVbed{$file}{$chr}{($start+1)} = $end; }
							}
						}
					}
				foreach my$chr (keys%{ $CNVbed{$file} }) {
					%{ $CNVbed{$file}{$chr} } = merge(\%{ $CNVbed{$file}{$chr} });	
					}
				@{ $IDs{$file} } = geneFromBed2("$outdir/id.tmp",$ref,\%{ $CNVbed{$file} });
				unlink "$outdir/id.tmp";
				foreach (@{ $IDs{$file} }) {
					if (exists $NMgene{$_} && exists $Genes{$NMgene{$_}})
						{ $CNV_Genes{$file}{$NMgene{$_}} = 1; }
					}
				}
			close MERGE;
			%{ $CNVbed{"allFiles"} } = readBed("$outdir/allCNVs.bed");
			foreach my$chr (keys%{ $CNVbed{"allFiles"} }) {
				%{ $CNVbed{"allFiles"}{$chr} } = merge(\%{ $CNVbed{"allFiles"}{$chr} }); 
				}
			@{ $IDs{"allFiles"} } = geneFromBed2("$outdir/id.tmp",$ref,\%{ $CNVbed{"allFiles"} });
			unlink "$outdir/id.tmp";
			unlink "$outdir/allCNVs.bed";
			foreach (@{ $IDs{"allFiles"} }) {
				if (exists $NMgene{$_} && exists $Genes{$NMgene{$_}})
					{ $CNV_Genes{"allFiles"}{$NMgene{$_}} = 1; }
				}
			#change cov file with $Patients{$file}{"Ref_Profondeur_Patient"}
			if ($gatk) {
				my%gatkIdx2File;	#$gatkIdx{$file} = $i;
				foreach (keys%gatkIdx) { $gatkIdx2File{$gatkIdx{$_}} = $_; }	#$gatkIdx2File{$i} = $file;
				open(COV, "$outdir/all.cov") || die "can't open file $outdir/all.cov\n";
				open(NORM, ">$outdir/all.norm.cov") || die "can't create file $outdir/all.norm.cov\n";
				my$l=0; #line iteration
				while (my$line=<COV>) {
					chomp $line;
					my@tab = split(/\t/,$line);
					my$line2="";
					for my$i (0..2) { $line2 .= $tab[$i]."\t"; }
					for my$i (3..$#tab) { $line2 .= ($tab[$i] / $cnv_Patients{$gatkIdx2File{$i}}{"Ref_depth"})."\t"; }
					chop $line2;
					print NORM $line2."\n";
					$l++;
					}
				close COV; close NORM;
				}
			else {
				foreach my$file (@Files) {
					open(COV, "$outdir/$fName{$file}.cov") || die "can't open file $outdir/$fName{$file}.cov\n";
					open(NORM, ">$outdir/$fName{$file}.norm.cov") || die "can't create file $outdir/$fName{$file}.norm.cov\n";
					while (my$line=<COV>){
						chomp $line;
						my@tab = split(/\t/,$line);
						$tab[-1] /= $cnv_Patients{$file}{"Ref_depth"};
						my$line2="";
						foreach (@tab) { $line2 .= $_."\t"; }
						chop $line2;
						print NORM $line2."\n";
						}
					close COV; close NORM;
					}
				}
			#compute as in graphs by genes
			my(%CNV_NMdepth,%CNV_maxCov);
			foreach my$gene (keys%{ $CNV_Genes{"allFiles"} }) {

				print "analysing cov in $gene\n";
				my@NMs =  @{ $geneNM{$gene} };
				my$chr = $NMchr{$NMs[0]};
				my$sens = $NMsens{$NMs[0]};
				## %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = depth
	
				foreach my$file (@Files) {

					if ($gatk)
						{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.norm.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },$gatk,""); }
					else 
						{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.norm.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },$gatk,""); }
					my%allDepth = %{ $hashSub[0] };

					## %NMdepth: key = $file, value = %(key = $NM, value = %( key = $ex, value = @(cov foreach ordered bp of exon) ) )
					## @{ $NMdepth{$file}{$NM}{$startReg} } = [ cov foreach ordered bp of exon ]
					%{ $CNV_NMdepth{$gene}{$file} } = depthLine(\%{ $Regions{"raw"}{$chr}{$gene} },\%allDepth);
					}

				if ($maxGr) { $CNV_maxCov{$gene} = $maxGr; }
				else {
					@hashSub = maxCov(\@Files,\%{ $CNV_NMdepth{$gene} },\%{ $Regions{"rev"}{$gene} }); 
					$CNV_maxCov{$gene} = $hashSub[0];
					}

				##reverse depth coord if sens "-"
				if ($Rev && ($sens eq "-")) {
					foreach my$file (@Files) {
						my$nEx=scalar(keys%{ $CNV_NMdepth{$gene}{$file} })-1;
						my%tmp;
						foreach my$ex (sort{$a<=>$b}(keys%{ $CNV_NMdepth{$gene}{$file} }))
							{ @{ $tmp{($nEx-$ex)} } = reverse@{ $CNV_NMdepth{$gene}{$file}{$ex} }; }
						%{ $CNV_NMdepth{$gene}{$file} } = %tmp;
						}
					}

				}
			#print graphs
			foreach my$file (@Files) {
				foreach my$gene (sort(keys%{ $CNV_Genes{$file} })) {
					print "printing CNV graph for $sName2{$file}, in $gene\n";
					my@NMs =  @{ $geneNM{$gene} };
					my$chr = $NMchr{$NMs[0]};
					my$sens = $NMsens{$NMs[0]};
					CNVgraphByGene($file,$suff,"$outdir/CNV_analysis/$sName2{$file}",$gene,$sens,$maxGr,$Rev,$chr,$CNV_maxCov{$gene},$pThreshold,$NMlength{$gene},\@Files,\%sName2,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"rev"}{$gene} },\@NMs,\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $CNV_NMdepth{$gene} });
					}
				}
			}

		}
	
	}


###################
#rm tmp files
foreach my$f ("regions","original","merge")
	{ unlink "$outdir/$f\_0Chr.bed","$outdir/$f\_wChr.bed"; }
if (($UTRinTxt > $wUTR) || ($lenTxt5 > $len5) || ($lenTxt3 > $len3) || ($UpInTxt > $upstream) || ($DownInTxt > $downstream))
	{ unlink "$outdir/txtRegions_0Chr.bed","$outdir/txtRegions_wChr.bed"; }

if ($cov_Bed && !$bedFile && !$keepBed)
	{ unlink "$outdir/$bedName.bed"; }
if ($splitBed && !$keepBed)
	{ unlink "$splitBed"; }
if ($cutBed && !$keepBed)
	{ unlink "$cutBed"; }

if ($keepCov) {
	if ($gatk) {
		open(my$fhOut, ">", "$outdir/gatk.all.cov.txt") or die "cannot create $outdir/gatk.all.cov.txt file\n";
		foreach (@{ $headers{"$outdir/all.cov"} }) { print $fhOut "$_"; }
		open(my$fhIn, "<", "$outdir/all.cov") or die "cannot read $outdir/all.cov\n";
		while (<$fhIn>) { print $fhOut "$_"; }
		close $fhIn; close $fhOut;
		}	
	}

if (-e "$outdir/chromLength.txt") { unlink "$outdir/chromLength.txt"; }

if ($gatk) {
	unlink glob "$outdir/all.cov*"; 
	if ($CNV_tool) { unlink glob "$outdir/all.norm.cov*"; }
	}
else {
	foreach (@Files) {
		unlink glob "$outdir/$fName{$_}.cov*";
		if ($CNV_tool) { unlink glob "$outdir/$fName{$_}.norm.cov*"; }
		}
	}

if ($dedup eq "do") {
	foreach (@Files) 
		{ unlink "$outdir/$fName{$_}-dedup.bam","$outdir/$fName{$_}-dedup.bam.bai","$outdir/$fName{$_}.dedup-metrics"; }
	}
foreach (@Files) {
	if (-e $tmpFile{$_}) 
		{ unlink "$tmpFile{$_}"; }
	}

if ($gz) {
	system "tar -zcvf $outdir.tar.gz $outdir";
	system "rm -rf $outdir";
	}

exit;


######################
sub readBed
{
my($bed) = @_;
my%covBed;			#$covbed{$chr}{$start} = $end;	transform in 1-based coord
open(BED, $bed) || die "can't open file $bed\n";
print "open $bed\n";
my$ok=0;
while (my$line=<BED>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//i;
		#keep longest interval
		if ( exists $covBed{$tab[0]}{($tab[1]+1)} ) {
			if ( $tab[2] > $covBed{$tab[0]}{($tab[1]+1)}) 
				{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }	
			else { next; }
			}
		else
			{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }
		}
	}
unless ($ok) { die "no bed formatted line in $bed file";}
close BED;
return(%covBed);
}


######################
sub addLength2Bed
{
my($bedFile,$newBed,$len) = @_;
open(BED, $bedFile) || die "can't open file $bedFile\n";
open(OUT, ">$newBed") || die "can't create file $newBed\n";
while (my$line=<BED>) {
	if ( ($line !~ /^\w+\t\d+\t\d+/) || ($line =~ /^#/) )
		{ print OUT "$line"; }
	else {
		chomp $line;
		my@tab = split(/\t/,$line);
		print OUT $tab[0]."\t".($tab[1]-$len)."\t".($tab[2]+$len);
		for my$i (3..$#tab) { print OUT "\t".$tab[$i]; }
		print OUT "\n";
		}
	}
close BED; close OUT;
}


######################
sub split_Bed
{
my($bedFile,$newBed,$h1) = @_;
my@chromOrder = @$h1;

# $intervals{$chr}{$start}{$end} = $line;
my(%intervals,@tmpOrder,%allChrom);		
open(BED, $bedFile) || die "can't open file $bedFile\n";
print "spliting $bedFile\n";
my$ok=0;
while (my$line=<BED>) {
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		$ok++;
		chomp $line;
		my@tab = split(/\t/,$line);
		unless (@chromOrder) {
			unless (exists $allChrom{$tab[0]}) 
				{ push(@tmpOrder,$tab[0]); $allChrom{$tab[0]} = 1; }
			}
		$intervals{$tab[0]}{$tab[1]}{$tab[2]} = $tab[3];
		}
	}
unless ($ok) { die "no bed formatted line in $bedFile file"; }
close BED;
unless (@chromOrder) { @chromOrder = @tmpOrder; }

#split intervals with same start
my%interval2;
foreach my$chr (keys%intervals) {
	my$i=0;
	foreach my$start ( sort{$a<=>$b}(keys%{ $intervals{$chr} }) ) {
		my$currentStart=$start;
		foreach my$end ( sort{$a<=>$b}(keys%{ $intervals{$chr}{$start} }) ) {
			$interval2{$chr}[$i]{"start"} = $currentStart;
			$interval2{$chr}[$i]{"end"} = $end;
			$interval2{$chr}[$i]{"info"} = $intervals{$chr}{$start}{$end};
			$currentStart=$end;
			$i++;
			}
		}
	}

#split overlapping intervals
my%interval3;
foreach my$chr (keys%interval2) { 
	my$i=0;
	while (($i+1) < scalar@{ $interval2{$chr} } ) {
		if ($interval2{$chr}[$i+1]{"start"} < $interval2{$chr}[$i]{"end"}) {
			my$End = $interval2{$chr}[$i]{"end"};
			my$Info = $interval2{$chr}[$i]{"info"};
			my%tmp1;
			$tmp1{$interval2{$chr}[$i]{"start"}} = $End; 
			my$j=$i;
			while (($j+1) < scalar@{ $interval2{$chr} } && $interval2{$chr}[$j+1]{"start"} < $End) {
				my%tmp2;
				my@tmpStarts = sort{$a<=>$b}(keys%tmp1);
				for (my$k=0;$k<scalar@tmpStarts;$k++) {
					if ($interval2{$chr}[$j+1]{"start"} < $tmp1{$tmpStarts[$k]}) {
						if ($interval2{$chr}[$j+1]{"start"} > $tmpStarts[$k]) {
							$interval3{$chr}{$tmpStarts[$k]}{"end"} = $interval2{$chr}[$j+1]{"start"};
							$interval3{$chr}{$tmpStarts[$k]}{"info"} = $Info;
							}
						if ($interval2{$chr}[$j+1]{"end"} < $tmp1{$tmpStarts[$k]}) {
							$tmp2{$interval2{$chr}[$j+1]{"start"}} = $interval2{$chr}[$j+1]{"end"};
							$tmp2{$interval2{$chr}[$j+1]{"end"}} = $tmp1{$tmpStarts[$k]};
							for (my$l=($k+1);$l<scalar@tmpStarts;$l++)
								{ $tmp2{$tmpStarts[$l]} = $tmp1{$tmpStarts[$l]}; }
							last;
							}
						else {
							$tmp2{$interval2{$chr}[$j+1]{"start"}} = $tmp1{$tmpStarts[$k]};
							if ($interval2{$chr}[$j+1]{"end"} > $tmp1{$tmpStarts[$k]})
								{ $interval2{$chr}[$j+1]{"start"} = $tmp1{$tmpStarts[$k]}; }
							}
						}
					else {
						if ($interval2{$chr}[$j+1]{"start"} > $tmpStarts[$k]) {				
							$interval3{$chr}{$tmpStarts[$k]}{"end"} = $tmp1{$tmpStarts[$k]};
							$interval3{$chr}{$tmpStarts[$k]}{"info"} = $Info;
							}
						}
					}
				%tmp1 = %tmp2;
				$j++;
				}
			foreach (sort{$a<=>$b}(keys%tmp1)) {
				$interval3{$chr}{$_}{"end"} = $tmp1{$_};
				$interval3{$chr}{$_}{"info"} = $Info;
				}
			}
		else {
			unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
				$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
				}
			}
		$i++;
		}
	unless (exists $interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"}) {
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"end"} = $interval2{$chr}[$i]{"end"};
		$interval3{$chr}{$interval2{$chr}[$i]{"start"}}{"info"} = $interval2{$chr}[$i]{"info"};
		}
	}

#print splitted bed
open(BED, ">$newBed") || die "can't create file $newBed\n";
foreach my$chr (@chromOrder) {
	if (exists $interval3{$chr}) {
		foreach my$start ( sort{$a<=>$b}(keys%{ $interval3{$chr} }) ) { 
			print BED $chr."\t".$start."\t".$interval3{$chr}{$start}{"end"};
			if (defined $interval3{$chr}{$start}{"info"}) { print BED "\t".$interval3{$chr}{$start}{"info"}."\n"; }
			else { print BED "\t.\n"; }
			}
		}
	}
close BED;

}



######################
sub cut_Bed
{
my($bedFile,$newBed,$h1,$h2) = @_;
my@chromOrder = @$h1;
my%c_opt = %$h2;
my$cutL = $c_opt{"cutL"};

open(OUT, ">", "$newBed") || die "can't create file $newBed\n";
open(BED, "<", "$bedFile") || die "can't open file $bedFile\n";
while (my$line=<BED>) {
	chomp $line;
	my@tab = split(/\t/,$line);
	my$line2;
	if ( ($tab[2]-$tab[1]) >= $c_opt{"maxL"} ) {
		my$start = $tab[1];
		my$end = $tab[2];
		my$div=int(($end-$start) / $cutL);
		my$mod=($end-$start) % $cutL;
		my$info="";
		for (my$i=3;$i<scalar@tab;$i++)
			{ $info.=$tab[$i]."\t"; }
		chop $info;
		my$i=0;
		if ($c_opt{"keepLast"} && ($mod<$c_opt{"minL"})) {
			while ($i<($div-1)) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+(($i+1)*$cutL))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print OUT $line2."\n";
				$i++;
				}
			if ($c_opt{"keepLast"} eq "merge") {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				}
			else {
				my$lastI = $end-($start+($i*$cutL));
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+($i*$cutL)+int($lastI/2))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print OUT $line2."\n";
				$line2 = $tab[0]."\t".($start+($i*$cutL)+int($lastI/2))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				}
			print OUT $line2."\n";
			}
		else {
			while ($i<$div) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".($start+(($i+1)*$cutL))."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print OUT $line2."\n";
				$i++;
				}
			if ($mod>=$c_opt{"minL"}) {
				$line2 = $tab[0]."\t".($start+($i*$cutL))."\t".$end."\t";
				if ($info) { $line2 .= $info; }
				else { chop $line2; }
				print OUT $line2."\n";
				}
			}
		}
	else {
		foreach my$i (@tab)
			{ $line2 .= $i."\t"; }
		chop $line2;
		print OUT $line2."\n";
		}
	}
close(BED);
close(OUT);

}


#################### 
#extractBed from bedtools output
#not used anymore
sub extractBed
{
my($dir,$file) = @_;
my%covBed;		#$covbed{$chr}{$start} = $end;

if ($dir) { 
	$dir =~ s/\/$//;
	open(COV, $dir."/".$file) || die "can't open file $file\n"; 
	}
else
	{ open(COV, $file) || die "can't open file $file\n"; }
while (my$line=<COV>) {
	chomp $line;
	my@tab = split(/\t/,$line);
	$tab[0] =~ s/chr//;
	if ( exists $covBed{$tab[0]}{($tab[1]+1)} ) {
		if ( $tab[2] > $covBed{$tab[0]}{($tab[1]+1)}) 
			{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }	
		else { next; }
		}
	else
		{ $covBed{$tab[0]}{($tab[1]+1)} = $tab[2]; }
	}
close COV;
return(%covBed);
}


##############################
#print lines of RefSeq matching each $id of @IDs
sub gene2Ref
{
my($idFile,$ref,$h1)=@_;
my@IDs=@$h1;
my@Ref;
if ($ref) {
	open(REF, $ref) || die "can't open file $ref\n";
	while (my$line=<REF>) {
		unless($line =~ /^#/) {
			chomp $line;
			push(@Ref, $line);
			}
		}
	close(REF);
	}
else { die "RefSeq file required\n"; }
my@Ref2;
foreach my$id (@IDs) { 
	my@tmp = grep(/\t$id\t/i, @Ref); 
	if (@tmp) { push(@Ref2, @tmp); }
	else { die "can't find $id in $ref file\n"; }
	}
open(IDS, ">$idFile") || die "can't create file $idFile\n";
foreach(@Ref2) { print IDS "$_\n"; }
close(IDS);
}


##############################
#old one
sub geneFromBed
{
print"look for transcripts overlapping bed file\n";
my($ref,$h1) = @_;	#refseq in 0-based
my%interval = %$h1;	#$Bed{$chr}{$start} = $end , in 1-based
my@Chrom=(0);
my$ok1=0;		#next line if no NM in this chromosome
my$chr;
my@bedStarts=();
my(%allNM);
open(REF, $ref) || die "can't open file $ref\n";
while (my$line=<REF>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;
		unless ($tab[2] eq $Chrom[-1]) { 
			push (@Chrom, $tab[2]); print $tab[2]."\n";
			$ok1=0;
			foreach my$i (sort(keys%interval)) {
				if ($i eq $tab[2]) {
					$chr = $tab[2]; 
					@bedStarts = sort{$a<=>$b}keys%{ $interval{$chr} };
					$ok1=1;
					last; 
					}
				}
			}
		if ($ok1) {
			for (my$c=0;$c<scalar(@bedStarts);$c++) {
				if ( (($tab[4]+1) <= $interval{$chr}{$bedStarts[$c]}) && ($tab[5] >= $bedStarts[$c]) )
					{ $allNM{$tab[1]} = $tab[12]; }
				}
			}

		}
	}
close(REF);
my@Transcripts = sort{ $allNM{$a} cmp $allNM{$b} }keys%allNM ;
return(sort@Transcripts);
}


######################
#new one, refseq in ram
sub geneFromBed2
{
print"look for transcripts overlapping bed file\n";
my($idFile,$ref,$h1) = @_;	#refseq in 0-based
my%interval = %$h1;	#$Bed{$chr}{$start} = $end , in 1-based

my(%NM,@Transcripts,%RefNames,%RefLines,%newLines);
#$RefCoord{$chr}{$start} = $end, in 1-based
#@{ $RefCoord{$chr}{$start}{$end} } = [$NM1,$NM2,...]		
open(REF, $ref) || die "can't open file $ref\n";
while (my$line=<REF>) {
	unless($line =~ /^#/) {
		chomp $line;
		my@tab=split(/\t/,$line);
		$tab[2] =~ s/chr//i;			
		push(@{ $RefNames{$tab[2]}{($tab[4]+1)}{$tab[5]} }, $tab[1]);
		push(@{ $RefLines{$tab[2]}{($tab[4]+1)}{$tab[5]} }, $line);
		}
	}
close(REF);

foreach my$chr (sort(keys%interval)) {
	my@bedStarts = sort{$a<=>$b}keys%{ $interval{$chr} };
	my@refStarts = sort{$a<=>$b}keys%{ $RefNames{$chr} };
	my$c=0;	#idx of @refStarts
	my@RefEnds = sort{$b<=>$a}keys%{ $RefNames{$chr}{$refStarts[$c]} };
	foreach my$bedstart(@bedStarts) {
		while ( ($c<(scalar@refStarts-1)) && ($bedstart > $RefEnds[0]) ) { 
			$c++; 
			@RefEnds = sort{$b<=>$a}keys%{ $RefNames{$chr}{$refStarts[$c]} };
			}
		my$c2=$c;
		while (($c2<(scalar@refStarts-1)) && ($interval{$chr}{$bedstart}>=$refStarts[$c2])) {
			foreach my$end (@RefEnds) {
				if ($bedstart<=$end) { 
					foreach(@{ $RefNames{$chr}{$refStarts[$c2]}{$end} }) 
						{ $NM{$_}=1; }
					foreach(@{ $RefLines{$chr}{$refStarts[$c2]}{$end} }) 
						{ $newLines{$_}=1;}
					}
				else { last; }
				}
			$c2++;
			@RefEnds = sort{$b<=>$a}keys%{ $RefNames{$chr}{$refStarts[$c2]} };
			}
		if ($interval{$chr}{$bedstart}>=$refStarts[$c2]) {
			foreach my$end (@RefEnds) {
				if ($bedstart<=$end) { 
					foreach(@{ $RefNames{$chr}{$refStarts[$c2]}{$end} }) 
						{ $NM{$_}=1; }
					foreach(@{ $RefLines{$chr}{$refStarts[$c2]}{$end} }) 
						{ $newLines{$_}=1;}
					}
				else { last; }
				}
			}
		}
	}
open(IDS, ">$idFile") || die "can't create file $idFile\n";
foreach(keys%newLines)
	{ print IDS "$_\n";}
close(IDS);
@Transcripts = sort(keys(%NM));
return(@Transcripts);
}


##########################
#RefSeq:
##bin	name	chrom	strand	txStart	txEnd	cdsStart	cdsEnd	exonCount	exonStarts	exonEnds	score	name2	cdsStartStat	cdsEndStat	exonFrames
#0	NM_032291	chr1	+	66999824	67210768	67000041	67208778	25	66999824,67091529,67098752,67101626,67105459,67108492,67109226,67126195,67133212,67136677,67137626,67138963,67142686,67145360,67147551,67154830,67155872,67161116,67184976,67194946,67199430,67205017,67206340,67206954,67208755,	67000051,67091593,67098777,67101698,67105516,67108547,67109402,67126207,67133224,67136702,67137678,67139049,67142779,67145435,67148052,67154958,67155999,67161176,67185088,67195102,67199563,67205220,67206405,67207119,67210768,	0	SGIP1	cmpl	cmpl	0,1,2,0,0,0,1,0,0,0,1,2,1,1,1,1,0,1,1,2,2,0,2,1,1,
##@hashSub = Id2Coord($idFile,$len5,$len3,$upstream,$downstream,$noOverlap,$nonCod,$wUTR,$id2Bed);
##Id2Coord($idFile,$lenForTxt,$nonCod,$UTRinTxt)
sub Id2Coord
{
my($idFile,$len5,$len3,$upstream,$downstream,$noOverlap,$nonCod,$wUTR,$id2Bed) = @_;
my(%NMgene,%geneNM,%NMchr,%NMsens,%NMstartCod,%NMendCod,%NM_Ex,%Regions,%gOK,%Bed);

if ($id2Bed) { open(BED, ">$id2Bed") || die "can't create $id2Bed\n"; }
open(IDS, "$idFile") || die "can't open file $idFile\n";
while (my$line=<IDS>) {
	chomp $line;
	my@tab=split(/\t/,$line);
	$tab[2] =~ s/^chr//i;
	if ( (exists $geneNM{$tab[12]}) && ($tab[2] ne $NMchr{$geneNM{$tab[12]}[0]}) )
		{ $tab[12] .= "-$tab[2]"; }
	my$ok=1;
	if (exists $NMchr{$tab[1]}) {
		if ($tab[2] =~ /^$NMchr{$tab[1]}.+/)
			{ $ok=0; }
		unless ($NMchr{$tab[1]} =~ /$tab[2].+/)
			{ $ok=0; }
			#{ $tab[1].= "-$tab[2]"; }
		}
	unless ($nonCod) {
		#only coding transcipt: cdsStar != cdsEnd
		if ($tab[6] == $tab[7]) 
			{ $ok=0; }
		}
	if ($ok) {
		my$NM = $tab[1];
		my$gene = $tab[12];
		$NMgene{$NM} = $gene;
		push(@{ $geneNM{$gene} }, $NM);
		my$chr = $tab[2];
		$NMchr{$NM} = $chr;	
		$NMsens{$NM} = $tab[3];
		print $gene."\tchr: ".$NMchr{$NM}."\t".$NM."\tsens:".$NMsens{$NM}."\n";
		$NMstartCod{$NM} = ($tab[6]+1);	#for 1-based coord
		$NMendCod{$NM} = $tab[7];
		my@Starts = split(/,/,$tab[9]);
		my@Ends = split(/,/,$tab[10]);
		my(%interval,$firstCodingEx,$lastCodingEx,$minLen,$plusLen); # %intervalin 1-based coord
		if ($tab[3] eq "+") { $minLen = $len5; $plusLen = $len3; }
		else { $minLen = $len3; $plusLen = $len5; }
		#expand exons +/-length:	
		if ($wUTR) {
			if ($tab[3] eq "+" && $upstream) {
				if ($id2Bed)
					{ print BED "$chr\t".($Starts[0]-$upstream)."\t".($Starts[0]-$minLen)."\t$gene".":$NM\_upstream\n"; }
				$interval{($Starts[0]+1-$upstream)} = $Starts[0]-$minLen;
				}
			elsif ($tab[3] eq "-" && $downstream) {
				if ($id2Bed)
					{ print BED "$chr\t".($Starts[0]-$downstream)."\t".($Starts[0]-$minLen)."\t$gene".":$NM\_downstream\n"; }
				$interval{($Starts[0]+1-$downstream)} = $Starts[0]-$minLen;
				}
			for (my$i=0;$i<scalar(@Starts);$i++) {
				if ($noOverlap && $Starts[$i+1] && ($Ends[$i]+$plusLen) > ($Starts[$i+1]-$minLen)) {
					my$ecart  = ($Starts[$i+1]-$Ends[$i]) / 2;
					$Ends[$i] = int($Ends[$i]+$ecart-$plusLen);
					$Starts[$i+1] = int($Starts[$i+1]-$ecart+$minLen);
					}
				if ($id2Bed) {
					print BED "$chr\t".($Starts[$i]-$minLen)."\t".($Ends[$i]+$plusLen)."\t$gene".":$NM";
					if ($tab[3] eq "+") { print BED ":exon".($i+1)."\n"; }
					else { print BED ":exon".(scalar(@Starts)-$i)."\n"; }
					}
				$interval{($Starts[$i]+1-$minLen)} = $Ends[$i]+$plusLen;	
				}
			if ($tab[3] eq "+" && $downstream) {
				if ($id2Bed)
					{ print BED "$chr\t".($Ends[-1]+$plusLen)."\t".($Ends[-1]+$downstream)."\t$gene".":$NM\_downstream\n"; }
				$interval{($Ends[-1]+1+$plusLen)} = $Ends[-1]+$downstream;
				}
			elsif ($tab[3] eq "-" && $upstream) {
				if ($id2Bed)
					{ print BED "$chr\t".($Ends[-1]+$plusLen)."\t".($Ends[-1]+$upstream)."\t$gene".":$NM\_upstream\n"; }
				$interval{($Ends[-1]+1+$plusLen)} = $Ends[-1]+$downstream;
				}
			}
		else {
			for (my$i=0;$i<scalar(@Starts);$i++) {
				if ($noOverlap && $Starts[$i+1] && ($Ends[$i]+$plusLen) > ($Starts[$i+1]-$minLen)) {
					my$ecart  = ($Starts[$i+1]-$Ends[$i]) / 2;
					$Ends[$i] = int($Ends[$i]+$ecart-$plusLen);
					$Starts[$i+1] = int($Starts[$i+1]-$ecart+$minLen);
					}
				if ($Ends[$i] < $NMstartCod{$NM}) { next; }
				elsif ( ($Ends[$i] >= $NMstartCod{$NM}) && ($Starts[$i] <= $NMstartCod{$NM}) ) {
					$firstCodingEx = $i;
					if ($Ends[$i] > $NMendCod{$NM}) { 
						$interval{($NMstartCod{$NM}-$minLen)} = $NMendCod{$NM}+$plusLen;
						if ($id2Bed) {
							print BED "$chr\t".($tab[6]-$minLen)."\t".($tab[7]+$plusLen)."\t$gene".":$NM";
							if ($tab[3] eq "+") { print BED ":exon".($i+1)."\n"; }
							else { print BED  ":exon".(scalar(@Starts)-$i)."\n"; }
							}
						}
					else { 
						$interval{($NMstartCod{$NM}-$minLen)} = $Ends[$i]+$plusLen;
						if ($id2Bed) {
							print BED "$chr\t".($tab[6]-$minLen)."\t".($Ends[$i]+$plusLen)."\t$gene".":$NM";
							if ($tab[3] eq "+") { print BED ":exon".($i+1)."\n"; }
							else { print BED  ":exon".(scalar(@Starts)-$i)."\n"; }
							}
						}
					}
				elsif ( ($Starts[$i] > $NMstartCod{$NM}) && ($Starts[$i] <= $NMendCod{$NM}) ) {
					if ($Ends[$i] < $NMendCod{$NM}) { 
						$interval{($Starts[$i]+1-$minLen)} = $Ends[$i]+$plusLen;
						if ($id2Bed) {
							print BED "$chr\t".($Starts[$i]-$minLen)."\t".($Ends[$i]+$plusLen)."\t$gene".":$NM";
							if ($tab[3] eq "+") { print BED ":exon".($i+1)."\n"; }
							else { print BED ":exon".(scalar(@Starts)-$i)."\n"; }
							}
						}
					else {
						$lastCodingEx = $i;
						$interval{($Starts[$i]+1-$minLen)} = $NMendCod{$NM}+$plusLen;
						if ($id2Bed) {
							print BED "$chr\t".($Starts[$i]-$minLen)."\t".($tab[7]+$plusLen)."\t$gene".":$NM";
							if ($tab[3] eq "+") { print BED ":exon".($i+1)."\n"; }
							else { print BED ":exon".(scalar(@Starts)-$i)."\n"; }
							}
						}
					}
				else { last; }
				}
			}
		#eventually merges overlapping intervals of regions
		#associates real exons to intervals
		my@Starts2 = sort{$a<=>$b}(keys%interval);
		my%interval2;
		my$start = $Starts2[0];
		my$end = $interval{$start};
		if ($wUTR) {
			$NM_Ex{$NM}{$start}{$Starts[0]+1} = $Ends[0];
			for (my$i=1;$i<scalar(@Starts2);$i++) {
				if ($Starts2[$i] <= $end) { 
					$end = $interval{$Starts2[$i]}; 
					$NM_Ex{$NM}{$start}{$Starts[$i]+1} = $Ends[$i];
					}
				else { 
					$interval2{$start} = $end;
					$start = $Starts2[$i];
					$end = $interval{$start};
					$NM_Ex{$NM}{$start}{$Starts[$i]+1} = $Ends[$i];
					}
				}
			$interval2{$start} = $end;
			$NM_Ex{$NM}{$start}{$Starts[-1]+1} = $Ends[-1];
			}
		else {
			$NM_Ex{$NM}{$start}{$NMstartCod{$NM}} = $Ends[$firstCodingEx];
			for (my$i=1;$i<scalar(@Starts2);$i++) {
				if ($Starts2[$i] <= $end) { 
					$end = $interval{$Starts2[$i]}; 
					$NM_Ex{$NM}{$start}{$Starts[$i+$firstCodingEx]+1} = $Ends[$i+$firstCodingEx];
					}
				else { 
					$interval2{$start} = $end;
					$start = $Starts2[$i];
					$end = $interval{$start};
					$NM_Ex{$NM}{$start}{$Starts[$i+$firstCodingEx]+1} = $Ends[$i+$firstCodingEx];
					}
				}
			$interval2{$start} = $end;
			$NM_Ex{$NM}{$start}{$Starts[$lastCodingEx]+1} = $NMendCod{$NM};
			}
		%{ $Regions{$chr}{$NM} } = %interval2;
		foreach (keys%interval2) {
			if ( exists $Bed{$chr}{$_} ) {
				if ( $interval2{$_} > $Bed{$chr}{$_}) 
					{ $Bed{$chr}{$_} = $interval2{$_}; }	
				}
			else
				{ $Bed{$chr}{$_} = $interval2{$_}; }
			}			
		}
	}
close(IDS);
if ($id2Bed) { close BED; }
my%Genes;
foreach (keys%geneNM) { 
	$Genes{$_} = 1;
	@{ $geneNM{$_} } = sort@{ $geneNM{$_} };
	}
return (\%geneNM,\%NMgene,\%NMchr,\%NMsens,\%NMstartCod,\%NMendCod,\%Regions,\%NM_Ex,\%Genes,\%Bed);
}


#########################
sub NM2GeneRegion {
my($h1,$h2,$h3,$h4,$h5)=@_;
my%Genes = %$h1;
my%geneNM = %$h2;
my%NMchr = %$h3;
my%Regions = %$h4;
my%NM_Ex = %$h5;
my%RegionG;
foreach my$gene (keys%Genes) {
	my@NMs =  @{ $geneNM{$gene} };
	my$chr = $NMchr{$NMs[0]};
	print "change intervals for ".$gene." according to:\n\t".$NMs[0];
	%{ $RegionG{$chr}{$gene} } = %{ $Regions{$chr}{$NMs[0]} };
	my%geneNM_Ex;
	%{ $geneNM_Ex{$NMs[0]} } = %{ $NM_Ex{$NMs[0]} };
	for(my$i=1;$i<scalar@NMs;$i++) {
		print "\t".$NMs[$i];
		@hashSub = changeRegion1($NMs[$i],\%{ $RegionG{$chr}{$gene} },\%geneNM_Ex,\%{ $Regions{$chr}{$NMs[$i]} },\%{ $NM_Ex{$NMs[$i]} });
		%{ $RegionG{$chr}{$gene} } = %{$hashSub[0]};
		%geneNM_Ex = %{$hashSub[1]};
		}
	print "\n";
	foreach (@NMs)
		{ %{ $NM_Ex{$_} } = %{ $geneNM_Ex{$_} }; }
	}
%Regions = %RegionG;
return(\%Regions,\%NM_Ex);
}


#########################
#make 1 common region from all transcripts of 1 gene
sub changeRegion1
{
#@hashSub = changeRegion1($NMs[$i],\%{ $RegionG{$chr}{$gene} },\%geneNM_Ex,\%{ $Regions{$chr}{$NMs[$i]} },\%{ $NM_Ex{$NMs[$i]} });
my($NM,$h1,$h2,$h3,$h4) = @_;
my%RegionG = %$h1;	#for gene: $Regions{start of region} = end of region
my%geneNM_Ex = %$h2;	#foreach $nm of gene already processed: $geneNM_Ex{$nm}{start of region}{start of exon} = end of exon
my%RegionN = %$h3;	#for current NM: $Regions{start of region} = end of region
my%NM_Ex = %$h4;	#for current NM: $NM_Ex{start of region}{start of exon} = end of exon

my@StartG = sort{$a<=>$b}(keys%RegionG);
my@StartN = sort{$a<=>$b}(keys%RegionN);
my(%RegionG2,%geneNM_Ex2);
my$c=0;	#$c: count of @StartG
my$i=0;	#$i: count of @StartN
my$endN = $RegionN{$StartN[$i]};

while ( ($i < scalar@StartN) && ($endN < $StartG[0]) ) {
	$RegionG2{$StartN[$i]} = $endN;
	foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
		{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
	$i++;
	$endN = $RegionN{$StartN[$i]};
	}
while ( $i < scalar@StartN ) {
	$endN = $RegionN{$StartN[$i]};				
	if ( $endN < $StartG[$c] ) {
		$RegionG2{$StartN[$i]} = $endN;
		foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
		}
	while ( ($c < (scalar@StartG -1)) && ($StartN[$i] > $RegionG{$StartG[$c]}) ) {
		$RegionG2{$StartG[$c]} = $RegionG{$StartG[$c]};
		foreach my$nm (keys%geneNM_Ex) {
			foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
				{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
			}
		$c++; 
		}
	while ( ($c < (scalar@StartG -1)) && ($StartN[$i] <= $RegionG{$StartG[$c]}) && ($endN >= $StartG[$c]) ) {
		if ($StartN[$i] < $StartG[$c]) {
			if ($endN > $RegionG{$StartG[$c]})
				{ $RegionG2{$StartN[$i]} = $endN; }
			else
				{ $RegionG2{$StartN[$i]} = $RegionG{$StartG[$c]}; }
			foreach my$nm (keys%geneNM_Ex) { 
				foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartN[$i]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
			}
		else	{
			if ($endN > $RegionG{$StartG[$c]})
				{ $RegionG2{$StartG[$c]} = $endN; }
			else
				{ $RegionG2{$StartG[$c]} = $RegionG{$StartG[$c]}; }
			foreach my$nm (keys%geneNM_Ex) { 
				foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartG[$c]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
			}
		$c++;
		}
	#current $c
	if ( ($endN < $StartG[$c]) && ($StartN[$i]>$RegionG{$StartG[$c-1]}) ) {
		$RegionG2{$StartN[$i]} = $endN;			
		foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
		}
	if ( $StartN[$i] > $RegionG{$StartG[$c]} ) {
		$RegionG2{$StartG[$c]} = $RegionG{$StartG[$c]};
		foreach my$nm (keys%geneNM_Ex)
			{
			foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
				{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
			} 
		}
	if ( ($StartN[$i] <= $RegionG{$StartG[$c]}) && ($endN >= $StartG[$c]) ) {
		if ($StartN[$i] < $StartG[$c])
			{
			if ($endN > $RegionG{$StartG[$c]})
				{ $RegionG2{$StartN[$i]} = $endN; }
			else
				{ $RegionG2{$StartN[$i]} = $RegionG{$StartG[$c]}; }
			foreach my$nm (keys%geneNM_Ex)
				{ 
				foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartN[$i]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
			}
		else {
			if ($endN > $RegionG{$StartG[$c]})
				{ $RegionG2{$StartG[$c]} = $endN; }
			else
				{ $RegionG2{$StartG[$c]} = $RegionG{$StartG[$c]}; }
			foreach my$nm (keys%geneNM_Ex)
				{ 
				foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
					{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
				}
			foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
				{ $geneNM_Ex2{$NM}{$StartG[$c]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
			}
		}
	if ( $StartN[$i] > $RegionG{$StartG[-1]} )	#if regionN keep going on after end of regionG
		{
		$RegionG2{$StartN[$i]} = $endN;		
		foreach my$startEx (keys%{ $NM_Ex{$StartN[$i]} })
			{ $geneNM_Ex2{$NM}{$StartN[$i]}{$startEx} = $NM_Ex{$StartN[$i]}{$startEx}; }
		}
	$i++;
	}
#if regionG keep going on after end of regionN
while ( ($c < scalar@StartG) && ($StartG[$c] > $endN) )
	{
	$RegionG2{$StartG[$c]} = $RegionG{$StartG[$c]};
	foreach my$nm (keys%geneNM_Ex) { 
		foreach my$startEx (keys%{ $geneNM_Ex{$nm}{$StartG[$c]} })
			{ $geneNM_Ex2{$nm}{$StartG[$c]}{$startEx} = $geneNM_Ex{$nm}{$StartG[$c]}{$startEx}; }
		}
	$c++; 
	}

#merge intervals
@StartG = sort{$a<=>$b}(keys%RegionG2);
my(%RegionG3,%geneNM_Ex3);
my$startReg = $StartG[0];
my$endReg = $RegionG2{$startReg};
foreach my$nm (keys%geneNM_Ex2) { 
	foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$startReg} })
		{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$startReg}{$startEx}; }
	}
for (my$i=1;$i<scalar(@StartG);$i++) {
	if ($StartG[$i] <= $endReg) { 
		if ($RegionG2{$StartG[$i]} > $endReg)
			{ $endReg = $RegionG2{$StartG[$i]}; }
		foreach my$nm (keys%geneNM_Ex2) {
			foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$StartG[$i]} })
				{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$StartG[$i]}{$startEx}; }
			}
		}
	else	{ 
		$RegionG3{$startReg} = $endReg;
		$startReg = $StartG[$i];
		$endReg = $RegionG2{$startReg};
		foreach my$nm (keys%geneNM_Ex2)
			{
			foreach my$startEx (keys%{ $geneNM_Ex2{$nm}{$startReg} })
				{ $geneNM_Ex3{$nm}{$startReg}{$startEx} = $geneNM_Ex2{$nm}{$startReg}{$startEx}; }
			}
		}
	}
$RegionG3{$startReg} = $endReg;

return(\%RegionG3,\%geneNM_Ex3);
}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#create 1 hash : 
sub changeRegion2G
{
	#@hashSub = changeRegion2G(\@NMs,\%{ $Regions{$chr}{$gene} },\%NM_Ex,\%{ $Bed{$chr} });
	#%{ $Regions{$chr}{$gene} } = %{$hashSub[0]};
	#%NM_Ex = %{$hashSub[1]};
	#%{ $RegBed{$gene} } = %{$hashSub[2]};	#$RegBed{$NM}{$startReg}{$startBed} = $endBed;
my($h1,$h2,$h3,$h4) = @_;
my@NMs = @$h1;		# @{ $geneNM{$gene} } = [$NM1,...]
my%interval = %$h2;		# $Regions{start of region} = end of region
my%NM_Ex = %$h3;		# %NM_Ex{NM}{start of region}{start of exon} = end of exon
my%Bed = %$h4;			#$Bed{$startBed} = $endBed;

my%RegBed;			#$RegBed{$NM}{$startReg}{$startBed} = $endBed;

my@Starts = sort{$a<=>$b}(keys%interval);
my(%interval2,%NM_Ex2,%RegBed1);
my$c=0;	#$c: count of @StartInterval			
my@startBed = sort{$a<=>$b}keys%Bed;
my$endBed = $Bed{$startBed[0]};
for (my$i=0;$i<scalar@startBed;$i++) {
	if ($startBed[$i] > $interval{$Starts[-1]})	#if bed keep going on after end of region
		{ last; }
	$endBed = $Bed{$startBed[$i]};	
	if ( $endBed < $Starts[0] )
		{ next; }
	if ( $endBed < $Starts[$c] ) {
		if ($startBed[$i] > $interval{$Starts[$c-1]})
			{ 
			$interval2{$startBed[$i]} = $endBed; 
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			next;
			}
		else { $c--; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] > $interval{$Starts[$c]}) ) { 
		$interval2{$Starts[$c]} = $interval{$Starts[$c]};
		foreach my$NM (@NMs) {
			foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
				{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
			}
		$c++; 
		}
	if ( $startBed[$i] > $interval{$Starts[$c]} ) { #for current $c
		$interval2{$Starts[$c]} = $interval{$Starts[$c]};
		foreach my$NM (@NMs) {
			foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
				{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
			} 
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] <= $interval{$Starts[$c]}) && ($endBed >= $Starts[$c]) ) {
		if ($startBed[$i] < $Starts[$c]) {
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = $interval{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$NM (@NMs) {
				foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$startBed[$i]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		else {
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = $interval{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$NM (@NMs) {
				foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		$c++;
		}
	if ( ($startBed[$i] <= $interval{$Starts[$c]}) && ($endBed >= $Starts[$c]) ) {	#for current $c
		if ($startBed[$i] < $Starts[$c]) {
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = $interval{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$NM (@NMs) {
				foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$startBed[$i]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		else {
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = $interval{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$NM (@NMs) {
				foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
					{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
				}
			}
		}
	}
#if region keep going on after end of bed
while ( ($c < scalar@Starts) && ($Starts[$c] > $endBed) ) {
	$interval2{$Starts[$c]} = $interval{$Starts[$c]};
	foreach my$NM (@NMs) {
		foreach my$startEx (keys%{ $NM_Ex{$NM}{$Starts[$c]} })
			{ $NM_Ex2{$NM}{$Starts[$c]}{$startEx} = $NM_Ex{$NM}{$Starts[$c]}{$startEx}; }
		}
	$c++; 
	}

#merge intervals
my@Starts2 = sort{$a<=>$b}(keys%interval2);
my(%interval3,%NM_Ex3,%RegBed2);
my$startReg = $Starts2[0];
my$endReg = $interval2{$startReg};
foreach my$NM (keys%NM_Ex2) {
	foreach my$startEx (keys%{ $NM_Ex2{$NM}{$startReg} })
		{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$startReg}{$startEx}; }
	}
foreach my$startBed (keys%{ $RegBed1{$startReg} })
	{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
for (my$i=1;$i<scalar(@Starts2);$i++) {
	if ($Starts2[$i] <= $endReg) { 
		if ($interval2{$Starts2[$i]} > $endReg)
			{ $endReg = $interval2{$Starts2[$i]}; }
		foreach my$NM (keys%NM_Ex2) {
			foreach my$startEx (keys%{ $NM_Ex2{$NM}{$Starts2[$i]} })
				{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$Starts2[$i]}{$startEx}; }
			}
		foreach my$startBed (keys%{ $RegBed1{$Starts2[$i]} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$Starts2[$i]}{$startBed}; }
		}
	else { 
		$interval3{$startReg} = $endReg;
		$startReg = $Starts2[$i];
		$endReg = $interval2{$startReg};
		foreach my$NM (keys%NM_Ex2)
			{
			foreach my$startEx (keys%{ $NM_Ex2{$NM}{$startReg} })
				{ $NM_Ex3{$NM}{$startReg}{$startEx} = $NM_Ex2{$NM}{$startReg}{$startEx}; }
			}
		foreach my$startBed (keys%{ $RegBed1{$startReg} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
		}
	}
$interval3{$startReg} = $endReg;

foreach my$NM (keys%NM_Ex3)
	{ %{ $NM_Ex{$NM} } = %{ $NM_Ex3{$NM} };	 }

return(\%interval3,\%NM_Ex,\%RegBed2);
}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#create 1 hash : 
sub changeRegion2N
{
	#@hashSub = changeRegion2N(\%{ $Regions{$NMchr{$NM}}{$NM} },\%{ $NM_Ex{$NM} },\%{ $Bed{$NMchr{$NM}} });
	#%{ $Regions{$NMchr{$NM}}{$NM} } = %{$hashSub[0]};
	#%{ $NM_Ex{$NM} } = %{$hashSub[1]};
	#%{ $RegBed{$NM} } = %{$hashSub[2]};
my($h1,$h2,$h3) = @_;
my%interval = %$h1;		# $Regions{start of region} = end of region
my%NM_Ex = %$h2;		# %NM_Ex{start of region}{start of exon} = end of exon
my%Bed = %$h3;			#$Bed{$startBed} = $endBed;

my%RegBed;			#$RegBed{$startReg}{$startBed} = $endBed;

my@Starts = sort{$a<=>$b}(keys%interval);
my(%interval2,%NM_Ex2,%RegBed1);
my$c=0;	#$c: count of @StartInterval			
my@startBed = sort{$a<=>$b}keys%Bed;
my$endBed = $Bed{$startBed[0]};
for (my$i=0;$i<scalar@startBed;$i++)
	{
	if ($startBed[$i] > $interval{$Starts[-1]})	#if bed keep going on after end of region
		{ last; }
	$endBed = $Bed{$startBed[$i]};	
	if ( $endBed < $Starts[0] )
		{ next; }
	if ( $endBed < $Starts[$c] )
		{
		if ($startBed[$i] > $interval{$Starts[$c-1]})
			{ 
			$interval2{$startBed[$i]} = $endBed; 
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			next;
			}
		else { $c--; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] > $interval{$Starts[$c]}) )
		{ 
		$interval2{$Starts[$c]} = $interval{$Starts[$c]};
		foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
			{ $NM_Ex2{$Starts[$c]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
		$c++; 
		}
	if ( $startBed[$i] > $interval{$Starts[$c]} )	#for current $c
		{ 
		$interval2{$Starts[$c]} = $interval{$Starts[$c]};
		foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
			{ $NM_Ex2{$Starts[$c]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
		}
	while ( ($c < (scalar@Starts -1)) && ($startBed[$i] <= $interval{$Starts[$c]}) && ($endBed >= $Starts[$c]) )
		{
		if ($startBed[$i] < $Starts[$c])
			{
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = $interval{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
				{ $NM_Ex2{$startBed[$i]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
			}
		else
			{
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = $interval{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
				{ $NM_Ex2{$Starts[$c]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
			}
		$c++;
		}
	if ( ($startBed[$i] <= $interval{$Starts[$c]}) && ($endBed >= $Starts[$c]) )	#for current $c
		{
		if ($startBed[$i] < $Starts[$c])
			{
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$startBed[$i]} = $endBed; }
			else
				{ $interval2{$startBed[$i]} = $interval{$Starts[$c]}; }
			$RegBed1{$startBed[$i]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
				{ $NM_Ex2{$startBed[$i]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
			}
		else
			{
			if ($endBed > $interval{$Starts[$c]})
				{ $interval2{$Starts[$c]} = $endBed; }
			else
				{ $interval2{$Starts[$c]} = $interval{$Starts[$c]}; }
			$RegBed1{$Starts[$c]}{$startBed[$i]} = $endBed;
			foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
				{ $NM_Ex2{$Starts[$c]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
			}
		}
	}
#if region keep going on after end of bed
while ( ($c < scalar@Starts) && ($Starts[$c] > $endBed) )
	{
	$interval2{$Starts[$c]} = $interval{$Starts[$c]};
	foreach my$startEx (keys%{ $NM_Ex{$Starts[$c]} })
		{ $NM_Ex2{$Starts[$c]}{$startEx} = $NM_Ex{$Starts[$c]}{$startEx}; }
	$c++; 
	}

#merge intervals
my@Starts2 = sort{$a<=>$b}(keys%interval2);
my(%interval3,%NM_Ex3,%RegBed2);
my$startReg = $Starts2[0];
my$endReg = $interval2{$startReg};
foreach my$startEx (keys%{ $NM_Ex2{$startReg} })
	{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$startReg}{$startEx}; }
foreach my$startBed (keys%{ $RegBed1{$startReg} })
	{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
for (my$i=1;$i<scalar(@Starts2);$i++)
	{
	if ($Starts2[$i] <= $endReg)
		{ 
		if ($interval2{$Starts2[$i]} > $endReg)
			{ $endReg = $interval2{$Starts2[$i]}; }
		foreach my$startEx (keys%{ $NM_Ex2{$Starts2[$i]} })
			{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$Starts2[$i]}{$startEx}; }
		foreach my$startBed (keys%{ $RegBed1{$Starts2[$i]} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$Starts2[$i]}{$startBed}; }
		}
	else
		{ 
		$interval3{$startReg} = $endReg;
		$startReg = $Starts2[$i];
		$endReg = $interval2{$startReg};
		foreach my$startEx (keys%{ $NM_Ex2{$startReg} })
			{ $NM_Ex3{$startReg}{$startEx} = $NM_Ex2{$startReg}{$startEx}; }
		foreach my$startBed (keys%{ $RegBed1{$startReg} })
			{ $RegBed2{$startReg}{$startBed} = $RegBed1{$startReg}{$startBed}; }
		}
	}
$interval3{$startReg} = $endReg;	

return(\%interval3,\%NM_Ex3,\%RegBed2);
}


#########################
#extract bed from file, and intersect with %Regions (regions of selected genes) 
#no -L option: shorten bed eventually
#create 1 hash : 
sub linkBed
{
my($h1,$h2) = @_;
my%NM_interval = %$h1;		# $Regions{chr}{gene}{start of region} = end of region
my%Bed = %$h2;			#$Bed{$chr}{$startBed} = $endBed;

#my%covBed2;			
my%RegBed;			#$RegBed{$NM}{$startRegion}{$startBed} = $endBed;
my$c=0;				#idx of $startByChr = sort{$a<=>$b}(keys%{ $allInterval{$chr} });
foreach my$chr (keys%NM_interval)
	{
	foreach my$NM (keys%{ $NM_interval{$chr} })
		{
		my%interval = %{ $NM_interval{$chr}{$NM} };
		my@Starts = sort{$a<=>$b}(keys%interval);
		my$c=0;
		foreach my$start (sort{$a<=>$b}keys%{ $Bed{$chr} })
			{
			my$end = $Bed{$chr}{$start};
			if ( $end < $Starts[$c] )
				{ next; }
			while ( ($c < (scalar(@Starts)-1)) && ($start > $interval{$Starts[$c]}) )
				{ $c++; }
			my$c2=$c;
			while ( ($c2 < scalar@Starts) && ($start <= $interval{$Starts[$c2]}) && ($end >= $Starts[$c2]) )
				{ 
				#eventually restrict %Bed
				if ($start < $Starts[$c2])
					{
					if ($end > $interval{$Starts[$c2]})
						{ 
						#$covBed2{$chr}{$Starts[$c2]} = $interval{$Starts[$c2]};
						$RegBed{$NM}{$Starts[$c2]}{$Starts[$c2]} = $interval{$Starts[$c2]};
						}
					else
						{ 
						#$covBed2{$chr}{$Starts[$c2]} = $end;
						$RegBed{$NM}{$Starts[$c2]}{$Starts[$c2]} = $end;
						}
					}
				else
					{
					if ($end > $interval{$Starts[$c2]})
						{ 
						#$covBed2{$chr}{$start} = $interval{$Starts[$c2]}; 
						$RegBed{$NM}{$Starts[$c2]}{$start} = $interval{$Starts[$c2]};
						}
					else
						{
						#$covBed2{$chr}{$start} = $end; 
						$RegBed{$NM}{$Starts[$c2]}{$start} = $end;
						}
					}
				$c2++;
				}
			}
		}
	}
#return(\%covBed2,\%RegBed);
return(%RegBed);
}


#########################
#eliminates $NM with no corresponding cov bed
sub notAnalysedG
{
my($h0,$h1,$h2,$h3)=@_;
my%Genes = %$h0;
my%Regions = %$h1;
my%NM_Ex = %$h2;
my%RegBed = %$h3;
my(@Not,%Genes2,%Regions2,%NM_Ex2,%RegBed2);
foreach my$gene (keys%Genes) {
	my@startBed = keys%{ $RegBed{$gene} };
	unless (@startBed) {
		print "$gene not in analysed bed\n";
		push(@Not ,$gene);
		}
	}
foreach my$chr (sort(keys%Regions)) {
	foreach my$gene (sort(keys%{ $Regions{$chr} })) {
		my$ok=1;
		foreach my$not(@Not) {
			if ($gene eq $not)
				{ $ok=0; last; }
			}
		if ($ok) {
			$Genes2{$gene} = 1;
			%{ $Regions2{$chr}{$gene} } = %{ $Regions{$chr}{$gene} };
			foreach (@{ $geneNM{$gene}})
				{ %{ $NM_Ex2{$_} } = %{ $NM_Ex{$_} }; }
			%{ $RegBed2{$gene} } = %{ $RegBed{$gene} };
			}	
		}
	}
return(\%Genes2,\%Regions2,\%NM_Ex2,\%RegBed2);
}
#############
#eliminates $NM with no corresponding cov bed
sub notAnalysedN
{
my($h0,$h1,$h2,$h3,$h4)=@_;
my%Genes = %$h0;
my%NMgene = %$h1;
my%Regions = %$h2;
my%NM_Ex = %$h3;
my%RegBed = %$h4;
my(@Not,%Genes2,%Regions2,%NM_Ex2,%RegBed2);
foreach my$NM (keys%NM_Ex) {
	my@startBed = keys%{ $RegBed{$NM} };
	unless (@startBed) {
		print "$NM not in analysed bed\n";
		push(@Not ,$NM);
		}
	}
foreach my$chr (sort(keys%Regions)) {
	foreach my$NM (sort(keys%{ $Regions{$chr} })) {
		my$ok=1;
		foreach my$not(@Not) {
			if ($NM eq $not)
				{ $ok=0; last; }
			}
		if ($ok) {
			$Genes2{$NMgene{$NM}} = 1;
			%{ $Regions2{$chr}{$NM} } = %{ $Regions{$chr}{$NM} };
			%{ $NM_Ex2{$NM} } = %{ $NM_Ex{$NM} };
			%{ $RegBed2{$NM} } = %{ $RegBed{$NM} };
			}	
		}
	}
return(\%Genes2,\%Regions2,\%NM_Ex2,\%RegBed2);
}


#########################

sub readMut
{
my($file) = @_;
my(%Mut);			#$covbed{$chr}{$start} = $end;
open(BED, $file) || die "can't open file $file\n";
while (my$line=<BED>) {
	unless($line =~ /^\s*$/ || $line =~ /^#/) {
		$line =~ s/\s+$//;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//i;
		$Mut{$tab[0]}{$tab[1]} = $tab[2];	#already in 1-based coord
		}
	}
close BED;
return(%Mut);
}


#########################

sub linkMut
{
my($h1,$h2) = @_;
my%NM_interval = %$h1;		# $Regions{chr}{NM}{start of region} = end of region
my%Mut = %$h2;			#$Mut{$chr}{$startMut} = $infoMut;

my%RegMut;			#$RegMut{$NM}{$startRegion}{$startMut} = $MutInfo;
my$c=0;				#idx of $Starts = sort{$a<=>$b}(keys%{ $NM_interval{$chr} });
foreach my$chr (keys%NM_interval) {
	foreach my$NM (keys%{ $NM_interval{$chr} }) {
		my%interval = %{ $NM_interval{$chr}{$NM} };
		my@Starts = sort{$a<=>$b}(keys%interval);
		my$c=0;
		foreach my$mut (sort{$a<=>$b}keys%{ $Mut{$chr} }) {
			if ( $mut < $Starts[$c] )
				{ next; }
			while ( ($c < (scalar(@Starts)-1)) && ($mut > $interval{$Starts[$c]}) )
				{ $c++; }
			if ( ($mut <= $interval{$Starts[$c]}) && ($mut >= $Starts[$c]) )
				{ $RegMut{$NM}{$Starts[$c]}{$mut} = $Mut{$chr}{$mut}; }
			}
		}
	}

return(%RegMut);
}


#########################
sub depthMut
{
#%tmpFile = depthMut($mutFile,\%path,$extenS,\@Files,\%fName,\%Mut,$outdir,\%withChr,$keepTmp,\%tmpFile,$mmq,$mbq,$dedup,$bedT,$samT,$picard,$gatk,$genom);
my($mutFile,$h1,$extenS,$h2,$h3,$h4,$h5,$h6,$outdir,$h7,$keepTmp,$h8,$mmq,$mbq,$dedup,$threads,$chromLength,$bedT,$bedTversion,$samT,$picard,$gatk,$genom) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName = %$h4;
my%sName2 = %$h5;
my%Mut = %$h6;
my%withChr = %$h7;
my%tmpFile = %$h8;

#print bed
open(MUT0,">$outdir/mut_0Chr.bed") or die "cannot create $outdir/mut_0Chr.bed";
open(MUTw,">$outdir/mut_wChr.bed") or die "cannot create $outdir/mut_wChr.bed";
foreach my$chr (sort(keys%Mut)) {
	foreach my$pos (sort{$a<=>$b}keys%{ $Mut{$chr} }) {
		print MUT0 $chr."\t".($pos-1)."\t".$pos."\n";
		print MUTw "chr".$chr."\t".($pos-1)."\t".$pos."\n";
		}
	}
close(MUT0);close(MUTw);
#coveragedepth
my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}
my%depthMut;
my@Pos;
if($gatk) { 
	my($r1,$r2) = gatkCov("mut",\%path,$extenS,\@Files,\%fName,\%sName,$outdir,"all.covMut",$withChr{"all"},$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom);
	my%gatkIdx = %$r1;
	open(IN, "$outdir/all.covMut");
	while (<IN>) { 
		my$line = $_;
		chomp $line;
		my@tab = split(/\t/,$line);
		my@tab2 = split(/:/,$tab[0]);
		my$chr = $tab2[0];
		$chr =~ s/^chr//i;
		push(@Pos, $chr."\t".$tab2[1]);
		foreach(@Files)
			{ push (@{ $depthMut{$_} }, $tab[$gatkIdx{$_}]) ; }
		}
	close(IN);
	unlink glob "$outdir/all.covMut*";
	}
else {
	foreach (@Files) {
		$tmpFile{$_} = bedToolCmd("mut",$fName{$_},$path{$_},$extenS,$outdir,".covMut",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
		unless ($withChr{$_}) {
			open(COV, "$outdir/$fName{$_}.covMut") || die "can't open file $outdir/$fName{$_}.covMut\n";
			my$ok=0;
			while (my$line=<COV>) {
				chomp $line;
				my@tab = split(/\t/,$line);
				if ($tab[-1] != 0)
					{ $ok=1; last; }
				}
			close COV;
			unless ($ok) {
				print "try other reference genome:\n";
				foreach my$f (@Files) { 
					unless ($withChr{$f}) { 
						if ($isChr{$f}eq"_0Chr.bed") { $isChr{$f} = "_wChr.bed"; }
						else { $isChr{$f} = "_0Chr.bed"; }
						} 
					}
				$tmpFile{$_} = bedToolCmd("mut",$fName{$_},$path{$_},$extenS,$outdir,".covMut",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$samT,$picard);
				}
			}
		my$cmd = "sort -k 1,1 -k 2n,2n -k 4n,4n -o $outdir/$fName{$_}.covMut $outdir/$fName{$_}.covMut";
		print "$cmd\n";
		system "$cmd";
		open(IN, "$outdir/$fName{$_}.covMut");
		while (my$line=<IN>) {
			chomp $line;
			push (@{ $depthMut{$_} }, $line) ;
			}
		close(IN);
		unlink "$outdir/$fName{$_}.covMut";
		}
	}
unlink "$outdir/mut_0Chr.bed";
unlink "$outdir/mut_wChr.bed";

#print mut_depth.txt
my@mutName = split(/\//, $mutFile);
$mutName[-1] =~ s/.list$//;
open(COV, ">$outdir/$mutName[-1]\_depth.txt") or die "cannot create $outdir/$mutName[-1]\_depth.txt";
print COV "chr\t1-based position\tmutation";
foreach (@Files) { print COV "\t$sName2{$_}"; }
print COV "\n";
unless ($gatk) {
	foreach (@{ $depthMut{$Files[0]} }) {
		my@tab = split(/\t/,$_); 
		my$chr = $tab[0]; 
		$chr =~ s/^chr//i;
		push(@Pos, $chr."\t".($tab[1]+1));
		}
	}
for my$i (0 .. $#Pos) {
	print COV $Pos[$i];
	my@loc = split(/\t/,$Pos[$i]);
	print COV "\t".$Mut{$loc[0]}{$loc[1]};
	foreach my$file(@Files) {
		if ($gatk) { print COV "\t".$depthMut{$file}[$i]; }
		else {
			my@tab = split(/\t/,$depthMut{$file}[$i]); 
			print COV "\t".$tab[-1];
			}
		}
	print COV "\n";
	}
close(COV);
return(%tmpFile)
}


#########################
#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#if end of exon = x, start of next exon = x
sub transposeReg
{
my($spacer,$h1) = @_;
my%Regions=%$h1;		# $Regions{chr}{NM}{start of region} = end of region	

my(%Reg_00,%NMlength);	
#$Reg_00{$NM}{$startReg} = endReg (for start of region = 0)
foreach my$chr (keys%Regions)
	{
	foreach my$gene ( keys%{ $Regions{$chr} } )	#$gene or $NM
		{
		print "transpose and splice $gene\n";
		my@Starts = sort{$a<=>$b}(keys%{ $Regions{$chr}{$gene} });
		#find $spacer as $NMlength/100
		#unless((exists $opts{S}) && ($opts{S} eq "N"))
		#	{
			$NMlength{$gene}=0;
			for (my$reg=0;$reg<scalar@Starts;$reg++)
				{ $NMlength{$gene} += ($Regions{$chr}{$gene}{$Starts[$reg]} - $Starts[$reg] +1); }
			$spacer = int($NMlength{$gene}/100);
		#	}
		#transpose $Regions{$chr}{$gene}
		my$start00 = 0;
		my$end00 =  $Regions{$chr}{$gene}{$Starts[0]} - $Starts[0] + $start00 +1;
		$Reg_00{$gene}{$start00} = $end00;
		for (my$reg=1;$reg<scalar@Starts;$reg++)
			{
			$start00 = $end00 + $spacer;
			$end00 = $Regions{$chr}{$gene}{$Starts[$reg]} - $Starts[$reg] + $start00 +1;
			$Reg_00{$gene}{$start00} = $end00;
			}
		#re-calculates $NMlength
		my@Starts00 = sort{$a<=>$b}(keys%{ $Reg_00{$gene} });
		$NMlength{$gene} = $Reg_00{$gene}{$Starts00[-1]};
		}
	}
return($spacer,\%NMlength,\%Reg_00);
}

#########################
#transposition and splicing, for exons of transcripts: 
#1st position of 1st exon = 0, 
#if end of exon = x, start of next exon = x
sub transposeNM
{
my($wUTR,$NMstartCod,$NMendCod,$h1,$h2,$h3) = @_;
my%Reg=%$h1;			# $Regions{start of region} = end of region
my%Reg_00=%$h2;			#$Reg_00{$startReg} = endReg (for start of region = 0)	
my%NM_Ex=%$h3;			# %NM_Ex{start of region}{start of exon} = end of exon

my(%NM_Ex00,$NMstartCod00,$NMendCod00);	
#NM_Ex00{$startReg}{$startExon} = endExon (for start of region = 0)
my@Starts = sort{$a<=>$b}(keys%Reg);
my@Starts00 = sort{$a<=>$b}(keys%Reg_00);

my$r=0;
if ($wUTR) {
	#transpose $NMstartCod and $NMendCod
	if (($NMstartCod-1)!=$NMendCod) { 
		while ($NMstartCod>$Reg{$Starts[$r]}) { $r++; }
		$NMstartCod00 = $NMstartCod - $Starts[$r] + $Starts00[$r];
		while ( ($NMendCod>$Reg{$Starts[$r]}) ) { $r++; }
		$NMendCod00 = $NMendCod - $Starts[$r] + $Starts00[$r] +1;
		}
	else { $NMstartCod00=0; $NMendCod00=0; }
	#transpose %NM_Ex
	for ($r=0;$r<scalar@Starts;$r++) {
		foreach my$startEx (keys%{ $NM_Ex{$Starts[$r]} }) {
			$NM_Ex00{$Starts00[$r]}{($startEx-$Starts[$r]+$Starts00[$r])} = $NM_Ex{$Starts[$r]}{$startEx}-$Starts[$r]+$Starts00[$r]+1;
			}
		}
	}
else {
	my($rIni,$rFin);
	my@startsNM = sort{$a<=>$b}keys%NM_Ex;
	while ($r <= $#Starts && $Starts[$r] != $startsNM[0]) { $r++; }
	$rIni = $r;
	#transpose $NMstartCod and $NMendCod
	my@StartsEx1 = sort{$a<=>$b}keys%{ $NM_Ex{$startsNM[0]} };
	$NMstartCod00 = $StartsEx1[0]-$startsNM[0] + $Starts00[$r];
	$r = $#Starts;
	while ($r > 0 && $Starts[$r] != $startsNM[-1]) { $r--; }
	$rFin = $r;
	my@StartsExf = sort{$a<=>$b}(keys%{ $NM_Ex{$startsNM[-1]} });	
	$NMendCod00 = $Reg{$startsNM[-1]}-$NM_Ex{$startsNM[-1]}{$StartsExf[-1]} + $Starts00[$r] +1;
	#transpose %NM_Ex
	for ($r=$rIni;$r<=$rFin;$r++) {
		foreach my$startEx (keys%{ $NM_Ex{$Starts[$r]} }) {
			$NM_Ex00{$Starts00[$r]}{($startEx-$Starts[$r]+$Starts00[$r])} = $NM_Ex{$Starts[$r]}{$startEx}-$Starts[$r]+$Starts00[$r]+1;
			}
		}
	}

return($NMstartCod00,$NMendCod00,\%NM_Ex00);
}


#########################
#if ($All):
#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons 
sub designExons1
{
#@hashSub = designExons(\%Reg_00,\%NM_00,\%NMstartCod00,\%NMendCod00);
my($wUTR,$h1,$h2,$h3,$h4,$h5,$h6) = @_;
my%Genes=%$h1;
my%geneNM=%$h2;
my%Reg_00=%$h3;			#$Reg_00{NM}{start of region} = end of region (for start of region = 0)
my%NM_Ex00=%$h4;		#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my%NMstartCod00=%$h5;		#$NMstartCod00{$NM} = $start of coding sequence (for start of region = 0)
my%NMendCod00=%$h6;		#$NMendCod00{$NM} = $end of coding sequence (for start of region = 0)

my(%intron,%UTR,%Cod);
#$intron{$NM}{$startInt} = $endInt;
#$UTR{$NM}{$startUTR} = $endUTR;
#$Cod{$NM}{$startCod} = $endCod;
foreach my$gene (keys%Genes) {
	print "design exons of $gene\n";
	my@startReg = sort{$a<=>$b}keys%{ $Reg_00{$gene} } ; 
	foreach my$NM (@{ $geneNM{$gene} }) {
		print "\tfor $NM\n";
		my(%Exons,@startEx);
		#introns:
		foreach my$startR (@startReg) {
			my@Starts = sort{$a<=>$b}(keys%{ $NM_Ex00{$NM}{$startR} });
			if (@Starts) {
				$intron{$NM}{$startR} = $Starts[0];
				for (my$ex=0;$ex<(scalar@Starts-1);$ex++)
					{ $intron{$NM}{ $NM_Ex00{$NM}{$startR}{$Starts[$ex]} } = $Starts[$ex+1]; }
				$intron{$NM}{ $NM_Ex00{$NM}{$startR}{$Starts[-1]} } = $Reg_00{$gene}{$startR};
				push (@startEx , @Starts); 
				for (my$ex=0;$ex<scalar@Starts;$ex++)
					{ $Exons{$Starts[$ex]} = $NM_Ex00{$NM}{$startR}{$Starts[$ex]}; }
				}
			else
				{ $intron{$NM}{$startR} = $Reg_00{$gene}{$startR}; }
			}
		#exons:
		my$i=0;
		if ($wUTR) {
			if ($NMstartCod00{$NM}==$NMendCod00{$NM}) {
				while ($i<scalar@startEx) {
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;
					}
				}
			else {
					#UTRpreCod
				while ( $Exons{$startEx[$i]}<$NMstartCod00{$NM} && $i<(scalar@startEx-1) ) {
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;						
					}
				if ( $startEx[$i] < $NMstartCod00{$NM} ) 
					{ $UTR{$NM}{$startEx[$i]} = $NMstartCod00{$NM}; }
					#Cod
				if( $Exons{$startEx[$i]} >= $NMendCod00{$NM} )
					{ $Cod{$NM}{$NMstartCod00{$NM}} = $NMendCod00{$NM}; }
				else {
					$Cod{$NM}{$NMstartCod00{$NM}} = $Exons{$startEx[$i]}; 
					$i++;
					while ( $Exons{$startEx[$i]}<$NMendCod00{$NM} && $i<(scalar@startEx-1) ) {
						$Cod{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
						$i++;	
						}
					if ( $Exons{$startEx[$i]} >= $NMendCod00{$NM} ) 
						{ $Cod{$NM}{$startEx[$i]} = $NMendCod00{$NM}; }
					}
					#UTRpostCod
				if ( $Exons{$startEx[$i]} > $NMendCod00{$NM} ) 
					{ $UTR{$NM}{$NMendCod00{$NM}} = $Exons{$startEx[$i]}; }
				while ($i<(scalar@startEx-1)) {
					$i++;
					$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					}
				}
			}
		else {
			foreach (@startEx)
				{ $Cod{$NM}{$_} = $Exons{$_}; }
			}
		}
	}
return(\%intron,\%UTR,\%Cod);
}

#########################
#foreach $NM
#make arrays for starts of non coding exons, before and after coding exons
#and arrays for starts of extragenic regions, before and after exons 
sub designExons2
{
#@hashSub = designExons(\%Reg_00,\%NM_00,\%NMstartCod00,\%NMendCod00);
my($wUTR,$h1,$h2,$h3,$h4) = @_;
my%Reg_00=%$h1;			#$Reg_00{NM}{start of region} = end of region (for start of region = 0)
my%NM_Ex00=%$h2;		#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my%NMstartCod00=%$h3;		#$NMstartCod00{$NM} = $start of coding sequence (for start of region = 0)
my%NMendCod00=%$h4;		#$NMendCod00{$NM} = $end of coding sequence (for start of region = 0)

my(%intron,%UTR,%Cod);
#$intron{$NM}{$startInt} = $endInt;
#$UTR{$NM}{$startUTR} = $endUTR;
#$Cod{$NM}{$startCod} = $endCod;
foreach my$NM (keys%Reg_00) {
	print "design exons of $NM\n";
	my@startReg = sort{$a<=>$b}keys%{ $Reg_00{$NM} } ;
	my(%Exons,@startEx);
	#introns:
	foreach my$startR (@startReg) {
		my@Starts = sort{$a<=>$b}(keys%{ $NM_Ex00{$NM}{$startR} });
		if (@Starts)
			{
			$intron{$NM}{$startR} = $Starts[0];
			for (my$ex=0;$ex<(scalar@Starts-1);$ex++)
				{ $intron{$NM}{ $NM_Ex00{$NM}{$startR}{$Starts[$ex]} } = $Starts[$ex+1]; }
			$intron{$NM}{ $NM_Ex00{$NM}{$startR}{$Starts[-1]} } = $Reg_00{$NM}{$startR};
			push (@startEx , @Starts);
			for (my$ex=0;$ex<scalar@Starts;$ex++)
				{ $Exons{$Starts[$ex]} = $NM_Ex00{$NM}{$startR}{$Starts[$ex]}; }
			}
		else
			{ $intron{$NM}{$startR} = $Reg_00{$NM}{$startR}; }
		}
	#exons:
	my$i=0;
	if ($wUTR) {
		if ($NMstartCod00{$NM}==$NMendCod00{$NM}) {
			while ($i<scalar@startEx) {
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				$i++;
				}
			}
		else {
				#UTRpreCod
			while ( $Exons{$startEx[$i]}<$NMstartCod00{$NM} && $i<(scalar@startEx-1) ) {
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				$i++;						
				}
			if ( $startEx[$i] < $NMstartCod00{$NM} ) 
				{ $UTR{$NM}{$startEx[$i]} = $NMstartCod00{$NM}; }
				#Cod
			if( $Exons{$startEx[$i]} >= $NMendCod00{$NM} )
				{ $Cod{$NM}{$NMstartCod00{$NM}} = $NMendCod00{$NM}; }
			else {
				$Cod{$NM}{$NMstartCod00{$NM}} = $Exons{$startEx[$i]}; 
				$i++;
				while ( $Exons{$startEx[$i]}<$NMendCod00{$NM} && $i<(scalar@startEx-1) ) {
					$Cod{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
					$i++;	
					}
				if ( $Exons{$startEx[$i]} >= $NMendCod00{$NM} ) 
					{ $Cod{$NM}{$startEx[$i]} = $NMendCod00{$NM}; }
				}
				#UTRpostCod
			if ( $Exons{$startEx[$i]} > $NMendCod00{$NM} ) 
				{ $UTR{$NM}{$NMendCod00{$NM}} = $Exons{$startEx[$i]}; }
			while ($i<(scalar@startEx-1)) {
				$i++;
				$UTR{$NM}{$startEx[$i]} = $Exons{$startEx[$i]};
				}
			}
		}
	else {
		foreach (@startEx)
			{ $Cod{$NM}{$_} = $Exons{$_}; }
		}
	}
return(\%intron,\%UTR,\%Cod);
}


#########################

#transposition and splicing of RegBed and RegMut
sub transposeBed
{
my($h1,$h2,$h3,$h4) = @_;
my%Regions = %$h1;		# $Regions{chr}{NM}{start of region} = end of region
my%Reg_00 = %$h2;		# #$Reg_00{$NM}{$startReg} = endReg (start of Region =0)
my%RegBed = %$h3;		#$RegBed{$NM}{$startRegion}{$startBed} = $endBed;
my%RegMut = %$h4;		#$RegMut{$NM}{$startRegion}{$startMut} = $MutInfo;

my(%NMbed00,%NMmut00);		#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
				#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
foreach my$chr (keys%Regions) {
	foreach my$NM ( keys%{ $Regions{$chr} } )	#$gene or $NM
		{
		my@startReg = sort{$a<=>$b}(keys%{ $Regions{$chr}{$NM} });
		my@start00 = sort{$a<=>$b}(keys%{ $Reg_00{$NM} });
		for (my$i=0;$i<scalar@startReg;$i++)
			{
			my$sub = $startReg[$i] - $start00[$i];
			foreach my$startBed ( keys%{ $RegBed{$NM}{$startReg[$i]} } )
				{ $NMbed00{$NM}{($startBed-$sub)} = $RegBed{$NM}{$startReg[$i]}{$startBed}-$sub+1; }
			foreach my$mut ( keys%{ $RegMut{$NM}{$startReg[$i]} } )
				{ $NMmut00{$NM}{($mut-$sub)} = $RegMut{$NM}{$startReg[$i]}{$mut}; }
			}
		}
	}
return(\%NMbed00,\%NMmut00);
}


##########################
sub ReverseGene1
{
#@hashSub = ReverseGene1($gene,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $RegBed{"coord0"}{$gene} },\%{ $RegMut{"coord0"}{$gene} });
my($gene,$length,$h1,$h2,$h3)=@_;
my%Reg_00 = %$h1;
my%NMbed00 = %$h2;
my%NMmut00 = %$h3;

print "reverse $gene\n";
my%RegR;
foreach my$startReg (keys%Reg_00)
	{ $RegR{($length-$Reg_00{$startReg})} = $length-$startReg; }

my%NMbedR = reverseEx($length,\%NMbed00);

#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
my%NMmutR; 
foreach (keys%NMmut00)
	{ $NMmutR{($length-$_)} = $NMmut00{$_}; }

return(\%RegR,\%NMbedR,\%NMmutR);
}

##########################
sub ReverseGene2
{
#@hashSub = ReverseGene2($NM,$NMlength{$gene},\%{ $Regions{"coord0"}{$gene} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} });
my($NM,$length,$h1,$h2,$h3,$h4,$h5)=@_;
my%Reg_00 = %$h1;
my%NM_Ex00 = %$h2;
my%intron = %$h3;
my%UTR = %$h4;
my%Cod = %$h5;

print "reverse $NM\n";
my%NM_ExR;
foreach my$startReg (keys%Reg_00)
	{ %{ $NM_ExR{($length-$Reg_00{$startReg})} } = reverseEx( $length,\%{ $NM_Ex00{$startReg} } ); }
	
# $intron{$NM}{$startIntron} = $endIntron (for start of region = 0)
%intron = reverseEx($length,\%intron);
# $UTR{$NM}{$startUTR} = $endUTR (for start of region = 0)
%UTR = reverseEx($length,\%UTR);
# $Cod{$NM}{$startCod} = $endCod (for start of region = 0)}
%Cod = reverseEx($length,\%Cod);

return(\%NM_ExR,\%intron,\%UTR,\%Cod);
}

##########################
sub ReverseNMs
{
#@hashSub = ReverseNMs($NM,$NMlength{$NM},\%{ $Regions{"coord0"}{$NM} },\%{ $NM_Ex{"coord0"}{$NM} },\%{ $intron{"coord0"}{$NM} },\%{ $UTR{"coord0"}{$NM} },\%{ $Cod{"coord0"}{$NM} },\%{ $RegBed{"coord0"}{$NM} },\%{ $RegMut{"coord0"}{$NM} });
my($NM,$length,$h1,$h2,$h3,$h4,$h5,$h6,$h7)=@_;
my%Reg_00 = %$h1;
my%NM_Ex00 = %$h2;
my%intron = %$h3;
my%UTR = %$h4;
my%Cod = %$h5;
my%NMbed00 = %$h6;
my%NMmut00 = %$h7;

print "reverse $NM\n";
my(%RegR,%NM_ExR);
foreach my$startReg (keys%Reg_00) {
	$RegR{($length-$Reg_00{$startReg})} = $length-$startReg;
	%{ $NM_ExR{($length-$Reg_00{$startReg})} } = reverseEx( $length,\%{ $NM_Ex00{$startReg} } );
	}

# $intron{$NM}{$startIntron} = $endIntron (for start of region = 0)
%intron = reverseEx($length,\%intron);
# $UTR{$NM}{$startUTR} = $endUTR (for start of region = 0)
%UTR = reverseEx($length,\%UTR);
# $Cod{$NM}{$startCod} = $endCod (for start of region = 0)}
%Cod = reverseEx($length,\%Cod);

#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
my%NMbedR = reverseEx($length,\%NMbed00);
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
my%NMmutR; 
foreach (keys%NMmut00)
	{ $NMmutR{($length-$_)} = $NMmut00{$_}; }

return(\%RegR,\%NM_ExR,\%intron,\%UTR,\%Cod,\%NMbedR,\%NMmutR);
}


###########################
#merge intervals from %Regions: 
#$Regions{chr}{NM}{start of region} = end of region
#my%allInterval = mergeIntervals(%Regions);
sub mergeIntervals
{
print "merge overlapping intervals from RefSeq selected transcripts\n";
# %allExon : key1 = chr, value1 = %( key2 = NM, value2 = %(key3 = exonstart, value3 = exonend) ) 
#$interval2{$chr}{$start} = $end;
my(%allExon) = @_;

#for each same starts, keep longer intervals
my(%interval,%chrom);
foreach my$chr (keys%allExon) {
	foreach my$NM (keys%{ $allExon{$chr} }) {
		$chrom{$chr} = 1;
		foreach my$start ( sort{$a<=>$b}(keys%{ $allExon{$chr}{$NM} }) ) {
			if ( exists $interval{$chr}{$start} ) {
				if ( $allExon{$chr}{$NM}{$start} > $interval{$chr}{$start} )
					{  $interval{$chr}{$start} = $allExon{$chr}{$NM}{$start}; }	
				else { next; }
				}
			else
				{ $interval{$chr}{$start} = $allExon{$chr}{$NM}{$start}; }
			}
		}
	}
my@chrom = sort(keys%chrom);

#merge overlapping intervals
my(%interval2);
foreach my$chr (@chrom) { 
	my@Starts = sort{$a<=>$b}(keys%{ $interval{$chr} }); 	#hash{chr}=@sortedStart
	my$start = $Starts[0];
	my$end = $interval{$chr}{$start};
	$interval2{$chr}{$start} = $end;
	for (my$i=1;$i<scalar(@Starts);$i++) {
		if ($Starts[$i] <= $end) {
			if ($interval{$chr}{$Starts[$i]} > $end)
				{ $end = $interval{$chr}{$Starts[$i]}; }
			else { next; }
			}
		else {
			$interval2{$chr}{$start} = $end;
			$start = $Starts[$i];
			$end = $interval{$chr}{$start};
			}
		}
	$interval2{$chr}{$start} = $end;
	}
return (%interval2)	#$interval2{$chr}{$start} = $end;
}


#####################
sub printBed
{
my($bedFile,$h1) = @_;
my%interval = %$h1;
open (OUT0, ">$outdir/$bedFile\_0Chr.bed")  || die "cannot create $outdir/$bedFile\_0Chr.bed\n";
open (OUTw, ">$outdir/$bedFile\_wChr.bed")  || die "cannot create $outdir/$bedFile\_wChr.bed\n";
foreach my$chr (sort(keys%interval)) {
	foreach my$start (sort{$a<=>$b}keys%{ $interval{$chr} }) {
		print OUT0 $chr."\t".($start-1)."\t".$interval{$chr}{$start}."\n";
		print OUTw "chr".$chr."\t".($start-1)."\t".$interval{$chr}{$start}."\n";
		}
	}
close OUT0;
close OUTw;
}


####################
#no longer used
sub withChr
{
my($bedName,$h1,$extenS,$h2,$h3,$outdir) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%withChr;
foreach (@Files) {
	#intersect: to know which bed to use (with or without chr prefix)
	$withChr{$_}="_0Chr.bed";
	print "bedtools intersect -a $path{$_}$fName{$_}$extenS -b $outdir/$bedName\_0Chr.bed -bed > $outdir/$fName{$_}\_inter.bed\n";
	system "bedtools intersect -a $path{$_}$fName{$_}$extenS -b $outdir/$bedName\_0Chr.bed -bed > $outdir/$fName{$_}\_inter.bed";
	if ( -z "$outdir/$fName{$_}\_inter.bed" ) { 
		print "no overlap between refseq and $fName{$_}\n";
		$withChr{$_}="_wChr.bed"; 
		}
	unlink "$outdir/$fName{$_}\_inter.bed";
	}
return(%withChr);
}


####################
#bedtools cov
sub bedToolsCov
{
my($bedName,$h1,$extenS,$h2,$h3,$outdir,$h4,$keepTmp,$h5,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%withChr = %$h4;
my%tmpFile = %$h5;

my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}
foreach (@Files) {
	$tmpFile{$_} = bedToolCmd($bedName,$fName{$_},$path{$_},$extenS,$outdir,".cov",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
	unless ($withChr{$_}) {
		open(COV, "$outdir/$fName{$_}.cov") || die "can't open file $outdir/$fName{$_}.cov\n";
		my$ok=0;
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			if ($tab[-1] != 0)
				{ $ok=1; last; }
			}
		close COV;
		unless ($ok) {
			print "try other reference genome:\n";
			foreach (@Files) { 
				unless ($withChr{$_}) { 
					if ($isChr{$_}eq"_0Chr.bed") { $isChr{$_} = "_wChr.bed"; }
					else { $isChr{$_} = "_0Chr.bed"; }
					} 
				}
			$tmpFile{$_} = bedToolCmd($bedName,$fName{$_},$path{$_},$extenS,$outdir,".cov",$isChr{$_},$keepTmp,$tmpFile{$_},$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard);
			}
		$withChr{$_} = $isChr{$_};
		}

	my$cmd = "sort -k 1,1 -k 2n,2n -k 4n,4n -o $outdir/$fName{$_}.cov $outdir/$fName{$_}.cov";
	print "$cmd\n";
	system "$cmd";
	}
}

##
sub bedToolCmd
{
my($bedName,$file,$path,$extenS,$outdir,$outname,$withChr,$keepTmp,$tmpFile,$mmq,$dedup,$chromLength,$bedT,$bedTversion,$samT,$picard) = @_;
print "perform bedtools coverageBed on $file\n";
my$cmd="";
if ($tmpFile) {
	if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $tmpFile -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
	else	{ $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $tmpFile -d -sorted -g $chromLength > $outdir/$file$outname"; }
	}
else {
	if ($mmq) { 
		$cmd = "$samT view -u -q $mmq $path$file$extenS"; #-L $outdir/$bedName$withChr ?
		if ($keepTmp && !$dedup) {
			$cmd .= " > $outdir/$file.tmp.bam";
			print "$cmd\n";
			system "$cmd";
			$tmpFile = "$outdir/$file.tmp.bam";
			}		
		}
	if ($dedup) { 
		if ($mmq) { 
			$cmd .= " > $outdir/tmp.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "samtools not happy\n"; }
			$cmd = "$picard MarkDuplicates I=$outdir/tmp.bam O=/dev/stdout M=$outdir/$file.dedup-metrics REMOVE_DUPLICATES=true QUIET=true COMPRESSION_LEVEL=0"; 
			}
		else { $cmd = "$picard MarkDuplicates I=$path$file$extenS O=/dev/stdout M=$outdir/$file.dedup-metrics REMOVE_DUPLICATES=true QUIET=true COMPRESSION_LEVEL=0"; }
		if ($keepTmp) {
			$cmd .= " > $outdir/$file.tmp.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "picard tools not happy\n"; }
			$tmpFile = "$outdir/$file.tmp.bam";
			}
		}
	if ($mmq || $dedup) { 
		if ($keepTmp) {
			if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $tmpFile -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
			else { $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $tmpFile -d -sorted -g $chromLength > $outdir/$file$outname"; }
			}
		else {
			if ($bedTversion == 1) { $cmd .= " | $bedT coverage -abam stdin -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
			else { $cmd .= " | $bedT coverage -a $outdir/$bedName$withChr -b stdin -d -sorted -g $chromLength > $outdir/$file$outname"; }
			}
		}
	else { 
		if ($bedTversion == 1) { $cmd = "$bedT coverage -abam $path$file$extenS -b $outdir/$bedName$withChr -d > $outdir/$file$outname"; }
		else { $cmd = "$bedT coverage -a $outdir/$bedName$withChr -b $path$file$extenS -d -sorted -g $chromLength > $outdir/$file$outname"; }
		}
	}
print "$cmd\n";
system "$cmd";
if ($?) { die "bedtools not happy\n"; }
if (-e "$outdir/tmp.bam") { unlink "$outdir/tmp.bam"; }
if ($dedup) { unlink "$outdir/$file.dedup-metrics"; } 
return($tmpFile);
}


####################
#GATK cov
#%gatkIdx = gatkCov($intervalName,\%path,$extenS,\@Files,\%fName,$outdir,"all.cov",$withChr{"all"},$mmq,$mbq,$dedup,$gatk,$picard,$genom);
sub gatkCov
{
my($intervalFile,$h1,$extenS,$h2,$h3,$h4,$outdir,$outName,$withChr,$mmq,$mbq,$dedup,$threads,$gatk,$picard,$genom) = @_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName = %$h4;

my$cmd="";
if ($dedup eq "do") {
	foreach (@Files) {
		unless (-e "$outdir/$fName{$_}-dedup.bam") {
			$cmd = "$picard MarkDuplicates I=$path{$_}$fName{$_}$extenS O=$outdir/$fName{$_}-dedup.bam M=$outdir/$fName{$_}.dedup-metrics QUIET=true  COMPRESSION_LEVEL=0";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "picard tools not happy\n"; }
			$cmd = "$samT index $outdir/$fName{$_}-dedup.bam";
			print "$cmd\n";
			system "$cmd";
			if ($?) { die "samtools not happy\n"; }
			}
		}
	$cmd = "$gatk -T DepthOfCoverage -R $genom -L $outdir/$intervalFile$withChr";
	foreach (@Files) { $cmd .= " -I $outdir/$fName{$_}-dedup.bam"; }
	}
else { 
	$cmd = "$gatk -T DepthOfCoverage -R $genom -L $outdir/$intervalFile$withChr";
	foreach (@Files) { $cmd .= " -I $path{$_}$fName{$_}$extenS"; }
	}
unless ($dedup) { $cmd .= " -drf DuplicateRead"; }
if ($threads) { $cmd .= " -nt $threads"; }
$cmd .= " -mbq ";
if ($mbq) { $cmd .= "$mbq"; }
else { $cmd .= "0"; }
$cmd .= " -mmq ";
if ($mmq) { $cmd .= "$mmq"; }
else { $cmd .= "0"; }
$cmd .= " --countType COUNT_FRAGMENTS -omitLocusTable -omitSampleSummary -omitIntervals -o $outdir/$outName";
print "$cmd\n";
system "$cmd";
if ($?) { die "GATK not happy\n"; }

my%gatkIdx;
open(COV, "$outdir/$outName");
my$firstLine = <COV>;
print $firstLine;
chomp $firstLine;
my@tab = split(/\t/,$firstLine);
foreach my$file(@Files) {
	for (my$i=0;$i<scalar@tab;$i++) {
		if ($tab[$i] eq "Depth_for_$sName{$file}")
			{ $gatkIdx{$file} = $i; last; }
		}
	}
close COV;

#$cmd = "sed -i '1d' $outdir/$bedName-$outName";
my@header_cov = `head -n 1 $outdir/$outName`; 
$cmd = "tail -n +2 $outdir/$outName > $outdir/tmpTail; mv $outdir/tmpTail $outdir/$outName";
print "$cmd\n";
system "$cmd";
return(\%gatkIdx,\@header_cov);
}


####################
#if bedtools covfile and interval not identical (in previous versions)
#scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
#create 2 hash : 
# - %allDepth: depth foreach position in intervals from %allInterval : $allCov{$chr}{$loc} = $cov
# - %notCov: start and end of each not covered domain within %allInterval
sub intersect
{
#if ($gatk) { @hashSub = intersect($gatkIdx{$file},"$outdir/$intervalName-all.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{$chr}{$gene} },$gatk); }
#else { @hashSub = intersect($fName{$file},"$outdir/$file.cov",$maxGr,$chr,\@Thresholds,\%{ $Regions{$chr}{$gene} },$gatk); }
my($file,$covName,$maxD,$chr,$h1,$h2,$gatk,$doNotCov) = @_;
my@Thresholds = @$h1;
my%Intervals = %$h2;

my@Starts = sort{$a<=>$b}(keys%Intervals);
my%allDepth;		#for depth line : $allDepth{$loc} = $cov
my$c=0;			#idx of $startByChr

my$ok=0;
if ($gatk) {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		my@tab2 = split(/:/,$tab[0]);
		if ($tab2[0] eq $chr) {
			while ( ($tab2[1] > $Intervals{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			if ( ($tab2[1] >= $Starts[$c]) && ($tab2[1] <= $Intervals{$Starts[$c]}) ) {
				my$loc = $tab2[1]; #already 1-based coordinate
				my$cov = $tab[$file];
				if ($maxD) { if ($cov > $maxD) { $cov = $maxD; } }
				$allDepth{$loc} = $cov; 
				}
			if ( $tab2[1] > $Intervals{$Starts[-1]} )
				{ $ok = 1; }
			}
		if ($ok) { last; }
		}
	}
else {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		if ($tab[0] eq $chr) {
			while ( (($tab[1]+1) > $Intervals{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			if ( ($tab[2] >= $Starts[$c]) && (($tab[1]+1) <= $Intervals{$Starts[$c]}) ) {
				my$loc = $tab[1]+$tab[-2]; #so now 1-based coordinate
				my$cov = $tab[-1];
				if ($maxD) { if ($cov > $maxD) { $cov = $maxD; } }
				$allDepth{$loc} = $cov; 
				}
			if ( ($tab[1]+1) > $Intervals{$Starts[-1]} )
				{ $ok = 1; }
			}
		if ($ok) { last; }	
		}
	}
close COV;

##if some regions not present in cov file, put depth at 0
#foreach my$start (@Starts) {
#	my$pos = $start;
#	while ($pos <= $Intervals{$start}) {
#		unless (exists $allDepth{$pos})
#			{  $allDepth{$pos} = 0; }
#		$pos++;
#		}
#	}

#cov-domains:
my%notCov;		#for cov-domains: foreach threshold, for regions < threshold: $notCov{$chr}{$start} = $end
my%notCovStarts;	#for cov-domains: foreach threshold, ordered starts of regions < threshold
if ($doNotCov) {
	my$noCovStart=0; my$noCovEnd=0;
	foreach my$threshold (@Thresholds) {
		foreach my$start (@Starts) {
			my$pos=$start;
			while ($pos<=$Intervals{$start}) {
				if ( $allDepth{$pos} < $threshold ) {
					if ( $pos == ($noCovEnd + 1) ) { 
						$notCov{$threshold}{$noCovStart} = $pos ; 
						$noCovEnd = $pos; 
						}
					else { 
						$notCov{$threshold}{$pos} = $pos ; 
						$noCovStart = $pos; 
						$noCovEnd = $pos; 
						}
					}
				$pos++;
				}
			}
		@{ $notCovStarts{$threshold} } = sort{$a<=>$b}keys%{ $notCov{$threshold} };
		}
	return(\%allDepth,\%notCov,\%notCovStarts);
	}
else { return(\%allDepth); }
}


####################
#scan bedtools file, and intersect with %allInterval (coding regions of selected genes) 
#create 2 hash : 
# - %allDepth: depth foreach position in intervals from %allInterval : $allDepth{$loc} = $cov
# - %notCov: start and end of each not covered domain within %allInterval
sub intersect2
{
my($file,$fileName,$outdir,$maxD,$h1) = @_;
my@Thresholds = @$h1;

#all cov values:
my%allDepth;		#for cov-line : $allDepth{$loc} = $cov 

unless ( -s "$outdir/$fileName\_cov" ) { die "$outdir/$fileName\_cov is empty\n"; }
open(COV, "$outdir/$fileName\_cov") || die "can't open file $outdir/$fileName\_cov\n";
while (my$line=<COV>){
	if ($line =~ /^\s*$/) { die "bedtools file $file\_cov_sort.bed empty\n"; }
	chomp $line;
	my@tab = split(/\t/,$line);
	$tab[0] =~ s/chr//;
	$allDepth{($tab[1]+$tab[-2])} = $tab[-1]; #now 1-based coordinate
	if ($maxD) { 
		if ($tab[-1] > $maxD) 
			{ $allDepth{($tab[1]+$tab[-2])} = $maxD; } 
		}
	}
close COV;

#cov-domains:
my%notCov;		#for cov-domains: foreach chr, for regions > threshold: $notCov{$chr}{$start} = $end
my%notCovStarts;	#for cov-domains: foreach chr, ordered starts of regions < threshold
my$noCovStart=-1; my$noCovEnd=-1;
foreach my$threshold (@Thresholds)
	{
	foreach my$pos (sort{$a<=>$b}keys%allDepth)
		{
		if ( $allDepth{$pos} < $threshold )
			{
			if ( $pos == ($noCovEnd + 1) )
				{ 
				$notCov{$threshold}{$noCovStart} = $pos ; 
				$noCovEnd = $pos; 
				}
			else 
				{ 
				$notCov{$threshold}{$pos} = $pos ; 
				$noCovStart = $pos; 
				$noCovEnd = $pos; 
				}
			}
		}
	@{ $notCovStarts{$threshold} } = sort{$a<=>$b}keys%{ $notCov{$threshold} };
	}
return(\%allDepth,\%notCov,\%notCovStarts);
}


#########################
#for cov-line :
#create a hash : foreach file, foreach NM, foreach exon, return an array of values for ordered positions
# %NMcov: key = $file, value = %(key = $NM, value = %( key = $ex, value = @(cov foreach ordered bp of exon) ) )
sub depthLine
{
my($h1,$h2)=@_; 
my%Regions = %$h1;	# $Regions{start of region} = end of region
my%allDepth = %$h2;	#$allDepth{$loc} = $cov

my%depthLine;		#@{ $depthLine{$startReg} } = [$allDepth{$posByChr[$c]}, ]
my@Pos = sort{$a<=>$b}keys%allDepth;
my@startReg = sort{$a<=>$b}keys%Regions;
my$c=0;
for (my$r=0;$r<scalar@startReg;$r++) { 
	while ( ( $startReg[$r] > $Pos[$c] ) && ( $c < (scalar@Pos -1) ) )
		{ $c++; }
	while ( ( $Regions{$startReg[$r]} >= $Pos[$c] ) && ( $c < (scalar@Pos -1) ) ) {
		push( @{ $depthLine{$r} } , $allDepth{$Pos[$c]} );
		$c++;
		}
	}
return(%depthLine);
}	


########################
#for cov-domains:
#intersections not covered regions and exons 
	#starts and ends of not covered regions within exons
sub notCovDomains1
{
#@hashSub = notCovDomains1($All,$fName{$file},$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,$pThreshold,\%{ $Regions{$chr}{$gene} },\%{ $NM_Ex{$NM} },\%notCov,\%notCovStarts,\%NMnotCov);
my($All,$file2,$sName2,$outdir,$outfile,$gene,$chr,$NM,$sens,$h1,$pThreshold,$h2,$h3,$NMstartCod,$NMendCod,$h4,$h5,$h6,$printReports) = @_;
my@Thresholds = @$h1;
my%Regions = %$h2;	# $Regions{start of region} = end of region
my%NM_Ex = %$h3;	# $NM_Ex{start of region}{start of exon} = end of exon
my%notCov = %$h4; 	# $notCov{$threshold}{$start} = $end
my%notCovStarts = %$h5;
my%NMnotCov = %$h6;

my(%NMcovStart, %NMcovEnd);
#$NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
#@{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]

my$nExon=0;	#total nber of $Exons
foreach my$startR (keys%NM_Ex)
	{ $nExon+=scalar(keys%{ $NM_Ex{$startR} }); }
my@startReg = sort{$a<=>$b}keys%Regions;

#my$txt1 = "\nsample: $sName2\ngene: $gene\ntranscript: $NM\ncoding sequence: chr $chr : $NMstartCod - $NMendCod\n";
my$txt1 = "\ngene: $gene\ntranscript: $NM\ncoding sequence: chr $chr : $NMstartCod - $NMendCod\n";
my%txt;
my($geneL,%geneUC,%NM_UC);
foreach my$threshold (@Thresholds) {

	#$txt{$threshold} .= "\ndepth threshold = $threshold\n\n";
	my$nEx=0;	#idx of $Exons (for printing)
	my$posix=0;	#idx of $notCovStarts
	$geneUC{$threshold}=0; $geneL=0;
	for (my$r=0;$r<scalar@startReg;$r++)
		{
		my$startEx = $startReg[$r]; 
		my$endEx = $Regions{$startReg[$r]};
		$geneL += $Regions{$startReg[$r]}-$startReg[$r];

		unless ( scalar@{ $notCovStarts{$threshold} } == 0 )
			{
			while ( ( $startEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]} ) && ( $posix < (scalar@{ $notCovStarts{$threshold} }-1) ) )
				{ $posix++; }
	
			while ( ( $endEx >= $notCovStarts{$threshold}[$posix] ) && ( $posix < (scalar@{ $notCovStarts{$threshold} }-1) ) )
				{
				if ($startEx >= $notCovStarts{$threshold}[$posix]) 
					{
					if ($endEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					else	#$endEx <= $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < $notCovStarts{$chr}[$posix]
					{
					if ($endEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $endEx; }
					else	#$end > $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					}
				$posix++;
				}
			#for last [posix]:
			if ( ($startEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}) && ($endEx >= $notCovStarts{$threshold}[$posix]) )
				{
				if ($startEx >= $notCovStarts{$threshold}[$posix]) 
					{
					if ($endEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					else	#$endEx <= $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < $notCovStarts{$chr}[$posix]
					{
					if ($endEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $endEx; }
					else	#$end > $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					}
				}
			}
		if ($pThreshold) {
			if ($sens eq "+") {
				foreach my$ex (sort{$a<=>$b}keys%{ $NM_Ex{$startReg[$r]} }) {
					$nEx++;
					if (exists $NMcovEnd{$threshold}{$r})
						{ $txt{$threshold} .= "exon $nEx : ".$ex." - ".$NM_Ex{$startReg[$r]}{$ex}."\n"; } 
					}
				}
			else {
				foreach my$ex (sort{$a<=>$b}keys%{ $NM_Ex{$startReg[$r]} }) {
					if (exists $NMcovEnd{$threshold}{$r}) 
						{ $txt{$threshold} .= "exon ".($nExon-$nEx)." : ".$ex." - ".$NM_Ex{$startReg[$r]}{$ex}."\n"; }
					$nEx++; 
					}
				}
			if ((exists $NMcovEnd{$threshold}{$r}) && (scalar(keys%{ $NM_Ex{$startReg[$r]} })!=0)) {
				$NMnotCov{$NM}{$file2}{$threshold} = 1;
				$txt{$threshold} .= "\tnot covered from :\n";
				foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} })) { 
					push(@{ $NMcovStart{$threshold}{$r} }, $pos);
					$txt{$threshold} .= "\t$pos\tto\t".$NMcovEnd{$threshold}{$r}{$pos}."\n";
					$geneUC{$threshold} += $NMcovEnd{$threshold}{$r}{$pos} - $pos;
					}
				}
			}
		else {
			if ($sens eq "+") {
				foreach my$ex ( sort{$a<=>$b}keys%{ $NM_Ex{$startReg[$r]} } ) {
					$nEx++;
					$txt{$threshold} .= "exon $nEx : ".$ex." - ".$NM_Ex{$startReg[$r]}{$ex}."\n"; 
					}
				}
			else {
				foreach my$ex ( sort{$a<=>$b}keys%{ $NM_Ex{$startReg[$r]} } ) { 
					$txt{$threshold} .= "exon ".($nExon-$nEx)." : ".$ex." - ".$NM_Ex{$startReg[$r]}{$ex}."\n"; 
					$nEx++; 
					}
				}
			if ((exists $NMcovEnd{$threshold}{$r}) && (scalar(keys%{ $NM_Ex{$startReg[$r]} })!=0)) {
				$txt{$threshold} .= "\tnot covered from :\n";
				foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} })) { 
					push(@{ $NMcovStart{$threshold}{$r} }, $pos);
					$txt{$threshold} .= "\t$pos\tto\t".$NMcovEnd{$threshold}{$r}{$pos}."\n";
					$geneUC{$threshold} += $NMcovEnd{$threshold}{$r}{$pos} - $pos;
					}
				}
			}
		}
	$NM_UC{$threshold} = ($geneUC{$threshold}/$geneL)*100;
	print "$gene\_$NM\t".sprintf("%.1f",$NM_UC{$threshold})."\n";
	}
if($printReports) {
	if ($pThreshold) {
		if (exists $NMnotCov{$NM}{$file2}{$pThreshold}) {
			#open(OUT, ">$outdir/cov\_$sName2/$outfile$sName2\_$gene\_$NM.txt") || die "can't create file $outdir/$outfile$file2\_$NM.txt\n";
			open(OUT, ">>", "$outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt\n";
			print OUT $txt1;
			#foreach my$threshold (@Thresholds) {
			#	print OUT "\ndepth threshold = $threshold\n\n";
			#	print OUT "not covered over ".sprintf("%.1f",$NM_UC{$threshold})."% of exons\n\n";
			#	if (exists $txt{$threshold}) { print OUT $txt{$threshold}; }
			#	}
			print OUT "not covered over ".sprintf("%.1f",$NM_UC{$pThreshold})."% of exons\n\n";
			if (exists $txt{$pThreshold}) { print OUT $txt{$pThreshold}; }
			close OUT;
			}
		}
	else {
		#open(OUT, ">$outdir/cov\_$sName2/$outfile$sName2\_$gene\_$NM.txt") || die "can't create file $outdir/$outfile$file2\_$NM.txt\n";
		open(OUT, ">>", "$outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt") || die "can't create file $outdir/cov\_$sName2/$outfile$sName2\_geneReport.txt\n";
		print OUT $txt1;
		foreach my$threshold (@Thresholds) {
			print OUT "\ndepth threshold = $threshold\n\n";
			print OUT "not covered over ".sprintf("%.1f",$NM_UC{$threshold})."% of exons:\n\n";
			print OUT $txt{$threshold};
			}
		 close OUT;
		}
	}

return(\%NMnotCov,\%NMcovStart,\%NMcovEnd,\%NM_UC);
}


########################
#for cov-domains:
#intersections not covered regions and exons 
	#starts and ends of not covered regions within exons
sub notCovDomains2
{
#@hashSub = notCovDomains1($file2,$outdir,$outfile,$gene,$chr,$NM,$NMsens{$NM},\@Thresholds,\%{ $Regions{}$chr}{$gene} },\%{ $NM_Ex{$NM} },\%notCov,\%notCovStarts);
my($h1,$h2,$h3,$h4) = @_;
my@Thresholds = @$h1;
my%Regions = %$h2;	# $Regions{start of region} = end of region
my%notCov = %$h3; 	# $notCov{$threshold}{$start} = $end
my%notCovStarts = %$h4;

my(%NMcovStart, %NMcovEnd);
#$NMcovEnd{$NM}{$threshold}{$ex}{$notCovStart} = $notCovEnd;
#@{ $NMcovStart{$NM}{$threshold}{$ex} } = [ordered $notCovStarts]

my@startReg = sort{$a<=>$b}keys%Regions;
foreach my$threshold (@Thresholds)
	{
	my$posix=0;	#idx of $notCovStarts
	for (my$r=0;$r<scalar@startReg;$r++)
		{
		my$startEx = $startReg[$r]; 
		my$endEx = $Regions{$startReg[$r]}; 

		unless ( scalar@{ $notCovStarts{$threshold} } == 0 )
			{
			while ( ( $startEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]} ) && ( $posix < (scalar@{ $notCovStarts{$threshold} }-1) ) )
				{ $posix++; }
	
			while ( ( $endEx >= $notCovStarts{$threshold}[$posix] ) && ( $posix < (scalar@{ $notCovStarts{$threshold} }-1) ) )
				{
				if ($startEx >= $notCovStarts{$threshold}[$posix]) 
					{
					if ($endEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					else	#$endEx <= $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < $notCovStarts{$chr}[$posix]
					{
					if ($endEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $endEx; }
					else	#$end > $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					}
				$posix++;
				}
			#for last [posix]:
			if ( ($startEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}) && ($endEx >= $notCovStarts{$threshold}[$posix]) )
				{
				if ($startEx >= $notCovStarts{$threshold}[$posix]) 
					{
					if ($endEx > $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					else	#$endEx <= $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$startEx} = $endEx; }
					}
				else	#$startEx < $notCovStarts{$chr}[$posix]
					{
					if ($endEx <= $notCov{$threshold}{$notCovStarts{$threshold}[$posix]})
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $endEx; }
					else	#$end > $notCov{$chr}{$notCovStarts{$chr}[$posix]}
						{ $NMcovEnd{$threshold}{$r}{$notCovStarts{$threshold}[$posix]} = $notCov{$threshold}{$notCovStarts{$threshold}[$posix]}; }
					}
				}
			}
		if (exists $NMcovEnd{$threshold}{$r})
			{
			foreach my$pos (sort{$a<=>$b}(keys%{ $NMcovEnd{$threshold}{$r} }))
				{ push(@{ $NMcovStart{$threshold}{$r} }, $pos); }
			}
		}
	}
close OUT;
return(\%NMcovStart, \%NMcovEnd);
}


#########################
#transposition and splicing, for %NMcovStart and %NMcovEnd
#for $gene and $NM
sub transposeCov
{
my($h1,$h2,$h3,$h4,$h5) = @_;
my@Thresholds = @$h1;
my%Regions = %$h2;	# $Regions{start of region} = end of region
my%Reg_00 = %$h3;	# $Reg_00{start of region} = end of region (start of region =0)
my%NMcovStart = %$h4;
my%NMcovEnd = %$h5;

my(%covStart01,%covEnd01);


my@startReg = sort{$a<=>$b}keys%Regions;
my@start00 = sort{$a<=>$b}keys%Reg_00;
foreach my$threshold (@Thresholds)
	{
	my$sub = $startReg[0];
	for (my$i=0;$i<scalar(keys%{ $NMcovEnd{$threshold}{0} });$i++)
		{ $covEnd01{$threshold}{0}{($NMcovStart{$threshold}{0}[$i]-$sub)} = $NMcovEnd{$threshold}{0}{$NMcovStart{$threshold}{0}[$i]}-$sub+1; }

	for (my$ex=1;$ex<scalar@startReg;$ex++)
		{
		$sub = $startReg[$ex] - $start00[$ex];
		for (my$i=0;$i<scalar(keys%{ $NMcovEnd{$threshold}{$ex} });$i++)
			{ $covEnd01{$threshold}{$ex}{($NMcovStart{$threshold}{$ex}[$i]-$sub)} = $NMcovEnd{$threshold}{$ex}{$NMcovStart{$threshold}{$ex}[$i]}-$sub+1; }
		}

	for (my$ex=0;$ex<scalar@startReg;$ex++)
		{
		foreach my$pos ( sort{$a<=>$b}(keys%{ $covEnd01{$threshold}{$ex} }) )
			{  push(@{ $covStart01{$threshold}{$ex} }, $pos); }
		}
	}

return(\%covStart01,\%covEnd01);
}


#########################
#
sub covByThreshold
{
my($threshold,$h1,$h2,$h3)=@_;
my%Regions = %$h1;	# $Regions{start of region} = end of region
my%Depth = %$h2;	#$allDepth{$loc} = $cov
my%Cov = %$h3;		#@{ $Cov{$reg} } = [nbe of covered samples foreach pos of reg], for defined threshold
#print"for threshold $threshold, add covered positions\n";
my@Pos = sort{$a<=>$b}keys%Depth;
my@startReg = sort{$a<=>$b}keys%Regions;
my$d=0;	#index of @posByChr=keys%{ $Depth{$chr} }
for (my$r=0;$r<scalar@startReg;$r++)
	{
	my$c=0;	#index of @{ $NMCov{$threshold}{$NM}{$r} }
	while ( ( $startReg[$r] > $Pos[$d] ) && ( $d < (scalar@Pos -1) ) )
		{ $d++; }
	while ( ( $Regions{$startReg[$r]} >= $Pos[$d] ) && ( $d < (scalar@Pos -1) ) )
		{
		if(($Depth{$Pos[$d]}ne"") && ($Depth{$Pos[$d]}>=$threshold))
			{ $Cov{$r}[$c]++; }
		$d++; $c++;
		}
	}
return(%Cov);
}


############################
#foreach NM, find max cov, among all samples
sub maxCov
{
my($h1,$h2,$h3) = @_;
my@Files=@$h1;
my%NMdepth=%$h2;		#@{ $NMdepth{$file}{$startReg} } = [ cov foreach ordered bp of exon ]
my%Reg_00 = %$h3;		#$Reg_00{start of region} = $end of region (for start of region = 0)

my$maxCovA = 0;		#for all samples
my(%maxCovS);		#for each sample
foreach my$file (@Files) {
	my$maxD=0;
	for (my$ex=0;$ex<scalar(keys%Reg_00);$ex++) {
		foreach my$cov (@{ $NMdepth{$file}{$ex} }) {
			if ($cov > $maxD) { $maxD = $cov; }
			if ($cov > $maxCovA) { $maxCovA = $cov; }
			}
		}
	$maxCovS{$file} = $maxD;
	}
return($maxCovA,\%maxCovS);
}


##########################
sub ReverseCov_Gene
{
#@hashSub = ReverseCov_Gene($Sum,$allS,$byS,$gene,$NMlength{$gene},\@Thresholds,\%{ $NMdepth{$gene} },\%{ $covEnd01{$gene} },\%{ $covStart01{$gene} },\%{ $NMCov{$gene} });
my($Sum,$allS,$byS,$gene,$length,$h1,$h2,$h3,$h4,$h5)=@_;
my@Thresholds = @$h1;
my%NMdepth = %$h2;
my%covEnd01 = %$h3;
my%covStart01 = %$h4;
my%NMCov = %$h5;

print "reverse cov for $gene\n";

if ($allS || $byS) {		
	#@{ $NMcov{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	foreach my$file (keys%NMdepth) {
		my$nEx=scalar(keys%{ $NMdepth{$file} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ $NMdepth{$file} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ $NMdepth{$file}{$ex} }; }
		%{ $NMdepth{$file} } = %tmp;
		}
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	foreach my$file (keys%covEnd01) {
		foreach my$threshold (keys%{ $covEnd01{$file} }) {
			my%tmp;
			my$nEx=scalar(keys%{ $covEnd01{$file}{$threshold} })-1;
			foreach my$ex (keys%{ $covEnd01{$file}{$threshold} })
				{ %{ $tmp{($nEx-$ex)} } = reverseEx($length,\%{ $covEnd01{$file}{$threshold}{$ex} }); }
			%{ $covEnd01{$file}{$threshold} } = %tmp;
			foreach my$ex (keys%{ $covEnd01{$file}{$threshold} })
				{ @{ $covStart01{$file}{$threshold}{$ex} } = sort{$a<=>$b}keys%{ $covEnd01{$file}{$threshold}{$ex} }; }
			}
		}
	}

if ($Sum) {
	#@{ $NMCov{$threshold}{$NM}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
	foreach my$threshold (@Thresholds) {
		my$nEx=scalar(keys%{ $NMCov{$threshold} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ $NMCov{$threshold} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ $NMCov{$threshold}{$ex} }; }
		%{ $NMCov{$threshold} } = %tmp;
		}
	}

return(\%NMdepth,\%covEnd01,\%covStart01,\%NMCov);
}

##########################
sub ReverseCov_NMs
{
#@hashSub = ReverseCov_NMs($Sum,$allS,$byS,$NM,$NMlength{$NM},\@Thresholds,\%{ $NMdepth{$NM} },\%{ $covEnd01{$NM} },\%{ $covStart01{$NM} },\%{ $NMCov{$NM} });
my($Sum,$allS,$byS,$NM,$length,$h1,$h2,$h3,$h4,$h5)=@_;
my@Thresholds = @$h1;
my%NMdepth = %$h2;
my%covEnd01 = %$h3;
my%covStart01 = %$h4;
my%NMCov = %$h5;

print "reverse cov for $NM\n";

if ($allS || $byS) {		
	#@{ $NMcov{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	foreach my$file (keys%NMdepth) {
		my$nEx=scalar(keys%{ $NMdepth{$file} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ $NMdepth{$file} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ $NMdepth{$file}{$ex} }; }
		%{ $NMdepth{$file} } = %tmp;
		}
	#$covEnd01{$file}{$NM}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$NM}{$threshold}{$ex} } = [ordered $notCovStarts00]
	foreach my$file (keys%covEnd01) {
		foreach my$threshold (keys%{ $covEnd01{$file} }) {
			my%tmp;
			my$nEx=scalar(keys%{ $covEnd01{$file}{$threshold} })-1;
			foreach my$ex (keys%{ $covEnd01{$file}{$threshold} })
				{ %{ $tmp{($nEx-$ex)} } = reverseEx($length,\%{ $covEnd01{$file}{$threshold}{$ex} }); }
			%{ $covEnd01{$file}{$threshold} } = %tmp;
			foreach my$ex (keys%{ $covEnd01{$file}{$threshold} })
				{ @{ $covStart01{$file}{$threshold}{$ex} } = sort{$a<=>$b}keys%{ $covEnd01{$file}{$threshold}{$ex} }; }
			}
		}
	}

if ($Sum) {
	#@{ $NMCov{$threshold}{$NM}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
	foreach my$threshold (@Thresholds) {
		my$nEx=scalar(keys%{ $NMCov{$threshold} })-1;
		my%tmp;
		foreach my$ex (sort{$a<=>$b}(keys%{ $NMCov{$threshold} }))
			{ @{ $tmp{($nEx-$ex)} } = reverse@{ $NMCov{$threshold}{$ex} }; }
		%{ $NMCov{$threshold} } = %tmp;
		}
	}

return(\%NMdepth,\%covEnd01,\%covStart01,\%NMCov);
}

##########################
sub reverseEx
{
my($NMlength,$h1) = @_;
my%data=%$h1;
my(%dataR);
foreach (keys%data)
	{ $dataR{($NMlength-$data{$_})} = $NMlength-$_; }
return(%dataR);
}


#################################
#merge overlapping intervals 
#%interval2 = merge(\%interval);
sub merge
{
my($h1) = @_;
my%interval = %$h1;
my@Starts = sort{$a<=>$b}(keys%interval);
my$start = $Starts[0];
my$end = $interval{$start};
my%interval2;
for (my$i=1;$i<scalar(@Starts);$i++) {
	if ($Starts[$i] <= $end) {
		if ($interval{$Starts[$i]} > $end)
			{ $end = $interval{$Starts[$i]}; }
		else { next; }
		}
	else {
		$interval2{$start} = $end;
		$start = $Starts[$i];
		$end = $interval{$start};
		}
	}
$interval2{$start} = $end;
return(%interval2);
}


#####################
sub covDomains
{
#@hashSub= covDomains(\@Thresholds,\%{ $Reg_00{$NM} },\%{ $NMCov{$NM} });
#$NMCovEnd{$NM}{$threshold}{$ex}{$start}=$end
#$NMCovVal{$NM}{$threshold}{$ex}{$start}=$value
my($h1,$h2,$h3) = @_;
my@Thresholds=@$h1;
my%Reg_00=%$h2;		#$Reg_00{start of region} = $end of region (for start of region = 0)
my%NMCov=%$h3;		#@{ $NMCov{$threshold}{$nReg} } = [nber of covered samples foreach pos of Regions{$NM}{$startReg}]
#$NMCovEnd{$threshold}{$ex}{$start}=$end
#$NMCovVal{$threshold}{$ex}{$start}=$value
my(%NMCovEnd,%NMCovVal);
my@startR = sort{$a<=>$b}keys%Reg_00;
foreach my$threshold (@Thresholds)
	{
	foreach my$r (sort{$a<=>$b}(keys%{ $NMCov{$threshold} }))
		{
		my$start=$startR[$r];
		my$end=$start+1; 
		my$cov=$NMCov{$threshold}{$r}[0];
		for (my$i=1;$i<scalar@{ $NMCov{$threshold}{$r} };$i++)
			{
			if ($NMCov{$threshold}{$r}[$i] == $cov)
				{ $end++; }
			else
				{
				$NMCovEnd{$threshold}{$r}{$start}=$end;
				$NMCovVal{$threshold}{$r}{$start}=$cov;
				$start=$startR[$r]+$i;
				$end=$start+1;
				$cov=$NMCov{$threshold}{$r}[$i];
				}
			$NMCovEnd{$threshold}{$r}{$start}=$end;
			$NMCovVal{$threshold}{$r}{$start}=$cov;
			}
		}
	}
return(\%NMCovEnd,\%NMCovVal);
}


########################
#for $All $NM on same graph
sub graphAllSampleG
{
#graphAllSampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$gene},$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"rev"}{$gene} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $NMdepth{$gene} },\%{ $covStart01{$gene} },\%{ $covEnd01{$gene} },\%{ $RegMut{"rev"}{$gene} },\%fName,\%sName2);
my($nGraf,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$NMlength,$h0,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12,$h13,$h14,$h15,$h16)= @_;
my@NMs=@$h0;
my@Files=@$h1;
my@colors=@$h2;
my@Thresholds=@$h3;
my%Regions=%$h4;		
my%Reg_00=%$h5;
my%NM_Ex00=%$h6;
my%NMbed00=%$h7;
my%intron=%$h8;
my%UTR=%$h9;
my%Cod=%$h10;
my%NMdepth=%$h11;
my%covStart01=%$h12;
my%covEnd01=%$h13;
my%NMmut00=%$h14;
my%fileName=%$h15;
my%sampleName=%$h16;

print "print CMDR graphAllSampleG: $gene\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

if ($nGraf eq "max") { $nGraf = scalar@Files; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$file (@Files) {

	my($Y,$Y1,$Y2);

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
	$Y1=(0.5+0.25*scalar@NMs);$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%Reg_00,\%{ $NMdepth{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$line2="";
	for(my$i=0;$i<scalar@NMs;$i++) { 
		$Y=(0.425+0.25*$i);
		$line2 .= line2($maxY,$Y,\%{ $intron{$NMs[$i]} });
		}

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);
	my$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,\@Thresholds,\@colors,\%Reg_00,\%{ $covStart01{$file} },\%{ $covEnd01{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	my$line4a="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		if (scalar(keys%{ $UTR{$NMs[$i]} })!=0) {
			$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
			$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR{$NMs[$i]} });
			}
		}

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	my$line4b="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		if (scalar(keys%{ $Cod{$NMs[$i]} })) {
			$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
			$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod{$NMs[$i]} });
			}
		}
	
	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	my$line4c="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		$Y=(0.3+0.25*$i);
		$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NMs[$i]} });
		}
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,\@colors,\@Thresholds);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%NMmut00) != 0) {
		$Y1=0.05;$Y2=(0.3+0.25*scalar@NMs);
		$line6a = line6a($maxY,$Y1,$Y2,\%NMmut00);
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=(0.3+0.25*scalar@NMs);
		$line6b = line6b($maxY,$Y,\%NMmut00);
		}

	#$line7: NM names
	my$line7 = line7($NMlength,$maxY,\@NMs);

	#print CMDR:
	$cmdR .= 
"plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*scalar@NMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : $sampleName{$file}\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2)\n";

	$cmdR .= $line1a.$line1b;

	$cmdR .= 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
	my$col=0;
	foreach my$threshold (@Thresholds) {
		$cmdR .= 
"abline(h=$threshold, col=\"".$colors[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

	$cmdR .= $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@Thresholds) {
		if ($line3{$threshold}) 
			{ $cmdR .= $line3{$threshold}; }
		}
	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($i==(scalar@Files) || $n==$nGraf) {
		open (CMDR, ">$outdir/$gene\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==scalar@Files) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_bySample.png\", 1500, ".($nGraf*(400*(0.875+(0.125*scalar@NMs)))).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_bySample_$N.png\", 1500, ".($nGraf*(400*(0.875+(0.125*scalar@NMs)))).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_bySample_$N.png\", 1500, ".($n*(400*(0.875+(0.125*scalar@NMs)))).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		if ($sens eq "+") { print CMDR
"mtext(\"$gene\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		else { print CMDR 
"mtext(\"$gene\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$gene\_temp.R";
		unlink "$outdir/$gene\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}

}

########################
#graph foreach $NM 
sub graphAllSampleN
{
#graphAllSampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$maxCovA{$NM},$NMlength{$NM},$NMstartCod{$NM},$NMendCod{$NM},\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $Regions{"rev"}{$NM} },\%{ $NM_Ex{"rev"}{$NM} },\%{ $RegBed{"rev"}{$NM} },\%{ $intron{"rev"}{$NM} },\%{ $UTR{"rev"}{$NM} },\%{ $Cod{"rev"}{$NM} },\%{ $NMdepth{$NM} },\%{ $covStart01{$NM} },\%{ $covEnd01{$NM} },\%{ $RegMut{"rev"}{$NM} },\%fName,\%sName2);
my($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$NMlength,$NMstartCod,$NMendCod,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12,$h13,$h14,$h15,$h16)= @_;
my@Files=@$h1;
my@colors=@$h2;
my@Thresholds=@$h3;
my%Regions=%$h4;
my%Reg_00=%$h5;
my%NM_Ex00=%$h6;
my%NMbed00=%$h7;
my%intron=%$h8;
my%UTR=%$h9;
my%Cod=%$h10;
my%NMdepth=%$h11;
my%covStart01=%$h12;
my%covEnd01=%$h13;
my%NMmut00=%$h14;
my%fileName=%$h15;
my%sampleName=%$h16;

print "print CMDR graphAllSampleN: $gene\t$NM\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

if ($nGraf eq "max") { $nGraf = scalar@Files; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$file (@Files) {

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	my$Y1=0.75;my$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%Reg_00,\%{ $NMdepth{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$Y=0.425;
	my$line2 = line2($maxY,$Y,\%intron);

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);	#empty black squares
	my$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);	#full green squares

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,\@Thresholds,\@colors,\%Reg_00,\%{ $covStart01{$file} },\%{ $covEnd01{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%UTR)!=0) { $line4a .= line4a($maxY,$Y1,$Y2,\%UTR); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%Cod)!=0) { $line4b .= line4b($maxY,$Y1,$Y2,\%Cod); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%NM_Ex00);
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,\@colors,\@Thresholds);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%NMmut00) != 0)
		{
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%NMmut00);
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.55;
		$line6b = line6b($maxY,$Y,\%NMmut00);
		}

	#print CMDR:
	$cmdR .= 
"plot (c(0,0), xlim=c(0,".$NMlength."), ylim=c(-".(0.75*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : $sampleName{$file}\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5),labels=seq(0, $maxY, length = 5), las=2)\n";

	$cmdR .= $line1a.$line1b;

	$cmdR .= 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
	my$col=0;
	foreach my$threshold (@Thresholds) {
		$cmdR .= 
"abline(h=$threshold, col=\"".$colors[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	$cmdR .= $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@Thresholds) {
		if ($line3{$threshold}) 
			{ $cmdR .= $line3{$threshold}; }
		}
	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	

	if ($i==(scalar@Files) || $n==$nGraf) {
		open (CMDR, ">$outdir/$NM\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==scalar@Files) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample_$N.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_".$NM."_bySample_$N.png\", 1500, ".($n*400).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		if ($sens eq "+") { print CMDR 
"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		else { print CMDR 
"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$NM\_temp.R";
		unlink "$outdir/$NM\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}

}


########################
#for $All $NM on same graph
sub graphBySampleG
{
#graphBySampleG($nGraf,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMlength{$gene},\%{ $maxCovS{$gene} },\@NMs,\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$gene} },\%{ $Regions{"rev"}{$gene} },\%{ $NM_Ex{"rev"} },\%{ $RegBed{"rev"}{$gene} },\%{ $intron{"rev"} },\%{ $UTR{"rev"} },\%{ $Cod{"rev"} },\%{ $NMdepth{$gene} },\%{ $covStart01{$gene} },\%{ $covEnd01{$gene} },\%{ $RegMut{"rev"}{$gene} },\%fName,\%sName2); }
my($nGraf,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$NMlength,$h0,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12,$h13,$h14,$h15,$h16,$h17)= @_;
my%maxCov=%$h0;
my@NMs=@$h1;
my@Files=@$h2;
my@colors=@$h3;
my@Thresholds=@$h4;
my%Regions=%$h5;
my%Reg_00=%$h6;
my%NM_Ex00=%$h7;
my%NMbed00=%$h8;
my%intron=%$h9;
my%UTR=%$h10;
my%Cod=%$h11;
my%NMdepth=%$h12;
my%covStart01=%$h13;
my%covEnd01=%$h14;
my%NMmut00=%$h15;
my%fileName=%$h16;
my%sampleName=%$h17;

my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

foreach my$file (@Files)
	{

	print "print CMDR graphBySampleG: $gene\n";
	open (CMDR, ">$outdir/$gene\_temp.R") || die;
	print CMDR "#!/usr/bin/env Rscript\n\n" ;
	print CMDR 
	"png(\"$outdir/cov\_$sampleName{$file}/$gene\_$sampleName{$file}.png\", 1500, ".(400*(0.875+(0.125*scalar@NMs))).")\n"; 

	my$maxY = $maxCov{$file};
	unless ($maxD) {
		if ($maxY<10) { $maxY = 10; }
		}

	my($Y,$Y1,$Y2);
	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
	$Y1=(0.5+0.25*scalar@NMs);$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%Reg_00,\%{ $NMdepth{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
	my$line2="";
	for(my$i=0;$i<scalar@NMs;$i++) { 
		$Y=(0.425+0.25*$i);
		$line2 .= line2($maxY,$Y,\%{ $intron{$NMs[$i]} });
		}

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);
	my$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,\@Thresholds,\@colors,\%Reg_00,\%{ $covStart01{$file} },\%{ $covEnd01{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	my$line4a="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		if (scalar(keys%{ $UTR{$NMs[$i]} })!=0) {
			$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
			$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR{$NMs[$i]} });
			}
		}

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	my$line4b="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		if (scalar(keys%{ $Cod{$NMs[$i]} })!=0) {
			$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
			$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod{$NMs[$i]} });
			}
		}
	
	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	my$line4c="";
	for(my$i=0;$i<scalar@NMs;$i++) {
		$Y=(0.3+0.25*$i);
		$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NMs[$i]} });
		}
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,\@colors,\@Thresholds);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%NMmut00) != 0) {
		$Y1=0.05;$Y2=(0.3+0.25*scalar@NMs);
		$line6a = line6a($maxY,$Y1,$Y2,\%NMmut00);
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=(0.3+0.25*scalar@NMs);
		$line6b = line6b($maxY,$Y,\%NMmut00);
		}

	#$line7: NM names
	my$line7 = line7($NMlength,$maxY,\@NMs);

	#print CMDR:
	print CMDR 
"plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*scalar@NMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : $sampleName{$file}\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5),labels=seq(0, $maxY, length = 5), las=2)\n";

	print CMDR $line1a.$line1b;

	print CMDR 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
	my$col=0;
	foreach my$threshold (@Thresholds) {
		print CMDR 
"abline(h=$threshold, col=\"".$colors[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

	print CMDR $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@Thresholds) {
		if ($line3{$threshold}) 
			{ print CMDR $line3{$threshold}; }
		}
	print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($sens eq "+") {
		print CMDR 
		"mtext(\"$gene\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	else {
		print CMDR 
		"mtext(\"$gene\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	print CMDR "dev.off();\n";
	close CMDR;
	system "Rscript $outdir/$gene\_temp.R";
	unlink "$outdir/$gene\_temp.R";
	}
}


########################
#graph foreach $NM 
sub graphBySampleN
{
#graphBySampleN($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxGr,$Rev,$chr,$NMstartCod{$NM},$NMendCod{$NM},$NMlength{$NM},\%{ $maxCovS{$NM} },\@Files,\@colors,\@Thresholds,\%{ $Regions{"raw"}{$chr}{$NM} },\%{ $Regions{"rev"}{$NM} },\%{ $NM_Ex{"rev"}{$NM} },\%{ $RegBed{"rev"}{$NM} },\%{ $intron{"rev"}{$NM} },\%{ $UTR{"rev"}{$NM} },\%{ $Cod{"rev"}{$NM} },\%{ $NMdepth{$NM} },\%{ $covStart01{$NM} },\%{ $covEnd01{$NM} },\%{ $RegMut{"rev"}{$NM} },\%fName,\%sName2);
my($nGraf,$NM,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$NMstartCod,$NMendCod,$NMlength,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12,$h13,$h14,$h15,$h16,$h17)= @_;
my%maxCov=%$h1;
my@Files=@$h2;
my@colors=@$h3;
my@Thresholds=@$h4;
my%Regions=%$h5;
my%Reg_00=%$h6;
my%NM_Ex00=%$h7;
my%NMbed00=%$h8;
my%intron=%$h9;
my%UTR=%$h10;
my%Cod=%$h11;
my%NMdepth=%$h12;
my%covStart01=%$h13;
my%covEnd01=%$h14;
my%NMmut00=%$h15;
my%fileName=%$h16;
my%sampleName=%$h17;

my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

foreach my$file (@Files)
	{

	print "print CMDR graphBySampleN: $gene\t$NM\n";
	open (CMDR, ">$outdir/$NM\_temp.R") || die;
	print CMDR "#!/usr/bin/env Rscript\n\n" ;
	print CMDR 
	"png(\"$outdir/cov\_$sampleName{$file}/$gene\_$NM\_$sampleName{$file}.png\", 1500, 400)\n"; 

	my$maxY = $maxCov{$file};
	unless ($maxD) {
		if ($maxY<10) { $maxY = 10; }
		}

	#$line1: cmdR for plot cov line
	#@{ $NMdepth{$file}{$NM}{$ex} } = [ cov foreach ordered bp of exon ]
	my$Y1=0.75;my$Y2=1.25;
	my($line1a,$line1b) = line1($maxY,$NMlength,$Y1,$Y2,\%Reg_00,\%{ $NMdepth{$file} });
	
	#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
	my$Y=0.425;
	my$line2 = line2($maxY,$Y,\%intron);

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);	#empty black squares
	my$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);	#full green squares

	#$line3: cmdR for rect(not covered domains)
	#$covEnd01{$file}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
	#@{ $covStart01{$file}{$threshold}{$ex} } = [ordered $notCovStarts00]
	$Y1=0.1;$Y2=0.25;
	my%line3 = line3($maxY,$Y1,$Y2,\@Thresholds,\@colors,\%Reg_00,\%{ $covStart01{$file} },\%{ $covEnd01{$file} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%UTR)!=0) { $line4a .= line4a($maxY,$Y1,$Y2,\%UTR); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%Cod)!=0) { $line4b .= line4b($maxY,$Y1,$Y2,\%Cod); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%NM_Ex00);
	
	#$line5: cmdR for legends
	my$comp = "<";
	my$line5 = line5a($comp,\@colors,\@Thresholds);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%NMmut00) != 0) {
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%NMmut00);
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.55;
		$line6b = line6b($maxY,$Y,\%NMmut00);
		}

	#print CMDR:
	print CMDR 
"plot (c(0,0), xlim=c(0,".$NMlength."), ylim=c(-".(0.75*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : $sampleName{$file}\", ylab = \"depth\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2)\n";

	print CMDR $line1a.$line1b;


	print CMDR 
"abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n"; 
	my$col=0;
	foreach my$threshold (@Thresholds) {
		print CMDR 
"abline(h=$threshold, col=\"".$colors[$col]."\", lty = \"dotted\", lwd=2)\n"; 
		$col++;
		}

	print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	print CMDR $line3b." lwd=1, col=\"green\", border =\"green\")\n";
	foreach my$threshold (@Thresholds) {
		if ($line3{$threshold}) 
			{ print CMDR $line3{$threshold}; }
		}
	print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";
	
	if ($sens eq "+") {
		print CMDR 
	"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	else {
		print CMDR 
	"mtext(\"$gene\t$NM\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		}
	print CMDR "dev.off();\n";
	close CMDR;
	system "Rscript $outdir/$NM\_temp.R";
	unlink "$outdir/$NM\_temp.R";
	}
}


############################
#$line1: cmdR for plot cov line
#@{ $NMdepth{$NM}{$file}{$ex} } = [ cov foreach ordered bp of exon ]
sub line1
{
my($maxY,$NMlength,$Y1,$Y2,$h1,$h2) = @_;
my%Reg_00=%$h1;
my%NMdepth=%$h2;
my@startR = sort{$a<=>$b}keys%Reg_00;
my$line1a="";my$line1b="";
my$p=0;my$i=0;
for (my$n=0;$n<scalar@startR;$n++)
	{
	$line1a .= "par(new=TRUE)\nplot( c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ $NMdepth{$n} })
		{ $line1a .= $p.","; $p++; $i++; }
	chop $line1a;
	$line1a .= "), c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ $NMdepth{$n} }) {
		if ($NMdepth{$n}[$i] eq "") 
			{ 
			$line1a .= "0,";
			$line1b .= "lines (c($p,".($p+1)."), c(0,0), lwd=2, col=\"grey\")\n"; 
			}
		else { $line1a .= $NMdepth{$n}[$i].","; }
		$p++; $i++;
		}
	chop $line1a;
	$line1a .= "), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".($Y1*$maxY).",".($Y2*$maxY)."), type =\"l\", lwd=2, col=\"black\", axes=FALSE, ann=FALSE)\n";
	}
return($line1a,$line1b);
}
###########################
#$line2: cmdR for cmdR for lines(intron)	
#$intron{$NM}{$startInt} = $endInt;
sub line2
{
my($maxY,$Y,$h1) = @_;
my%intron=%$h1;
my$line="";
my@startIntron = sort{$a<=>$b}keys%intron; 
for (my$ex=0;$ex<scalar@startIntron;$ex++)
	{ $line .= "lines (c(".$startIntron[$ex].",".$intron{$startIntron[$ex]}."),c(-".($Y*$maxY).",-".($Y*$maxY)."), lwd=3)\n"; }
return($line);
}
###########################
#cmdR for rect(bed) empty
#$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);	#empty black squares
#$line3b = line3a($maxY,$Y1,$Y2,\%Reg_00);	#full green squares
sub line3a
{
my($maxY,$Y1,$Y2,$h1) = @_;
my%NMbed00=%$h1;
my@startBed = sort{$a<=>$b}keys%NMbed00;
my$line = "rect (c(";
foreach my$start (@startBed)
	{ $line .= $start.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(@startBed);$i++)
	{ $line .= "-".($Y1*$maxY).","; }			
chop $line;
$line .= "), c(";
foreach my$start (@startBed)
	{ $line .= $NMbed00{$start}.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(@startBed);$i++)
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
$line .= "),";
return($line);
}
##########################
#$line3: cmdR for rect(not covered domains)
#$covEnd01{$file}{$NM}{$threshold}{$ex}{$notCovStart00} = $notCovEnd00;
#@{ $covStart01{$file}{$NM}{$threshold}{$ex} } = [ordered $notCovStarts00]
sub line3
{
my($maxY,$Y1,$Y2,$h1,$h2,$h3,$h4,$h5) = @_;
my@Thresholds=@$h1;
my@colors=@$h2;
my%Reg_00=%$h3;
my%covStart01=%$h4;
my%covEnd01=%$h5;
my$col=0;
my%line;
foreach my$threshold (@Thresholds)
	{
	my$ok=0;
	for (my$ex=0;$ex<(scalar(keys%Reg_00));$ex++)
		{
		if ( scalar(keys(%{ $covEnd01{$threshold}{$ex} })) != 0) 
			{ $ok = 1; last; } 
		}
	
	if ($ok)
		{
		$line{$threshold} = "rect (c(";
		for (my$ex=0;$ex<scalar(keys%Reg_00);$ex++)
			{			
			foreach my$pos (@{ $covStart01{$threshold}{$ex} })
				{ $line{$threshold} .= $pos.","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<scalar(keys%Reg_00);$ex++)
			{			
			for (my$i=0;$i<scalar@{ $covStart01{$threshold}{$ex} };$i++)
				{ $line{$threshold} .= "-".($Y1*$maxY).","; }
			}			
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<scalar(keys%Reg_00);$ex++)
			{
			foreach my$pos (@{ $covStart01{$threshold}{$ex} })
				{ $line{$threshold} .= $covEnd01{$threshold}{$ex}{$pos}.","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), c(";
		for (my$ex=0;$ex<scalar(keys%Reg_00);$ex++)
			{
			for (my$i=0;$i<scalar@{ $covStart01{$threshold}{$ex} };$i++)
				{ $line{$threshold} .= "-".($Y2*$maxY).","; }
			}
		chop $line{$threshold};
		$line{$threshold} .= "), lwd=0.01, col=\"".$colors[$col]."\", border =\"".$colors[$col]."\")\n";
		}
	$col++;
	}
return(%line);
}
#############################
#$line4a: cmdR for cmdR for rect(UTR exons)	
#$UTR{$NM}{$startUTR} = $endUTR;
sub line4a
{
my($maxY,$Y1,$Y2,$h1) = @_;
my%UTR=%$h1;
my@startUTR = sort{$a<=>$b}keys%UTR;
my$line = "rect (c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= $startUTR[$ex].","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= "-".($Y1*$maxY).","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= $UTR{$startUTR[$ex]}.","; }
chop $line;
$line .= "), c(";
for (my$ex=0;$ex<scalar@startUTR;$ex++)
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
$line .= "), lwd=2, col=\"blue\")\n";
return($line);
}
##########################
#$line4b: cmdR for rect(coding exons)	
#$Cod{$NM}{$startCod} = $endCod;
sub line4b
{
my($maxY,$Y1,$Y2,$h1) = @_;
my%Cod=%$h1;
my@startCod = sort{$a<=>$b}keys%Cod;
my$line = "rect (c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= $startCod[$ex].","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= "-".($Y1*$maxY).","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= $Cod{$startCod[$ex]}.","; }
chop $line;
$line .= "), c(";
foreach (my$ex=0;$ex<scalar@startCod;$ex++) 
	{ $line .= "-".($Y2*$maxY).","; }
chop $line;
$line .= "), lwd=2, col=\"blue\")\n";
return($line);
}
###########################
#$line4c: text Nb exon
#($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NMs[$i]} });
sub line4c
{
my($sens,$Rev,$maxY,$Y,$h1) = @_;
my%NM_Ex00=%$h1;	#%NM_Ex00{start of region}{start of exon} = end of exon (for start of region = 0)
my$line = "text( c(";
foreach my$startR (sort{$a<=>$b}keys%NM_Ex00) {
	foreach my$startBed (sort{$a<=>$b}keys%{ $NM_Ex00{$startR} })
		{ $line .= (($NM_Ex00{$startR}{$startBed}+$startBed)/2).","; }
	}
chop $line;
$line .= "), c(";
my$nEx=0;
foreach my$startR (keys%NM_Ex00) {
	for (my$i=0;$i<scalar(keys%{ $NM_Ex00{$startR} });$i++)
		{ $line .= "-".($Y*$maxY).","; $nEx++; }
	}		
chop $line;
$line .= "), c(";
my$i=1;
if ($Rev) {
	foreach my$startR (keys%NM_Ex00) {
		while ($i<=$nEx)
			{ $line .= "\"$i\" ,"; $i++; }
		}			
	}
else {
	if ($sens eq "-") {
		$i=$nEx;
		foreach my$startR (keys%NM_Ex00) {
			while ($i>0)
				{ $line .= "\"$i\" ,"; $i--; }
			}			
		}
	}
chop $line;
$line .= "), cex = 1)\n";
return($line);
}
##########################
#$line5: cmdR for legends
sub line5a
{
my($comp,$h1,$h2) = @_;
my@colors=@$h1;
my@Thresholds=@$h2;
my$line = "legend(\"topright\", legend = c(\">=$Thresholds[0]\",";
foreach my$threshold (@Thresholds)
	{ $line .="\"$comp$threshold\","; }
chop $line;
$line .= "), col = c(\"green\",";
for (my$i=0;$i<scalar(@Thresholds);$i++)
	{ $line .="\"".$colors[$i]."\","; }
chop $line;
$line .= "), pch = 15, bty = \"n\", pt.cex = 2.5, cex = 1, horiz = TRUE, inset = c(0, 0))\n";
return($line);
}
##########################
#$line5: cmdR for legends
sub line5b
{
my($comp,$h1,$h2) = @_;
my@colors=@$h1;
my@Thresholds=@$h2;
my$line = "legend(\"topright\", legend = c(";
foreach my$threshold (@Thresholds)
	{ $line .="\"$comp$threshold\","; }
chop $line;
$line .= "), col = c(";
for (my$i=0;$i<scalar(@Thresholds);$i++)
	{ $line .="\"".$colors[$i]."\","; }
chop $line;
$line .= "), pch = 15, bty = \"n\", pt.cex = 2.5, cex = 1, horiz = TRUE, inset = c(0, 0))\n";
return($line);
}
#############################
#$line6: cmdR for mutations (symbol)
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
sub line6a
{
my($maxY,$Y1,$Y2,$h1) = @_;
my%NMmut00=%$h1;
my$line="";
#above
$line .= "points(c(";
foreach my$mut (keys%NMmut00)
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%NMmut00);$i++)
	{ $line .= "-".($Y1*$maxY).","; }			
chop $line;
$line .= "), pch = 6, col = \"black\", lwd = 2, cex = 1)\n";
#below
$line .= "points(c(";
foreach my$mut (keys%NMmut00)
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%NMmut00);$i++)
	{ $line .= "-".($Y2*$maxY).","; }			
chop $line;
$line .= "), pch = 2, col = \"black\", lwd = 2, cex = 1)\n";
return($line);
}
##############################
#$line6b: cmdR for mutations (text)
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
sub line6b
{
my($maxY,$Y,$h1) = @_;
my%NMmut00=%$h1;
my$line="";
$line = "text( c(";
foreach my$mut (keys%NMmut00)
	{ $line .= $mut.","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar(keys%NMmut00);$i++)
	{ $line .= "-".($Y*$maxY).","; }			
chop $line;
$line .= "), c(";
foreach my$mut (keys%NMmut00)
	{ $line .= "\"".$NMmut00{$mut}."\" ,"; }			
chop $line;
$line .= "), adj = c(0.5,1.75), cex = 1.25, srt = -15)\n";
#$line .= "), pos = 1, cex = 1)\n";
#$line .= "), cex = 1)\n";
return($line);
}

##############################
#$line7: cmdR for text NM
sub line7
{
my($NMlength,$maxY,$h1) = @_;
my@NMs=@$h1;
my$line="";
$line = "text( c(";
for (my$i=0;$i<scalar@NMs;$i++)
	{ $line .= "-".(0.6*$NMlength/10).","; }
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar@NMs;$i++)
	{ $line .= "-".((0.425+0.25*$i)*$maxY).","; }		
chop $line;
$line .= "), c(";
for (my$i=0;$i<scalar@NMs;$i++)
	{ $line .= "\"".$NMs[$i]."\" ,"; }			
chop $line;
#$line .= "), adj = c(0,2), cex = 1)\n";
$line .= "), cex = 1.2)\n";
return($line);
}


##############################
#graph with all transcripts of a gene
sub graphSumG
{
#graphSumG($gene,$suff,$outdir,$sens,$chr,$NMlength{$gene},\@NMs,\@Files,\@colors,\@Thresholds,\%{ Regions{$chr}{$gene} },\%NM_Ex00,\%{ $NMbed00{$gene} },\%intron,\%UTR,\%Cod,\%{ $NMmut00{$gene} },\%{ $NMCovEnd{$gene} },\%{ $NMCovVal{$gene} });
my($nGraf,$gene,$suff,$outdir,$sens,$chr,$length,$h0,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12)= @_;
my@NMs=@$h0;
my@Files=@$h1;
my@colors=@$h2;
my@Thresholds=@$h3;
my%Regions=%$h4;
my%NM_Ex00=%$h5;
my%NMbed00=%$h6;
my%intron=%$h7;
my%UTR=%$h8;
my%Cod=%$h9;
my%NMmut00=%$h10;
my%NMCovEnd=%$h11;
my%NMCovVal=%$h12;

print "print CMDR graphByGeneG: $gene\n";
open (CMDR, ">$outdir/$gene\_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
my$nNM=scalar(@NMs);
my$maxY=scalar(@Files);
my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_covSum.png\", 1500, ".(400*(0.875+(0.125*$nNM))).")\n"; 

if ($sens eq "+")
	{ print CMDR 
"plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*scalar@NMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr\t$startReg >>> $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2)\n";
	}
else
	{ print CMDR 
"plot (c(0,0), xlim=c(-".(0.8*$length/10).",".$length."), ylim=c(-".((0.5+0.25*scalar@NMs)*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"chr $chr\t$startReg <<< $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2),labels=seq(0, $maxY, length = 2), las=2)\n";
	}

my($Y,$Y1,$Y2);
#$line1
#$NMCovEnd{$threshold}{$r}{$start}=$end
#$NMCovVal{$threshold}{$r}{$start}=$value
my$col=0;
my%line1;
#$line1: cmdR for plot cov line
foreach my$threshold (@Thresholds)
	{
	$line1{$threshold} = line1g2($colors[$col],\%{ $NMCovEnd{$threshold} },\%{ $NMCovVal{$threshold} });
	$col++;
	}

#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
my$line2="";
for(my$i=0;$i<scalar@NMs;$i++) { 
	$Y=(0.425+0.25*$i);
	$line2 .= line2($maxY,$Y,\%{ $intron{$NMs[$i]} });
	}

#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
$Y1=0.1;$Y2=0.25;
my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);

#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
my$line4a="";
for(my$i=0;$i<scalar@NMs;$i++) {
	if (scalar(keys%{ $UTR{$NMs[$i]} })!=0) {
		$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
		$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR{$NMs[$i]} });
		}
	}

#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
my$line4b="";
for(my$i=0;$i<scalar@NMs;$i++) {
	if (scalar(keys%{ $Cod{$NMs[$i]} })!=0) {
		$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
		$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod{$NMs[$i]} });
		}
	}

#$line4c: Nb exon
#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my$line4c="";
for(my$i=0;$i<scalar@NMs;$i++) {
	$Y=(0.3+0.25*$i);
	$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NMs[$i]} });
	}

#$line5: cmdR for legends
my$comp = ">=";
my$line5 = line5b($comp,\@colors,\@Thresholds);

#$line6: cmdR for mutations (symbol)
#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
my$line6a = ""; my$line6b = "";
if (scalar(keys%NMmut00) != 0)
	{
	$Y1=0.05;$Y2=(0.3+0.25*scalar@NMs);
	$line6a = line6a($maxY,$Y1,$Y2,\%NMmut00);
	#$line6b: cmdR for mutations (text)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	$Y=(0.3+0.25*scalar@NMs);
	$line6b = line6b($maxY,$Y,\%NMmut00);
	}

#$line7: NM names
my$line7 = line7($length,$maxY,\@NMs);

print CMDR "abline(h=0, col=\"black\", lty = \"dotted\", lwd=1)\n"; 
print CMDR "abline(h=$maxY, col=\"darkgrey\", lty = \"dotted\", lwd=1)\n"; 

foreach my$threshold (reverse@Thresholds)
	{ print CMDR $line1{$threshold}; }

print CMDR $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b.$line7;

print CMDR $line3a." lwd=1, col=NA, border =\"black\")\n";


print CMDR "mtext(\"$gene\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
print CMDR "dev.off();\n";
close CMDR;
system "Rscript $outdir/$gene\_temp.R";
unlink "$outdir/$gene\_temp.R";
}


##############################
#graph foreach transcript of a gene
sub graphSumN
{
#graphSumN($gene,$suff,$outdir,$sens,$chr,\%NMlength,\@NMs,\@Files,\@colors,\@Thresholds,\%Regions,\%NM_Ex00,\%NMbed00,\%intron,\%UTR,\%Cod,\%NMmut00,\%NMCovEnd,\%NMCovVal);
my($nGraf,$gene,$suff,$outdir,$sens,$chr,$h0,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11,$h12,$h13)= @_;
my%NMlength=%$h0;
my@NMs=@$h1;
my@Files=@$h2;
my@colors=@$h3;
my@Thresholds=@$h4;
my%Regions=%$h5;
my%NM_Ex00=%$h6;
my%NMbed00=%$h7;
my%intron=%$h8;
my%UTR=%$h9;
my%Cod=%$h10;
my%NMmut00=%$h11;
my%NMCovEnd=%$h12;
my%NMCovVal=%$h13;

print "print CMDR graphByGeneN: $gene\n";

my$nNM=scalar@NMs;
my$maxY=scalar(@Files);
if ($nGraf eq "max") { $nGraf = $nNM; }
my$cmdR = "";
my$i=1;my$n=1;my$N=1;
foreach my$NM (sort(@NMs))
	{
	my@Starts = sort{$a<=>$b}(keys%{ $Regions{$chr}{$NM} });
	my$startReg = $Starts[0];
	my$endReg = $Regions{$chr}{$NM}{$Starts[-1]};

	if ($sens eq "+")
		{ $cmdR .= 
"plot (c(0,0), xlim=c(0,".$NMlength{$NM}."), ylim=c(-".(0.6*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"transcript : $NM\t\tchr $chr\t$startReg >>> $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2), labels=seq(0, $maxY, length = 2), las=2)\n";
		}
	else
		{ $cmdR .= 
"plot (c(0,0), xlim=c(0,".$NMlength{$NM}."), ylim=c(-".(0.6*$maxY).",".(1.25*$maxY)."), type =\"l\", xlab = \"transcript : $NM\t\tchr $chr\t$startReg <<< $endReg\", ylab = \"nber of covered samples\", cex.lab=1.5, cex.axis=1.2, yaxt='n')
axis(2, at=seq(0, $maxY, length = 2), labels=seq(0, $maxY, length = 2), las=2)\n";
		}

	#$line1: cmdR for plot cov line
	#$NMCovEnd{$threshold}{$r}{$start}=$end
	#$NMCovVal{$threshold}{$r}{$start}=$value
	my$col=0;my($Y,$Y1,$Y2);
	my%line1;
	foreach my$threshold (@Thresholds) {
		$line1{$threshold} = line1g2($colors[$col],\%{ $NMCovEnd{$NM}{$threshold} },\%{ $NMCovVal{$NM}{$threshold} });
		$col++;
		}

	#$line2: cmdR for cmdR for lines(intron)	#$intron{$NM}{$startInt} = $endInt;
	$Y=0.425;
	my$line2 = line2($maxY,$Y,\%{ $intron{$NM} });

	#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$NM}{$startBed00} = $endBed00 (start of Region=0 )
	$Y1=0.1;$Y2=0.25;
	my$line3a = line3a($maxY,$Y1,$Y2,\%{ $NMbed00{$NM} });

	#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
	$Y1=0.375;$Y2=0.475;
	my$line4a = "";
	if (scalar(keys%{ $UTR{$NM} })!=0) { $line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR{$NM} }); }

	#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
	$Y1=0.35;$Y2=0.5;
	my$line4b = "";
	if (scalar(keys%{ $Cod{$NM} })!=0) { $line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod{$NM} }); }

	#$line4c: Nb exon
	#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
	$Y=0.3;
	my$line4c = line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NM} });

	#$line5: cmdR for legends
	my$comp = ">=";
	my$line5 = line5b($comp,\@colors,\@Thresholds);
	
	#$line6: cmdR for mutations (symbol)
	#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
	my$line6a = ""; my$line6b = "";
	if (scalar(keys%{ $NMmut00{$NM} }) != 0)
		{
		$Y1=0.05;$Y2=0.55;
		$line6a = line6a($maxY,$Y1,$Y2,\%{ $NMmut00{$NM} });
		#$line6b: cmdR for mutations (text)
		#$NMmut00{$NM}{$mut00} = $infoMut (start of Region=0 )
		$Y=0.5;
		$line6b = line6b($maxY,$Y,\%{ $NMmut00{$NM} });
		}
	
	$cmdR .= "abline(h=0, col=\"black\", lty = \"dotted\", lwd=1)\n";
	$cmdR .= "abline(h=$maxY, col=\"darkgrey\", lty = \"dotted\", lwd=1)\n"; 

	foreach my$threshold (reverse@Thresholds)
		{ $cmdR .= $line1{$threshold}; }

	$cmdR .= $line2.$line4a.$line4b.$line4c.$line5.$line6a.$line6b;

	$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
	

	if ($i==($nNM) || $n==$nGraf) {

		open (CMDR, ">$outdir/$gene\_temp.R") || die;
		print CMDR "#!/usr/bin/env Rscript\n\n" ;
		if ($nGraf==$nNM) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_covSum.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
		else {
			if ($N>1) { print CMDR
"png(\"".$outdir."/cov_All/".$gene."_covSum_$N.png\", 1500, ".($nGraf*400).")\n
par(mfrow=c($nGraf,1))\n"; }
			else { print CMDR 
"png(\"".$outdir."/cov_All/".$gene."_covSum_$N.png\", 1500, ".($n*400).")\n
par(mfrow=c($n,1))\n"; }
			}
		print CMDR "$cmdR";
		print CMDR "mtext(\"$gene\", side = 3, outer=TRUE, line=-3, cex=1.5)\n";
		print CMDR "dev.off();\n";
		close CMDR;
		system "Rscript $outdir/$gene\_temp.R";
		unlink "$outdir/$gene\_temp.R";
		$cmdR="";
		$n=0;
		$N++;
		}

	$i++;$n++;

	}

}


###############################
#graph line (disabled)
sub line1g
{
my($NM,$maxY,$Y1,$Y2,$NMlength,$color,$h1,$h2) = @_;
my%Reg_00=%$h1;
my%NMCov=%$h2;
my@startR = sort{$a<=>$b}keys%Reg_00;
my$line="";
for (my$n=0;$n<scalar@startR;$n++)
	{
	$line .= "par(new=TRUE)\nplot( c(";
	my$p=$startR[$n]; my$i=0;
	while ($i<scalar@{ $NMCov{$n} })
		{ $line .= $p.","; $p++; $i++; }
	chop $line;
	$line .= "), c(";
	$i=0;
	while ($i<scalar@{ $NMCov{$n} })
		{ $line .= $NMCov{$n}[$i].","; $i++; }
	chop $line;
	$line .= "), xlim=c(0,".$NMlength."), ylim=c(-".($Y1*$maxY).",".($Y2*$maxY)."), type =\"l\", lwd=2, col=\"$color\", axes=FALSE, ann=FALSE)\n";
	}
return($line);
}
####################################
#same but graph rect
sub line1g2
{
#$NMCovEnd{$threshold}{$NM}{$ex}{$start}=$end
#$NMCovVal{$threshold}{$NM}{$ex}{$start}=$value
my($color,$h1,$h2) = @_;
my%NMCovEnd=%$h1;
my%NMCovVal=%$h2;
my@startR = sort{$a<=>$b}keys%NMCovEnd;
my$line = "";
for (my$r=0;$r<scalar@startR;$r++)
	{
	my@Starts= sort{$a<=>$b}keys%{ $NMCovEnd{$startR[$r]} };
	$line .= "rect (c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= $Starts[$i].","; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= "0,"; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= $NMCovEnd{$startR[$r]}{$Starts[$i]}.","; }
	chop $line;
	$line .= "), c(";
	for (my$i=0;$i<scalar@Starts;$i++)
		{ $line .= $NMCovVal{$startR[$r]}{$Starts[$i]}.","; }
	chop $line;
	$line .= "), border=NA, col=\"$color\")\n";
	}
return($line);
}


############################
#covPlot($bin,$max2,"original",$bedName,\%path,$extenS,\@Files,\%fName,\%sName2,$outdir,\%withChr);
sub covPlot
{
my($bin,$max2,$outName,$h1,$extenS,$h2,$h3,$h4,$outdir,$h5)=@_;
my%path = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%sName2 = %$h4;
my%allInterval = %$h5;

open(OUT1, ">$outdir/covPlot/$outName\_binCovPlot.txt") || die "can't create $outdir/covPlot/$outName\_binCovPlot.txt\n";
open(OUT2, ">$outdir/covPlot/$outName\_sumCovPlot.txt") || die "can't create $outdir/covPlot/$outName\_sumCovPlot.txt\n";

print OUT1 "depth\t";
print OUT2 "depth\t";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	print OUT1 ($bin*$i)."-".(($bin*($i+1))-1)."\t";
	print OUT2 ">".($bin*$i)."\t";
	$i++;
	}
print OUT1 ">=$max2\n";
print OUT2 "\n";

my%isChr;
foreach(@Files) { 
	if ($withChr{$_}) { $isChr{$_} = $withChr{$_}; }
	else { $isChr{$_} = "_0Chr.bed"; }
	}

my(%hist,$lengthBed);

foreach my$file (@Files) {

	print "analysing ".$sName2{$file}." for plot on $outName\n";
	if ($gatk) {
		print "intersect $outdir/all.cov with $outName for histPlot\n";
		my@hashSub = intersectForHist($gatkIdx{$file},"$outdir/all.cov",$maxPl,\%allInterval,$gatk);
		$lengthBed = $hashSub[0];
		%hist = %{$hashSub[1]};
		}
	else {
		print "intersect $outdir/$fName{$file}.cov with $outName for histPlot\n";
		my@hashSub = intersectForHist($fName{$file},"$outdir/$fName{$file}.cov",$maxPl,\%allInterval,$gatk);
		$lengthBed = $hashSub[0];
		%hist = %{$hashSub[1]};
		}

	print OUT1 "sample_$sName2{$file}\t";
	my$histCount;
	my$i=0;
	while ( ($i*$bin) <= $max2 ) {
		$histCount=0;
		for (my$j=($bin*$i);$j<($bin*($i+1));$j++)
			{ if (exists$hist{$j}) { $histCount+=$hist{$j}; } }
		print OUT1 $histCount."\t";
		$i++;
		}
	my@array=sort{$a<=>$b}keys%hist;
	$histCount=0;
	for ($i=$max2;$i<=$#array;$i++)
		{ $histCount+=$hist{$array[$i]}; }
	print OUT1 $histCount."\n";

	print OUT2 "sample_$sName2{$file}\t";
	my$totCount=0;
	if (exists$hist{0}) { $totCount+=$hist{0}; }
	print OUT2 (1-$totCount)."\t";
	$i=0;
	while ( ($i*$bin) < $max2 ) {
		$histCount=0;
		for (my$j=(($bin*$i)+1);$j<=($bin*($i+1));$j++)
			{ if (exists$hist{$j}) { $histCount+=$hist{$j}; } }
		$totCount+=$histCount;
		print OUT2 (1-$totCount)."\t";
		$i++;
		}
	print OUT2 "\n";
	}
close(OUT1); 
close(OUT2);
#R barplot -sum, mean of all samples
if (scalar@Files>1)
	{ meanCovPlot($bin,$max2,$outdir,$outName,$lengthBed); }
#R barplot -sum, 1graph / sample
allCovPlot($bin,$max2,$outdir,$outName,$lengthBed,\@Files,\%sName2,$extenS);

return(%withChr)
}

##
sub intersectForHist
{
#if ($gatk) { my@hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxPl,\%allInterval,$gatk); }
#else { my@hashSub = intersect($fName{$file},"$outdir/$file.cov",$maxPl,\%allInterval,$gatk); }
my($file,$covName,$maxPl,$h1,$gatk) = @_;
my%Intervals = %$h1;

my$lengthBed=0;
my%allDepth;		#for hist depth : $allDepth{depth value} = nber pos with this depth

my$c=0;			#idx of $startByChr
my$chr = "";
my(%allChr,@Starts);
foreach (keys%Intervals) { $allChr{$_} = 1; }

if ($gatk) {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		my@tab2 = split(/:/,$tab[0]);
		if ($chr ne $tab2[0]) {
			if (exists $allChr{$tab2[0]}) {
				$chr = $tab2[0];
				@Starts = sort{$a<=>$b}(keys%{$Intervals{$chr} });
				$c=0;
				}
			else { next; }
			}
		while ( ($tab2[1] > $Intervals{$chr}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
			{ $c++; }
		if ( ($tab2[1] >= $Starts[$c]) && ($tab2[1] <= $Intervals{$chr}{$Starts[$c]}) ) {
			$lengthBed++;
			my$cov = $tab[$file];
			if ($maxPl) { if ($cov > $maxPl) { $cov = ($maxPl+1); } }
			$allDepth{$cov}++; 
			}
		if ( $tab2[1] > $Intervals{$chr}{$Starts[-1]} ) {
			my%tmp;
			foreach (keys%allChr) { 
				unless ($_ eq $chr) { $tmp{$_} = 1; }
				}
			%allChr = %tmp;
			}
		if (scalar(keys%allChr) == 0) { last; }
		}
	}
else {
	unless ( -s "$covName" ) { die "$covName not found or empty\n"; }
	open(COV, "$covName") || die "can't open file $covName\n";
	while (my$line=<COV>) {
		chomp $line;
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//;
		if ($chr ne $tab[0]) {
			if (exists $allChr{$tab[0]}) {
				$chr = $tab[0];
				@Starts = sort{$a<=>$b}(keys%{$Intervals{$chr} });
				$c=0;
				}
			else { next; }
			}
		while ( (($tab[1]+1) > $Intervals{$chr}{$Starts[$c]}) && ($c < (scalar@Starts-1)) )
			{ $c++; }
		if ( ($tab[2] >= $Starts[$c]) && (($tab[1]+1) <= $Intervals{$chr}{$Starts[$c]}) ) {
			$lengthBed++;
			my$cov = $tab[-1];
			if ($maxPl) { if ($cov > $maxPl) { $cov = ($maxPl+1); } }
			$allDepth{$cov}++; 
			}
		if ( ($tab[1]+1) > $Intervals{$chr}{$Starts[-1]} ) {
			my%tmp;
			foreach (keys%allChr) { 
				unless ($_ eq $chr) { $tmp{$_} = 1; }
				}
			%allChr = %tmp;
			}
		if (scalar(keys%allChr) == 0) { last; }	
		}
	close COV;
	}
foreach (keys%allDepth) { $allDepth{$_} = $allDepth{$_}/$lengthBed; }
return($lengthBed,\%allDepth);
}
##
sub meanCovPlot
{
my($bin,$max2,$outdir,$outName,$lengthBed) = @_;
print "doing meanCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_meanCovPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_sumCovPlot.txt\",header=T, row.names=1)
allMean = apply(mat,2,mean)
std = apply(mat,2,sd)
error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop(\"vectors must be same length\")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
}
barx <- barplot(allMean, names.arg=c(";
print CMDR $line;
print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"mean of all samples\", xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\")
error.bar(barx,allMean, 1.96*std/10)
dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}
##
sub allCovPlot
{
my($bin,$max2,$outdir,$outName,$lengthBed,$h1,$h2,$extenS) = @_;
my@Files = @$h1;
my%sampleName = %$h2;
print "doing allCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/hist_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_allCovPlot.png\", 800, ".(scalar@Files*250).")
par(mfrow=c(".scalar@Files.",1))
mat <- read.table(\"$outdir/covPlot/$outName\_sumCovPlot.txt\",header=T, row.names=1)\n";
foreach my$file (@Files) {
	print CMDR "barplot(t(matrix(mat[\"sample_$sampleName{$file}\",])), names.arg=c(";
	print CMDR $line;
	print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"$sampleName{$file}\",xlab=\"Depth\", ylab=\"fraction of $outName\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
	}
print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/hist_temp.R";
unlink "$outdir/hist_temp.R";
}
##
#R barplot -bin , mean of all samples
#binCovPlot($bin,$max2,$outdir,$outName,$lengthBed);
sub binCovPlot
{
my($bin,$max2,$outdir,$outName,$lengthBed) = @_;
print "doing binCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 )
	{
	$line .= "\"".($bin*$i)."-\",";
	$i++;
	}
$line .= "\">100\"";
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_binCovPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_binCovPlot.txt\",header=T, row.names=1)
mean1 = apply(mat,2,mean)
mean2 = mean1[1:length(mean1)-1] 
std1 = apply(mat,2,sd)
std2 = std1[1:length(std1)-1]
error.bar <- function(x, y, upper, lower=upper, length=0.1,...) {
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop(\"vectors must be same length\")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...) }
barx <- barplot(mean1, names.arg=c(";
print CMDR $line;
print CMDR "), col=\"blue\", axis.lty=1, main=\"mean of all samples\", xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\")
error.bar(barx,mean1, 1.96*std1/10)
dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}
##
#R barplot -bin , 1graph / sample
#allBinCovPlot($bin,$max2,$outdir,$outName,$lengthBed,\@Files,\%sName2);
sub allBinCovPlot
{
my($bin,$max2,$outdir,$outName,$lengthBed,$h1,$h2) = @_;
my@Files = @$h1;
my%sampleName = %$h2;
print "doing allBinCovPlot\n";
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 )
	{
	$line .= "\"".($bin*$i)."-\",";
	$i++;
	}
$line .= "\">100\"";
open (CMDR, ">$outdir/plot_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_allBinCovPlot.png\", 800, ".(scalar@Files*250).")
par(mfrow=c(".scalar@Files.",1))
mat <- read.table(\"$outdir/covPlot/$outName\_binCovPlot.txt\",header=T, row.names=1)\n";
foreach my$file (@Files)
	{
	print CMDR "barplot(t(matrix(mat[\"sample_$sampleName{$file}\",])), names.arg=c(";
	print CMDR $line;
	print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"$sampleName{$file}\",xlab=\"Depth\", ylab=\"fraction of $outName\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
	}

print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/plot_temp.R";
unlink "$outdir/plot_temp.R";
}


############################
sub InterS
{
my($bin,$maxPl,$maxGr,$h1,$outName,$h2,$h3,$outdir,$gatk,$h4)=@_;
my%intervals = %$h1;
my@Files = @$h2;
my%fName = %$h3;
my%gatkIdx = %$h4;
print "doing interPlot for $outName\n";
if (scalar(keys%Bed)!=0) {
	my@allBins; my$i=0;
	while ( ($i*$bin) <= $maxPl ) {
		push(@allBins,($bin*$i+1));
		$i++;
		}
	my(%nPos,%nCov);
	foreach (@allBins) 
		{ $nPos{$_}=0; $nCov{$_}=0; }
	#intersection
	foreach my$chr (keys%intervals) {
		#initialyzes %regCov
		my%regCov;
		foreach (@allBins) {
			my$r=0; #idx of reg of $NM
			foreach my$startReg (sort{$a<=>$b}keys%{ $intervals{$chr} }) {
				my$pos=$startReg;
				while ($pos <= $intervals{$chr}{$startReg} ) {
					push (@{ $regCov{$_}{$r} }, 0);
					$pos++;
					}
				$r++;
				}
			}
		foreach my$file (@Files) {
			#$depth{$loc} = depth
			if ($gatk)
				{ @hashSub = intersect($gatkIdx{$file},"$outdir/all.cov",$maxGr,$chr,\@allBins,\%{ $intervals{$chr} },$gatk); }
			else 
				{ @hashSub = intersect($fName{$file},"$outdir/$fName{$file}.cov",$maxGr,$chr,\@allBins,\%{ $intervals{$chr} },$gatk); }
			my%depth = %{ $hashSub[0] };
			#@{ $regCov{$threshold}{$nReg} } = [nber of covered samples foreach pos]
			foreach (@allBins)
				{ %{ $regCov{$_} } = covByThreshold($_,\%{ $intervals{$chr} },\%depth,\%{ $regCov{$_} }); }
			}
		foreach (@allBins) {
			foreach my$r (keys%{ $regCov{$_} }) {
				foreach my$d (@{ $regCov{$_}{$r} }) {
					$nPos{$_}++;
					if ($d==scalar@Files) 
						{ $nCov{$_}++; }
					}
				}
			}
		}
	#plot
	my$hist = "depth\t";
	$i=0;
	while ( ($i*$bin) <= $maxPl ) {
		$hist .= ">".($bin*$i)."\t";
		$i++;
		}
	chop $hist;
	$hist .= "\ncov\t";
	foreach (@allBins) 
		{ $hist .=  ($nCov{$_}/$nPos{$_})."\t"; }
	chop $hist; $hist .= "\n";
	open(OUT, ">$outdir/covPlot/$outName\_interPlot.txt") || die "can't create $outdir/covPlot/$outName\_interPlot.txt\n";
	print OUT $hist;
	close(OUT); 

	#R barplot -sum, 1graph / sample
	interPlot($bin,$maxPl,$nPos{$allBins[0]},$outdir,$outName);

	}
}
##
sub interPlot
{
my($bin,$max2,$lengthBed,$outdir,$outName) = @_;
my$line="";
my$i=0;
while ( ($i*$bin) <= $max2 ) {
	$line .= "\">".($bin*$i)."\",";
	$i++;
	}
chop $line;
open (CMDR, ">$outdir/hist_temp.R") || die;
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/covPlot/$outName\_interPlot.png\", 800, 500)
mat <- read.table(\"$outdir/covPlot/$outName\_interPlot.txt\",header=T, row.names=1)\n";
print CMDR "barplot(t(matrix(mat[\"cov\",])), names.arg=c(";
print CMDR $line;
print CMDR "), ylim=c(0,1), col=\"blue\", axis.lty=1, main=\"intersection of all samples\",xlab=\"Depth\", ylab=\"fraction of $outName ($lengthBed bp)\", cex.lab=1.2, cex.main=1.5, cex.axis=1.2, cex.names=1.2)\n";
print CMDR "dev.off();warnings();\n";
close CMDR;
system "Rscript $outdir/hist_temp.R";
unlink "$outdir/hist_temp.R";
}


################################

##$refBedLines = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$bedFile,$bedName,\%Bed,$pThreshold,$toReseq,\@covFields,$gatk,\%gatkIdx);
##$refBedLines = Bed_Cov(\@Files,\%fName,\%sName2,$outdir,$id2Bed,$bedName,\%coordBed,$pThreshold,$toReseq,\@covFields,$gatk,\%gatkIdx);

sub Bed_Cov
{
my($h1,$h2,$h3,$outdir,$bedFile,$bedName,$h4,$threshold,$toReseq,$bedReport,$h5,$gatk,$h6) = @_;
my@Files = @$h1;
my%fName = %$h2;
my%sName2 = %$h3;
my%mergeBed = %$h4;
my@covFields = @$h5;
my%gatkIdx = %$h6;

print "perform bed coverage by interval";
if ($threshold) { print " ($threshold X)\n"; }
else { print "\n"; }
open(BED, "$bedFile") || die "can't open file $bedFile\n";
my(@allLines,@bedLines,%Chr,%Start,%End,%Intervals,%Intervals2);
my$i=0;my$j=0;
while (my$line=<BED>) {
	$line =~ s/\s+$//;
	$allLines[$i] = $line;
	if (($line =~ /^\w+\t\d+\t\d+/)&&($line !~ /^#/)) {
		my@tab = split(/\t/,$line);
		$tab[0] =~ s/chr//i;
		$bedLines[$j]{"allLine"} = $line;
		$bedLines[$j]{"Chrom"} = $tab[0]; $bedLines[$j]{"Start"} = ($tab[1]+1); $bedLines[$j]{"End"} = $tab[2];
		$Chr{$i} = $tab[0]; $Start{$i} = ($tab[1]+1); $End{$i} = $tab[2];		##1-based
		$Intervals{$Chr{$i}}{$Start{$i}}{$End{$i}} = 1;
		$j++;
		}
	$i++;
	}
close BED;
foreach my$chr (keys%mergeBed) {
	foreach my$start (keys%{ $mergeBed{$chr} })
		{ $Intervals{$chr}{$start}{$mergeBed{$chr}{$start}} = 1; }
	}
foreach my$chr (keys%Intervals) {
	foreach my$start (keys%{ $Intervals{$chr} })
		{ @{ $Intervals2{$chr}{$start} } = sort{$a<=>$b}(keys%{ $Intervals{$chr}{$start} }); }
	}

my(%min,%max,%sum,%mean,%median,%cov,%notCov,%TotBases,%TotByCov);
foreach my$file (@Files) {
	print "\tfile $fName{$file}\n";
	my(%vals);
	foreach my$chr (keys%Intervals) {
		foreach my$start (keys%{ $Intervals{$chr} }) {
			foreach my$end (@{ $Intervals2{$chr}{$start} }) {
			#foreach my$end (keys%{ $Intervals{$chr}{$start} }) {
				$cov{$file}{$chr}{$start}{$end} = 0;
				$min{$file}{$chr}{$start}{$end} = 0;
				$max{$file}{$chr}{$start}{$end} = 0;
				@{ $vals{$chr}{$start}{$end} } = ();
				}
			}
		}
	my$c=0;			#idx of $startByChr
	my$chr = "";
	my(%allChr,@Starts,%noCovStart,%noCovEnd);
	foreach (keys%Intervals) { $allChr{$_} = 1; }

	if ($gatk) {
		unless ( -s "$outdir/all.cov" ) { die "$outdir/all.cov not found or empty\n"; }
		open(COV, "$outdir/all.cov") || die "can't open file $outdir/all.cov\n";
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			$tab[0] =~ s/chr//;
			my@tab2 = split(/:/,$tab[0]);
			my$pos = $tab2[1];
			if ($chr ne $tab2[0]) {
				if (exists $allChr{$tab2[0]}) {
					$chr = $tab2[0];
					@Starts = sort{$a<=>$b}(keys%{ $Intervals{$chr} });
					undef(%noCovStart); undef(%noCovEnd);
					foreach my$start (@Starts) {
						foreach (@{ $Intervals2{$chr}{$start} })
							{ $noCovStart{$start}{$_}=0; $noCovEnd{$start}{$_}=0; }
						}
					$c=0;		##@Starts iteration
					}
				else { next; }
				}
			while ( ($pos > $Intervals2{$chr}{$Starts[$c]}[-1]) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			my$c2 = $c;			##@Starts iteration within while loop
			if ($pos == $Starts[$c2]) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					$min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}];
					$max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}];
					}
				}
			while ( ($pos >= $Starts[$c2]) && ($c2 < (scalar@Starts-1)) ) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					if ($pos <= $end) {
						if ($threshold && $tab[$gatkIdx{$file}] >= $threshold)
							{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
						else {
							if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							else { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos;
								$noCovStart{$Starts[$c2]}{$end} = $pos;
								$noCovEnd{$Starts[$c2]}{$end} = $pos;
								}
							}
						if ($tab[$gatkIdx{$file}] < $min{$file}{$chr}{$Starts[$c2]}{$end})
							{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}]; }
						if ($tab[$gatkIdx{$file}] > $max{$file}{$chr}{$Starts[$c2]}{$end})
							{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}]; }
						push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[$gatkIdx{$file}]);
						}
				 	}
				$c2++;
				}
			foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
				if (($pos >= $Starts[$c2]) && ($pos <= $end)) {
					if ($threshold && $tab[$gatkIdx{$file}] >= $threshold)
						{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
					else {
						if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
							$noCovEnd{$Starts[$c2]}{$end} = $pos; 
							}
						else { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
							$noCovStart{$Starts[$c2]}{$end} = $pos; 
							$noCovEnd{$Starts[$c2]}{$end} = $pos; 
							}
						}
					if ($tab[$gatkIdx{$file}] < $min{$file}{$chr}{$Starts[$c2]}{$end})
						{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}]; }
					if ($tab[$gatkIdx{$file}] > $max{$file}{$chr}{$Starts[$c2]}{$end})
						{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[$gatkIdx{$file}]; }
					push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[$gatkIdx{$file}]);
					}
				}
			if ( $pos > $Intervals2{$chr}{$Starts[-1]}[-1] ) {
				my%tmp;
				foreach (keys%allChr) { 
					unless ($_ eq $chr) { $tmp{$_} = 1; }
					}
				%allChr = %tmp;
				}
			if (scalar(keys%allChr) == 0) { last; }
			}
		}

	else {
		unless ( -s "$outdir/$fName{$file}.cov" ) { die "$outdir/$fName{$file}.cov not found or empty\n"; }
		open(COV, "$outdir/$fName{$file}.cov") || die "can't open file $outdir/$fName{$file}.cov\n";
		while (my$line=<COV>) {
			chomp $line;
			my@tab = split(/\t/,$line);
			$tab[0] =~ s/chr//;
			if ($chr ne $tab[0]) {
				if (exists $allChr{$tab[0]}) {
					$chr = $tab[0];
					@Starts = sort{$a<=>$b}(keys%{ $Intervals{$chr} });
					undef(%noCovStart); undef(%noCovEnd);
					foreach my$start (@Starts) {
						foreach (@{ $Intervals2{$chr}{$start} })
							{ $noCovStart{$start}{$_}=0; $noCovEnd{$start}{$_}=0; }
						}
					$c=0;
					}
				else { next; }
				}
			my$pos=$tab[1]+$tab[-2];
			while ( ($pos > $Intervals2{$chr}{$Starts[$c]}[-1]) && ($c < (scalar@Starts-1)) )
				{ $c++; }
			my$c2 = $c;
			if ($pos == $Starts[$c2]) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					$min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1];
					$max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1];
					}
				}
			while ( ($pos >= $Starts[$c2]) && ($c2 < (scalar@Starts-1)) ) {
				foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
					if ($pos <= $end) {
						if ($threshold && $tab[-1] >= $threshold)
							{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
						else {
							if ( $pos == ($noCovEnd{$Starts[$c2]}{$end} + 1) ) { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}{$end}} = $pos ; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							else { 
								$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
								$noCovStart{$Starts[$c2]}{$end} = $pos; 
								$noCovEnd{$Starts[$c2]}{$end} = $pos; 
								}
							}
						if ($tab[-1] < $min{$file}{$chr}{$Starts[$c2]}{$end}) 
							{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
						if ($tab[-1] > $max{$file}{$chr}{$Starts[$c2]}{$end}) 
							{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
						push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[-1]);
						}
				 	}
				$c2++;
				}
			foreach my$end (@{ $Intervals2{$chr}{$Starts[$c2]} }) {
				if (($pos >= $Starts[$c2]) && ($pos <= $end)) {
					if ($threshold && $tab[-1] >= $threshold)
						{ $cov{$file}{$chr}{$Starts[$c2]}{$end}++; }
					else {
						if ( $pos == ($noCovEnd{$Starts[$c2]} + 1) ) { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$noCovStart{$Starts[$c2]}} = $pos ; 
							$noCovEnd{$Starts[$c2]} = $pos; 
							}
						else { 
							$notCov{$file}{$chr}{$Starts[$c2]}{$end}{$pos} = $pos ; 
							$noCovStart{$Starts[$c2]} = $pos; 
							$noCovEnd{$Starts[$c2]} = $pos; 
							}
						}
					if ($tab[-1] < $min{$file}{$chr}{$Starts[$c2]}{$end})
						{ $min{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
					if ($tab[-1] > $max{$file}{$chr}{$Starts[$c2]}{$end})
						{ $max{$file}{$chr}{$Starts[$c2]}{$end} = $tab[-1]; }
					push(@{ $vals{$chr}{$Starts[$c2]}{$end} },$tab[-1]);
					}
				 }
			if ( $pos > $Intervals2{$chr}{$Starts[-1]}[-1] ) {
				my%tmp;
				foreach (keys%allChr) { 
					unless ($_ eq $chr) { $tmp{$_} = 1; }
					}
				%allChr = %tmp;
				}
			if (scalar(keys%allChr) == 0) { last; }	
			}
		close COV;
		}
	foreach my$chr (keys%Intervals) {
		foreach my$start (keys%{ $Intervals{$chr} }) {
			foreach my$end (@{ $Intervals2{$chr}{$start} }) {
				my$len = $end-$start+1;
				#cov
				$cov{$file}{$chr}{$start}{$end} /= $len;
				#sum
				$sum{$file}{$chr}{$start}{$end} = 0;
				foreach (@{ $vals{$chr}{$start}{$end} }) 
					{ $sum{$file}{$chr}{$start}{$end} += $_; }
				#mean
				$mean{$file}{$chr}{$start}{$end} = ($sum{$file}{$chr}{$start}{$end} / $len);
				#median
				my@sortDepth=();
				for (my$i=0;$i<($len - scalar@{ $vals{$chr}{$start}{$end} });$i++) { push(@sortDepth,0); }
				push(@sortDepth,@{ $vals{$chr}{$start}{$end} });
				@sortDepth = sort{$a<=>$b}@sortDepth;
				#odd?
				if($len%2) 
					{ $median{$file}{$chr}{$start}{$end} = $sortDepth[int($len/2)]; }
				#even
				else 
					{ $median{$file}{$chr}{$start}{$end} = (($sortDepth[int($len/2)-1]+$sortDepth[int($len/2)])/2 ); }
				}
			}
		}
	foreach my$chr (keys%mergeBed) {
		foreach my$start (keys%{ $mergeBed{$chr} }) {
			foreach (@{ $vals{$chr}{$start}{$mergeBed{$chr}{$start}} }) {
				$TotBases{$file} += $_;
				if ($threshold && $_ >= $threshold)
					{ $TotByCov{$file} ++; }
				}
			}
		}
	}

my$meanTotBases=0;
foreach (@Files) { $meanTotBases += $TotBases{$_}; }
if ($meanTotBases)
	{ $meanTotBases /= scalar@Files; }
else { print "no bases sequenced within bed in all samples!\n"; }

my$TotLength = 0;
foreach my$chr (keys%mergeBed) {
	foreach my$start (keys%{ $mergeBed{$chr} })
		{ $TotLength += ($mergeBed{$chr}{$start} - $start + 1); }
	}


my$nCol;
for (my$i=0;$i<scalar@allLines;$i++) {
	if (($allLines[$i] =~ /^\w+\t\d+\t\d+/)&&($allLines[$i] !~ /^#/))
		{ $nCol = scalar(split(/\t/,$allLines[$i])); last; }
	}
open(OUT1, ">$outdir/$bedName.cov.txt") || die "can't create file $outdir/$bedName.cov.bed\n";
print OUT1 "##samples:";
for (my$i=0;$i<($nCol-1);$i++) { print OUT1 "\t"; }
foreach (@Files) { 
	print OUT1 "\t$sName2{$_}";
	for (my$i=1;$i<scalar@covFields;$i++) { print OUT1 "\t"; }
	}
print OUT1 "\n##bed col.";
for (my$i=0;$i<($nCol-1);$i++) { print OUT1 "\t"; }
foreach (@Files) {
	foreach(@covFields) {
		if ($_ eq "cov") { print OUT1 "\t%>=$threshold"."X"; }
		else { print OUT1 "\t$_"; }
		}
	}
print OUT1 "\n";
my%reseq;
if ($toReseq)
	{ open(OUT2, ">$outdir/$bedName.toReseq.txt") || die "can't create file $outdir/$bedName.toReseq.txt\n"; }
$j=0;
for (my$i=0;$i<scalar@allLines;$i++) {
	print OUT1 $allLines[$i];
	if (exists $Chr{$i}) {
		foreach my$file (@Files) { 
			$bedLines[$j]{$file}{"Cov"} = $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}};
			$bedLines[$j]{$file}{"Mean"} = $mean{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}};
			foreach(@covFields) {
				if ($_ eq "min") { print OUT1 "\t".$min{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "max") { print OUT1 "\t".$max{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "tot") { print OUT1 "\t".$sum{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}; }
				elsif ($_ eq "mean") { print OUT1 "\t".sprintf("%.1f",$mean{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}); }
				elsif ($_ eq "median") { print OUT1 "\t".sprintf("%.1f",$median{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}); }
				elsif ($_ eq "cov") { print OUT1 "\t".100*(sprintf("%.3f", $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}))."%"; }
				}
			if ($toReseq && $bedLines[$j]{$file}{"Cov"} < $toReseq) 
				{ push(@{ $reseq{$i} },"$sName2{$file} (".100*(sprintf("%.3f", $cov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}))."%)"); }
			}
		$j++;
		}
	print OUT1 "\n";
	if ($toReseq && exists $reseq{$i}) {
		print OUT2 $allLines[$i];
		foreach (@{ $reseq{$i} })
			{ print OUT2 "\t$_"; }
		print OUT2 "\n";
		}
	}
close OUT1; 
if ($toReseq) { close OUT2; }

if ($bedReport && $threshold) {
	foreach my$file (@Files) {
		open(OUT, ">$outdir/cov\_$sName2{$file}/$bedName.$sName2{$file}.notCov.txt") || die "can't create file $outdir/cov\_$sName2{$file}/$bedName.$sName2{$file}.notCov.bed\n";
		print OUT "depthAnd Coverage report on $bedName.bed for $sName2{$file} sample\n\n";
		print OUT "total length of bed : $TotLength bp\n\n";
		print OUT "total cov >=$threshold"."x : ".100*(sprintf("%.3f", ($TotByCov{$file}/$TotLength)))." %\n\n";
		print OUT "mean depth : ".sprintf("%.1f", ($TotBases{$file}/$TotLength))." x\n\n";
		print OUT "domains covered less than $threshold"."x\n";
		for (my$i=0;$i<scalar@allLines;$i++) {
			if (exists $Chr{$i}) {
				if (exists $notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}) {
					print OUT "\n".$allLines[$i]."\n";
					foreach (sort{$a<=>$b}keys%{ $notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}} }) {
						print OUT "\t".($_-1)."\t".$notCov{$file}{$Chr{$i}}{$Start{$i}}{$End{$i}}{$_}."\n";
						}
					}
				}
			}
		close OUT;
		}
	}

return(\@bedLines);
}



########################
#for $All $NM on same graph
sub CNVgraphByGene {

my($file,$suff,$outdir,$gene,$sens,$maxD,$Rev,$chr,$maxY,$threshold,$NMlength,$h1,$h2,$h3,$h4,$h5,$h6,$h7,$h8,$h9,$h10,$h11)= @_;

my@Files=@$h1;
my%sampleName=%$h2;
my%Regions=%$h3;		
my%Reg_00=%$h4;
my@NMs=@$h5;
my%NM_Ex00=%$h6;
my%NMbed00=%$h7;
my%intron=%$h8;
my%UTR=%$h9;
my%Cod=%$h10;
my%NMdepth=%$h11;

print "print CMDR CNVgraphByGene: $sampleName{$file} , $gene\n";

unless ($maxD) {
	if ($maxY<10) { $maxY = 10; }
	}

my@Starts = sort{$a<=>$b}(keys%Regions);
my$startReg = $Starts[0];
my$endReg = $Regions{$Starts[-1]};

my($Y,$Y1,$Y2);
#$line1: cmdR for plot cov line
my$line1="";
for (my$f=0;$f<scalar@Files;$f++) {
	unless ($Files[$f] eq $file) {
		#@{ $NMdepth{$file}{$ex} } = [ cov foreach ordered bp of exon ]
		$line1 .= line1c("black",\%Reg_00,\%{ $NMdepth{$Files[$f]} });
		}
	}
$line1 .= line1c("green",\%Reg_00,\%{ $NMdepth{$file} });

#$line2: cmdR for cmdR for lines(intron)	#$intron{$startInt} = $endInt;
my$line2="";
for(my$i=0;$i<scalar@NMs;$i++) { 
	$Y=(0.425+0.25*$i);
	$line2 .= line2($maxY,$Y,\%{ $intron{$NMs[$i]} });
	}

#$line3a: cmdR for rect(bed, empty)	#$NMbed00{$startBed00} = $endBed00 (start of Region=0 )
$Y1=0.1;$Y2=0.25;
my$line3a = line3a($maxY,$Y1,$Y2,\%NMbed00);


#$line4a: cmdR for cmdR for rect(UTR exons)	#$UTR{$NM}{$startUTR} = $endUTR;
my$line4a="";
for(my$i=0;$i<scalar@NMs;$i++) {
	if (scalar(keys%{ $UTR{$NMs[$i]} })!=0) {
		$Y1=(0.375+0.25*$i);$Y2=(0.475+0.25*$i);
		$line4a .= line4a($maxY,$Y1,$Y2,\%{ $UTR{$NMs[$i]} });
		}
	}

#$line4b: cmdR for rect(coding exons)	#$Cod{$NM}{$startCod} = $endCod;
my$line4b="";
for(my$i=0;$i<scalar@NMs;$i++) {
	if (scalar(keys%{ $Cod{$NMs[$i]} })) {
		$Y1=(0.35+0.25*$i);$Y2=(0.5+0.25*$i);
		$line4b .= line4b($maxY,$Y1,$Y2,\%{ $Cod{$NMs[$i]} });
		}
	}

#$line4c: Nb exon
#%NM_Ex00{NM}{start of region}{start of exon} = end of exon (for start of region = 0)
my$line4c="";
for(my$i=0;$i<scalar@NMs;$i++) {
	$Y=(0.3+0.25*$i);
	$line4c .= line4c($sens,$Rev,$maxY,$Y,\%{ $NM_Ex00{$NMs[$i]} });
	}

#$line7: NM names
my$line7 = line7($NMlength,$maxY,\@NMs);


#print CMDR:
open (CMDR, ">$outdir/$sampleName{$file}.$gene.temp.R") || die "cannot create $outdir/$sampleName{$file}.$gene.temp.R";
print CMDR "#!/usr/bin/env Rscript\n\n" ;
print CMDR "png(\"$outdir/$sampleName{$file}.$gene.png\", 1500, ".(400*(0.875+(0.125*scalar@NMs))).")\n";

my$cmdR = 
"plot (c(0,0), xlim=c(-".(0.8*$NMlength/10).",".$NMlength."), ylim=c(-".((0.5+0.25*scalar@NMs)*$maxY).",".(1.25*$maxY)."), type =\"n\", xlab = \"sample : $sampleName{$file}\", ylab = \"normalized_depth\", cex.lab=1.5, cex.axis=1.2)\n";#, yaxt='n')
#axis(2, at=seq(0, $maxY, length = 5), labels=seq(0, $maxY, length = 5), las=2)\n";

$cmdR .= $line1;

$cmdR .= "abline(h=0, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n";
if ($threshold) { $cmdR .= "abline(h=$threshold, col=\"darkgrey\", lty = \"dotted\", lwd=2)\n"; }

$cmdR .= $line2.$line4a.$line4b.$line4c.$line7;

$cmdR .= $line3a." lwd=1, col=NA, border =\"black\")\n";
#print "$cmdR\n";
print CMDR "$cmdR";
if ($sens eq "+") { print CMDR
"mtext(\"$gene\tchr $chr\t".$startReg." >>> ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
else { print CMDR 
"mtext(\"$gene\tchr $chr\t".$startReg." <<< ".$endReg."\", side = 3, outer=TRUE, line=-3, cex=1.5)\n"; }
print CMDR "dev.off();\n";
close CMDR;
system "Rscript $outdir/$sampleName{$file}.$gene.temp.R";
unlink "$outdir/$sampleName{$file}.$gene.temp.R";


}


########################
sub line1c
{
my($col,$h1,$h2) = @_;
my%Reg_00=%$h1;
my%NMdepth=%$h2;
my@startR = sort{$a<=>$b}keys%Reg_00;
my$line1="";
my$p=0;my$i=0;
for (my$n=0;$n<scalar@startR;$n++)
	{
	$line1 .= "lines( c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ $NMdepth{$n} })
		{ $line1 .= $p.","; $p++; $i++; }
	chop $line1;
	$line1 .= "), c(";
	$p=$startR[$n]; $i=0;
	while ($i<scalar@{ $NMdepth{$n} }) {
		if ($NMdepth{$n}[$i] eq "") { $line1 .= "0,"; }
		else { $line1 .= $NMdepth{$n}[$i].","; }
		$p++; $i++;
		}
	chop $line1;
	$line1 .= "), type =\"l\", lwd=2, col=\"$col\")\n";
	}
return($line1);
}


############################
#print tests:

#	print "Regions:\n";	# $Regions{chr}{NM}{start of region} = end of region
#	foreach my$chr(sort(keys%Regions)) {
#		foreach my$NM (sort(keys%{ $Regions{$chr} })) {
#			foreach my$startR (sort{$a<=>$b}keys%{ $Regions{$chr}{$NM} })
#				{ print $chr."\t".$NM."\t".$startR."\t".$Regions{$chr}{$NM}{$startR}."\n"; }
#			}
#		}

#	print "NM_Ex:\n";	# %NM_Ex{NM}{start of region}{start of exon} = end of exon
#	foreach (sort(keys%NM_Ex)) {
#		foreach my$startR (sort{$a<=>$b}keys%{ $NM_Ex{$_} }) {
#			foreach my$startN (sort{$a<=>$b}keys%{ $NM_Ex{$_}{$startR} })
#				{ print $_."\t".$startR."\t".$Regions{$NMchr{$_}}{$NMgene{$_}}{$startR}."\n\t\t".$startN."\t".$NM_Ex{$_}{$startR}{$startN}."\n"; }
#			}
#		}

#	print "introns:\n";	# $intron{$NM}{$startIntron} = $endIntron
#	foreach my$NM (sort(keys%intron)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $intron{$NM} }))
#			{ print $NM."\t".$start."\t".$intron{$NM}{$start}."\n"; }
#		}
#	print "UTRs:\n";	# $UTR{$NM}{$startUTR} = $endUTR
#	foreach my$NM (sort(keys%UTR)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $UTR{$NM} }))
#			{ print $NM."\t".$start."\t".$UTR{$NM}{$start}."\n"; }
#		}
#	print "Cods:\n";	# $Cod{$NM}{$startCod} = $endCod
#	foreach my$NM (sort(keys%Cod)) {
#		foreach my$start (sort{$a<=>$b}(keys%{ $Cod{$NM} }))
#			{ print $NM."\t".$start."\t".$Cod{$NM}{$start}."\n"; }
#		}


##############
#gatk:
#-omitIntervals	
#outName.sample_interval_statistics	not used (eq to sum)
#outName.sample_interval_summary		for bed (remove 4,5,6e col)

#-omitLocusTable				not used
#outName.sample_cumulative_coverage_counts
#outName.sample_cumulative_coverage_proportions

#-omitSampleSummary		
#outName.sample_statistics		for hist
#outName.sample_summary

#-omitBaseOutput				if only plot

#options:
#--nBins	499 	Number of bins to use for granular binning

#--start	1 	Starting (left endpoint) for granular binning

#--stop		500 	Ending (right endpoint) for granular binning

#$intervalName-all.cov
#Locus	Total_Depth	Average_Depth_sample	Depth_for_01	Depth_for_02	Depth_for_03
#chr1:43390947	244	81.33	43	124	77
#chr1:43390948	248	82.67	44	125	79

